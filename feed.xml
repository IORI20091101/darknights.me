<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-03-19T10:00:29+00:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">vim快捷键和配置</title><link href="/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2018/03/15/vim-config/" rel="alternate" type="text/html" title="vim快捷键和配置" /><published>2018-03-15T00:00:00+00:00</published><updated>2018-03-15T00:00:00+00:00</updated><id>/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2018/03/15/vim-config</id><content type="html" xml:base="/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2018/03/15/vim-config/">&lt;h3 id=&quot;vim快捷键和配置&quot;&gt;vim快捷键和配置&lt;/h3&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/SpaceVim/SpaceVim&quot;&gt;SpaceVim&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://vim-bootstrap.com/&quot;&gt;vim-bootstrap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="生产工具" /><category term="Vim" /><category term="IDE" /><summary type="html">vim快捷键和配置</summary></entry><entry><title type="html">使用electron进行桌面开发笔记</title><link href="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2018/03/15/electron-develop-step1/" rel="alternate" type="text/html" title="使用electron进行桌面开发笔记" /><published>2018-03-15T00:00:00+00:00</published><updated>2018-03-15T00:00:00+00:00</updated><id>/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2018/03/15/electron-develop-step1</id><content type="html" xml:base="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2018/03/15/electron-develop-step1/">&lt;h3 id=&quot;使用electron进行桌面开发笔记&quot;&gt;使用electron进行桌面开发笔记&lt;/h3&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wizardforcel.gitbooks.io/electron-doc/content/tutorial/devtools-extension.html&quot;&gt;electron文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="Nodejs" /><category term="javascript" /><summary type="html">使用electron进行桌面开发笔记</summary></entry><entry><title type="html">Css布局研究之Flex布局总结（一）</title><link href="/css/2017/12/25/css-layout/" rel="alternate" type="text/html" title="Css布局研究之Flex布局总结（一）" /><published>2017-12-25T00:00:00+00:00</published><updated>2017-12-25T00:00:00+00:00</updated><id>/css/2017/12/25/css-layout</id><content type="html" xml:base="/css/2017/12/25/css-layout/">&lt;h2 id=&quot;flex布局&quot;&gt;Flex布局&lt;/h2&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-examples.html&quot;&gt;Flex 布局教程：实例篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="Flex - Css布局" /><summary type="html">Flex布局</summary></entry><entry><title type="html">初涉Android</title><link href="/android/2017/12/20/android-start/" rel="alternate" type="text/html" title="初涉Android" /><published>2017-12-20T00:00:00+00:00</published><updated>2017-12-20T00:00:00+00:00</updated><id>/android/2017/12/20/android-start</id><content type="html" xml:base="/android/2017/12/20/android-start/">&lt;h2 id=&quot;android环境安装&quot;&gt;Android环境安装&lt;/h2&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.androiddevtools.cn/&quot;&gt;AndroidDevTools&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="Android" /><summary type="html">Android环境安装</summary></entry><entry><title type="html">高性能网站建设指南</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2017/12/20/read-book-web/" rel="alternate" type="text/html" title="高性能网站建设指南" /><published>2017-12-20T00:00:00+00:00</published><updated>2017-12-20T00:00:00+00:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2017/12/20/read-book-web</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2017/12/20/read-book-web/">&lt;h1 id=&quot;高性能网站建设指南-前端工程师技能精髓&quot;&gt;高性能网站建设指南-前端工程师技能精髓&lt;/h1&gt;

&lt;h2 id=&quot;减少http请求&quot;&gt;减少HTTP请求&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;性能黄金法则&lt;/code&gt;提示了只有10%~20%响应时间花在了HTML文档上其他都用在了加载各种组件包括（图片，样式表，脚本，falsh）进行的HTTP请求上。因此改善响应时间的最简单途径就是减少组件数量，并由此减少请求数量&lt;/p&gt;

&lt;p&gt;可以以下通过方式&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;CSS Sprites&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;内联图片 data:URL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;合并脚本和样式表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;data:URL模式首次在1995年被提议其格式如下 :&lt;code&gt;data:mediatype;base64,data&lt;/code&gt;
其他类似的模式还有
 ftp:，file:， mailto:， smtp:， pop:， dns:， whois:， finger:， daytime:，news: ， run:
需要注意的是内联图片不被IE支持，而且增加了文档的大小如果存在于HTML当中首次下载的文档大小会变大，鉴于此可以将内联图片放到css当中这样可以让图片可以被缓存而且这样减少了一个图片的http请求。&lt;/p&gt;

&lt;h2 id=&quot;使用内容发布网络cdn&quot;&gt;使用内容发布网络CDN&lt;/h2&gt;
&lt;p&gt;合理使用cdn会很大程度增加网站响应速度而且价格不贵，比如本站使用的又拍云（非广告），即使被DDOS了也花不了多少&lt;/p&gt;

&lt;h2 id=&quot;添加expires头&quot;&gt;添加Expires头&lt;/h2&gt;
&lt;p&gt;通过设置一个长久有效的Expires头可以使web组件被缓存。web服务器通过Expires头来告诉Web客户端它可以使用一个组件的当前副本直到制定的时间为止。
但是由于Expires是一个特定时间，它要求服务器跟客户端始终严格同步（通常很难保证），所以需要跟Cache-Control: max-age=31500000 配合使用该项配置告诉客户端该组件过多长时间才会失效而不是到某一个时间失效。
如果两者同时出现max-age指令会覆盖Expires头。
比较幸运的是mod_expires Apache模块能够使用Expires头时能像max-age那样以相对的方式设置日期。使用Expire-Default指令来完成。设置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;FilesMatch &quot;\.(gif|jpg|js|css)$&quot;&amp;gt;
        ExpiresDefault &quot;access plus 10 years&quot;
    &amp;lt;/FileMatch&amp;gt;
    //该指令会同时向响应中发送Expires头和Cache-Contral max-age,响应格式如下：
    Expires: Wed, 16 Oct 2024 05:43:02 GMT
    Cache-control: max-age=315360000

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过设置Expires头可以避免额外的http请求，减少一半的响应时间。&lt;/p&gt;

&lt;p&gt;##压缩组件
使用gzip来压缩组件，从HTTP1.1开始Web客户端可以通过HTTP请求中的: Accept-Enconding: gzip,deflate  来表示对于压缩的支持，如果Web服务器看到请求中有这个头就会使用客户端列出来的方法中的一种来压缩响应。Web服务器通过响应中的Content-Encoding头来通知客户端 : Content-Encoding: gzip.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;gzip是目前最流行和最有效的压缩方法， 另外一种deflate的方式效果略逊且不流行，因此gzip使最理想的压缩方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配置gzip使用的模块取决于Apache的版本&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Apache1.3使用mod_gzip&lt;/li&gt;
  &lt;li&gt;Apache2.x使用mod_deflate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前的状况是浏览器与服务器直接连接并没有任何问题，但是如果中间有代理服务器的话有两种情况
情况一：Web客户端不支持gzip发送到代理服务器，代理服务器向服务器请求得到未压缩的组件，然后组件被代理服务器缓存，此后对该组件的所有请求都走缓存，组件失去了压缩的机会，即使以后的客户端支持gzip也没用了
情况二：如何顺序相反缓存的则是gzip压缩后的组件，这样一个不支持gzip的Web浏览器无法正常解压导致组件可能失效。
无论哪种情况都不是我们希望见到的，解决这个问题的方式是在Web服务器的响应中添加Vary头。Web服务器可以告诉代理根据一个或多个请求头来改变缓存响应，由于压缩决定基于Accept-Encoding请求头的，因此需要在服务器的Vary响应中包含Accept-Encoding.  如 Vary: Accept-Encoding
这使得代理会缓存两个版本的内容如果有设置Accept-Encoding: gzip,deflate的返回压缩版本，没有设置的返回未压缩版本。
还可以把在Apache设置支持和不支持gzip白名单将User-Agent加入Vary如 &lt;code&gt;Vary: Accept-Encoding,User-Agent&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;将样式表放在顶部&quot;&gt;将样式表放在顶部&lt;/h2&gt;
&lt;p&gt;最好的实践是将Css放到head标签中防止FOUC（Flash Of Unstyled Content）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;和A不一样，[LINK]只能出现在文档的HEAD中，但出现的次数时任意的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CSS放到底部会在IE导致白屏&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;在新窗口打开时&lt;/li&gt;
    &lt;li&gt;重新加载时&lt;/li&gt;
    &lt;li&gt;作为主页时&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;将脚本放到底部&quot;&gt;将脚本放到底部&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;脚本会阻塞后面组件的下载&lt;/li&gt;
    &lt;li&gt;脚本会阻塞后面内容的呈现&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以最佳的位置就是放到页面body最底部&lt;/p&gt;

&lt;h2 id=&quot;避免css表达式&quot;&gt;避免CSS表达式&lt;/h2&gt;
&lt;p&gt;css表达式使用不当会导致频繁的求值导致地下的性能&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以明确的一点是不了解底层影响的情况下使用css表达式是非常危险的，所以尽量避免使用CSS表达式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用外部的javascript和css&quot;&gt;使用外部的Javascript和CSS&lt;/h2&gt;

&lt;p&gt;组件的引入不外乎内联和外置。就纯粹而已内联要快一些但是我们还是会使用外置的css和脚本，这是因为外置的组件是会被缓存的导致以后的请求会从浏览器缓存读渲染会更快，而内联的脚本会导致html体积增大但是HTML是不会缓存的这样每次请求的html体积都会很大，造成额外的带宽消耗。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加载后下载脚本可以在第一次加载内联的组件然后异步加载外部组件以便为下次加载提供便利这里使用的html是不一样的需要注意。&lt;/li&gt;
  &lt;li&gt;动态内联，使用cookie来让后台决定返回那个页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;减少dns查找&quot;&gt;减少DNS查找&lt;/h2&gt;
&lt;p&gt;根据HTTP1.1规范，建议浏览器从每个主机名并行下载两个组件，如果一个web页面平均的将组件放到两个主机名下整体响应时间会减少一半。
Yahoo研究表明使用两个主机名比使用1，4，10个主机名能带来更好的性能。因此建议将组件分别放到至少两个但是不超过四个与主机名下，这样不会造成过多的DNS查找，又可以为并行下载。&lt;/p&gt;

&lt;h2 id=&quot;精简javascript&quot;&gt;精简Javascript&lt;/h2&gt;

&lt;p&gt;可以使用gulp等工具对脚本和css进行混淆，精简和压缩，服务端开启gzip，以减少文件的体积大小。&lt;/p&gt;

&lt;h2 id=&quot;避免重定向&quot;&gt;避免重定向&lt;/h2&gt;
&lt;p&gt;比如为了使用www.xxx.com 重定向到 www.xxx.com/ 这种是不推荐的，我们只需要使用服务端配置，无需重定向就能拥有如此简洁的url即可&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;寻找一种避免重定向的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;删除重复脚本&quot;&gt;删除重复脚本&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;确保脚本只被包含一次&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以添加文件MD5后缀或者时间戳来保证文件是不同的&lt;/p&gt;

&lt;h2 id=&quot;配置或删除etag&quot;&gt;配置或删除ETag&lt;/h2&gt;
&lt;p&gt;ETag，一般建议移除ETag&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;比较最新修改日期 Last-Modified
比较实体标签 ETag&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使ajax可缓存&quot;&gt;使Ajax可缓存&lt;/h2&gt;
&lt;p&gt;真实情况ajax一般不缓存
缓存可以缓存的ajax请求，通过修改cache-control&lt;/p&gt;

&lt;h2 id=&quot;析构网站的工具&quot;&gt;析构网站的工具&lt;/h2&gt;
&lt;p&gt;YSlow&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><summary type="html">高性能网站建设指南-前端工程师技能精髓</summary></entry><entry><title type="html">解读V8 GC</title><link href="/node.js/2017/12/20/node-gc/" rel="alternate" type="text/html" title="解读V8 GC" /><published>2017-12-20T00:00:00+00:00</published><updated>2017-12-20T00:00:00+00:00</updated><id>/node.js/2017/12/20/node-gc</id><content type="html" xml:base="/node.js/2017/12/20/node-gc/">&lt;h2 id=&quot;lodashjs源码阅读分析一&quot;&gt;Lodash.js源码阅读分析（一）&lt;/h2&gt;
&lt;p&gt;通过详细阅读lodash的源码，学习代码风格同时补充基础。&lt;/p&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://alinode.aliyun.com/blog/37&quot;&gt;Node.js 应用背景与 GC 基础知识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://v8project.blogspot.co.uk/&quot;&gt;V8 JavaScript Engine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="Node.js" /><summary type="html">Lodash.js源码阅读分析（一） 通过详细阅读lodash的源码，学习代码风格同时补充基础。</summary></entry><entry><title type="html">前端构建工具fit&amp;amp;webpack</title><link href="/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/2017/11/23/fit-webpack/" rel="alternate" type="text/html" title="前端构建工具fit&amp;webpack" /><published>2017-11-23T00:00:00+00:00</published><updated>2017-11-23T00:00:00+00:00</updated><id>/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/2017/11/23/fit-webpack</id><content type="html" xml:base="/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/2017/11/23/fit-webpack/">&lt;h2 id=&quot;lodashjs源码阅读分析一&quot;&gt;Lodash.js源码阅读分析（一）&lt;/h2&gt;
&lt;p&gt;通过详细阅读lodash的源码，学习代码风格同时补充基础。&lt;/p&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/camsong/blog/issues/2&quot;&gt;Ajax已死，fetch永生&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="webpack" /><category term="前端构建工具" /><summary type="html">Lodash.js源码阅读分析（一） 通过详细阅读lodash的源码，学习代码风格同时补充基础。</summary></entry><entry><title type="html">放弃ajax拥抱fetch</title><link href="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/23/ajax-fetch/" rel="alternate" type="text/html" title="放弃ajax拥抱fetch" /><published>2017-11-23T00:00:00+00:00</published><updated>2017-11-23T00:00:00+00:00</updated><id>/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/23/ajax-fetch</id><content type="html" xml:base="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/23/ajax-fetch/">&lt;h2 id=&quot;lodashjs源码阅读分析一&quot;&gt;Lodash.js源码阅读分析（一）&lt;/h2&gt;
&lt;p&gt;通过详细阅读lodash的源码，学习代码风格同时补充基础。&lt;/p&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/camsong/blog/issues/2&quot;&gt;Ajax已死，fetch永生&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="ES6学习笔记" /><category term="javascript" /><summary type="html">Lodash.js源码阅读分析（一） 通过详细阅读lodash的源码，学习代码风格同时补充基础。</summary></entry><entry><title type="html">vps各种玩法</title><link href="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/11/23/vps-func/" rel="alternate" type="text/html" title="vps各种玩法" /><published>2017-11-23T00:00:00+00:00</published><updated>2017-11-23T00:00:00+00:00</updated><id>/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/11/23/vps-func</id><content type="html" xml:base="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/11/23/vps-func/">&lt;h2 id=&quot;vps各种玩法&quot;&gt;vps各种玩法&lt;/h2&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jecvay.com/2015/01/learning-vps-3.html&quot;&gt;vps各种玩法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.lichanglin.cn/%E5%88%A9%E7%94%A8vps%E6%90%AD%E5%BB%BABT%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD/&quot;&gt;利用vps搭建BT离线下载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://t.du9l.com/2011/02/post2/&quot;&gt;在Linux VPS上下载BT的配置方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xubiji.com/11658.html&quot;&gt;Cloud Torrent 安装教程 – 支持BT种子、磁力链接远程离线下载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yepster.me/vps/&quot;&gt;一个野生互联网爱好者拿 VPS 干了些什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zrj96.com/post-296.html&quot;&gt;Debian系统下Aria2+AriaNg+h5ai实现离线下载与在线播放&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.senra.me/aria2-and-plex-build-your-own-cloud-video-streaming-service/&quot;&gt;Aria2+Plex实现支持离线下载的小型私人视频云盘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="vps" /><summary type="html">vps各种玩法</summary></entry><entry><title type="html">Generator函数的含义和用法</title><link href="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/20/js-generator/" rel="alternate" type="text/html" title="Generator函数的含义和用法" /><published>2017-11-20T00:00:00+00:00</published><updated>2017-11-20T00:00:00+00:00</updated><id>/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/20/js-generator</id><content type="html" xml:base="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/20/js-generator/">&lt;h2 id=&quot;同步和异步&quot;&gt;同步和异步&lt;/h2&gt;
&lt;p&gt;要了解generator首先需要说一下异步和同步，大家都知道，Javascript的语言执行环境是单线程（Single thread）.所谓&lt;code&gt;单线程&lt;/code&gt;，就是只一次只能完成一个任务如果有多个任务就需要排队，前面一个任务完成，再执行后面一个任务，一次类推。
这种做法&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;好处是实现起来比较简单，执行环境相对单纯.&lt;/li&gt;
    &lt;li&gt;坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了解决上面的问题javascript将语言执行分成了两种： 同步（Synchronous）和异步（Asynchronous）.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;同步模式即从上往下依次执行，等待前一个任务执行完成后在执行下一个任务，执行顺序与代码顺序是一样的。&lt;/li&gt;
  &lt;li&gt;异步模式是每一个任务有一个或者多个回调函数，前一个任务结束后不执行下一个任务而是执行毁掉函数，后一个任务不等前一个任务结束就执行。执行顺序与代码顺序是不一致的，异步的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;异步模式的四种方法&quot;&gt;异步模式的四种方法&lt;/h2&gt;

&lt;h3 id=&quot;回调函数&quot;&gt;回调函数&lt;/h3&gt;

&lt;p&gt;如果有两个函数f1和f2,后者等待前者的执行结果。但是f1是一个很耗时的任务可以将f2写成f1的回调函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    function f1(callback) {
        setTimeout(function() {
            // f1的任务代码
            callback();
        },1000)
    }

    f1(f2);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。&lt;/p&gt;

&lt;h3 id=&quot;事件监听&quot;&gt;事件监听&lt;/h3&gt;
&lt;p&gt;采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生，直接上代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    f1.on('done', f2); //f1监听'done'如果触发该事件执行f2,使用了jQuery的事件监听
    function f1(callback) {
        setTimeout(function() {
            // f1的任务代码

            f1.trigger('done');
        },1000)
    }

    f1(f2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;发布订阅&quot;&gt;发布、订阅&lt;/h3&gt;

&lt;p&gt;我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做
&lt;a href=&quot;http://en.wikipedia.org/wiki/Publish-subscribe_pattern&quot;&gt;“发布/订阅模式”（publish-subscribe pattern）&lt;/a&gt;，又称&lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;“观察者模式”（observer pattern）&lt;/a&gt;。
这个模式有&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/hh201955.aspx?f=255&amp;amp;MSPPError=-2147217396&quot;&gt;多种实现&lt;/a&gt;,本例子使用&lt;a href=&quot;https://gist.github.com/661855&quot;&gt;Tiny Pub/Sub&lt;/a&gt;,这是一个jQuery插件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    jQuery.subscribe(&quot;done&quot;, f2); //首先，f2向&quot;信号中心&quot;jQuery订阅&quot;done&quot;信号。

    function f1(){
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　jQuery.publish(&quot;done&quot;);
　　　　}, 1000);
　　}
//jQuery.publish(&quot;done&quot;)的意思是，f1执行完成后，向&quot;信号中心&quot;jQuery发布&quot;done&quot;信号，从而引发f2的执行。
//此外，f2完成执行后，也可以取消订阅（unsubscribe）。
　　jQuery.unsubscribe(&quot;done&quot;, f2);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;promises&quot;&gt;Promises&lt;/h3&gt;
&lt;p&gt;Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。
它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    function f1(){
　　　　var dfd = $.Deferred();
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　dfd.resolve();
　　　　}, 500);
　　　　return dfd.promise;
　　}

　　f1().then(f2);
　　f1().then(f2).then(f3);
　　f1().then(f2).fail(f3);


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。&lt;/p&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/04/generator.html&quot;&gt;Generator 函数的含义与用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="ES6学习笔记" /><category term="javascript" /><summary type="html">同步和异步 要了解generator首先需要说一下异步和同步，大家都知道，Javascript的语言执行环境是单线程（Single thread）.所谓单线程，就是只一次只能完成一个任务如果有多个任务就需要排队，前面一个任务完成，再执行后面一个任务，一次类推。 这种做法 好处是实现起来比较简单，执行环境相对单纯. 坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</summary></entry></feed>