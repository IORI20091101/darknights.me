<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-09-06T11:38:40+08:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">LeetCode刷题总结(简单版三)</title><link href="/leetcode/2019/09/05/leetcode-three/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版三)" /><published>2019-09-05T00:00:00+08:00</published><updated>2019-09-05T00:00:00+08:00</updated><id>/leetcode/2019/09/05/leetcode-three</id><content type="html" xml:base="/leetcode/2019/09/05/leetcode-three/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1自除数&quot;&gt;1.自除数&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/self-dividing-numbers/&quot;&gt;自除数&lt;/a&gt;：
自除数 是指可以被它包含的每一位数除尽的数。
例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
还有，自除数不允许包含 0 。
给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个输入参数的边界满足 1 &amp;lt;= left &amp;lt;= right &amp;lt;= 10000。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入： 
上边界left = 1, 下边界right = 22
输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一：&lt;/h4&gt;
&lt;p&gt;分析： 关键点就是对数字进行拆分取整数和取余数,我自己的解法代码有点复杂冗余，下面是根据题解的优化方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var selfDividingNumbers = function (left, right) {
    let arr = [];
    for(let i = left; i &amp;lt;= right; i++) {
        let n = i;
        let flag = true;
        while(n) {
            if (i % (n % 10) === 0) {
                n = Math.floor(n / 10);
            } else {
                flag = false;
                break;
            }
        }
        if(flag) {
            arr.push(i);
        }
    }
    return arr;
};

&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">LeetCode刷题总结(简单版二)</title><link href="/leetcode/2019/09/04/leetcode-two/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版二)" /><published>2019-09-04T00:00:00+08:00</published><updated>2019-09-04T00:00:00+08:00</updated><id>/leetcode/2019/09/04/leetcode-two</id><content type="html" xml:base="/leetcode/2019/09/04/leetcode-two/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1有趣的电影&quot;&gt;1.有趣的电影&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/not-boring-movies/&quot;&gt;有趣的电影&lt;/a&gt;：
某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。
作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如，下表 cinema:

+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
对于上面的例子，则正确的输出是为：

+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一：&lt;/h4&gt;
&lt;p&gt;我们可以使用 mod(id,2)=1 来确定奇数 id，然后添加 description != ‘boring’ 来解决问题。
官方题解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-MySQL&quot;&gt;select * 
from cinema
where mod(id,2) != 0 and description != 'boring'
order by rating desc
;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二&quot;&gt;答案二：&lt;/h4&gt;
&lt;p&gt;如何确定奇数除了使用mod函数还有一个比较巧妙的方法， id&amp;amp;1按位与,该操作会将数字转为32位的二进制进行比较&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//id=1
0001
0001

0001 结果为1

//id=2
0010
0001 

0000 结果为0

//id=3
0011
0001

0001 结果为1

//id=4
0010
0001

0000 结果为0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为1的前31位都是0，跟0进行与操作肯定是0，主要在于最后一位如果是奇数肯定能得到1，如果是0肯定是0
所以答案也可以写成这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * 
from cinema 
where description&amp;lt;&amp;gt;'boring' and id&amp;amp;1 
order by rating desc
;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2汉明距离&quot;&gt;2.汉明距离&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/hamming-distance/&quot;&gt;汉明距离&lt;/a&gt;:
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数 x 和 y，计算它们之间的汉明距离。
注意：
0 ≤ x, y &amp;lt; 231.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-1&quot;&gt;答案一：&lt;/h4&gt;
&lt;p&gt;分析其实本题的意图就是将x，y转为二进制后，记录对应位置值不相同的位置数量， 所以我们就想到了按位异或。x^y后得到一个数值，需要将这个值转为二进制再去统计数量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
  let z = x^y;
  let num = 0;
  let bin = z.toString(2);
  for(let i = 0; i &amp;lt; bin.length; i++) {
      if(bin.charAt(i) === '1') {
          num++;
      }
  }
    
    return num;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3翻转二叉树&quot;&gt;3.翻转二叉树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/invert-binary-tree/&quot;&gt;翻转二叉树&lt;/a&gt;:
翻转一棵二叉树。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) {
            return null;
        }
        
        TreeNode right = invertTree(root.right);
        TreeNode left = invertTree(root.left);
        
        root.left = right;
        root.right = left;
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(root !== null) {
        [root.left, root.right] = [invertTree(root.right), invertTree(root.left)]
    }
    return root;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4机器人能否返回原点&quot;&gt;4.机器人能否返回原点&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/robot-return-to-origin/&quot;&gt;机器人能否返回原点&lt;/a&gt;：
在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。
移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。
注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1:

输入: &quot;UD&quot;
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
示例 2:

输入: &quot;LL&quot;
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：是否回到原点，取决于上下移动的步数相等，左右移动的步数相等。
所以最简单的方法就是去计数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
     let u = 0;
        let d = 0;
        let r = 0;
        let l = 0;
        let movesArr = moves.split(&quot;&quot;);
        
        movesArr.forEach(function(val) {
            if(val === 'U') {
                u++;
            }
            if(val === 'D') {
                d++;
            }
            if(val === 'L') {
                l++;
            }
            if(val === 'R') {
                r++;
            }
            
        });
        return u === d &amp;amp;&amp;amp; r === l;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;比第一个方法要巧妙一些，不去计数了但是还是要判断步数相等，通过切割关键点来得到数组，如果关键点数量一样数组的长度相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
  return moves.split('L').length === moves.split('R').length &amp;amp;&amp;amp; moves.split('U').length === moves.split('D').length
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5高度检查器&quot;&gt;5.高度检查器&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/height-checker/&quot;&gt;高度检查器&lt;/a&gt;:
学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。
请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= heights.length &amp;lt;= 100&lt;/li&gt;
  &lt;li&gt;1 &amp;lt;= heights[i] &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入：[1,1,4,2,1,3]
输出：3
解释：
高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：将数组重新排序后得到新的数组去判断同一个位置的值是否相等，不想等计数+1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} heights
 * @return {number}
 */
var heightChecker = function(heights) {    
    var temp = heights.concat().sort((a, b) =&amp;gt; (a - b) );
    var count = 0;

    for(var i = 0; i &amp;lt; heights.length; i++) {
        if(heights[i] != temp[i]) {
            count++;   
        }
    }
    
    return count;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6二叉树的最大深度&quot;&gt;6.二叉树的最大深度&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&quot;&gt;二叉树的最大深度&lt;/a&gt;:
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度 3 。

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(root == null) {
        return 0;
    } else {
        let left = maxDepth(root.left);
        let right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7交换工资&quot;&gt;7.交换工资&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap-salary/&quot;&gt;交换工资&lt;/a&gt;
给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。
注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;

例如：

| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
运行你所编写的更新语句之后，将会得到以下表:

| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;UPDATE salary 
SET sex = CASE sex
        WHEN 'm' THEN 'f'
        ELSE 'm'
    END;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8有序数组的平方&quot;&gt;8.有序数组的平方&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/squares-of-a-sorted-array/&quot;&gt;有序数组的平方&lt;/a&gt;:
给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;-10000 &amp;lt;= A[i] &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;A 已按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
示例 2：

输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：因为是从小打大，其中可以包含负数，所以取平方后两头应该最大。之所以使用&lt;code&gt;unshift&lt;/code&gt;是因为双向指针来获取，拿到的一开始的值肯定是最大的后面越来越小&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortedSquares = function(A) {
    let count = A.length;
    let result = [];
    let i = 0;
    let j = count -1;
    
    while(i &amp;lt;= j) {
        let left = Math.pow(A[i], 2);
        let right = Math.pow(A[j], 2);
        
        if(left &amp;gt; right) {
            result.unshift(left);
            i++;
        } else {
            result.unshift(right);
            j--;
        }
        
    }

    return result;
    
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9增减字符串匹配&quot;&gt;9.增减字符串匹配&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/di-string-match/&quot;&gt;增减字符串匹配&lt;/a&gt;:
给定只含 ”I”（增大）或 “D”（减小）的字符串 S ，令 N = S.length。
返回 [0, 1, …, N] 的任意排列 A 使得对于所有 i = 0, …, N-1，都有：
如果 S[i] == “I”，那么 A[i] &amp;lt; A[i+1]
如果 S[i] == “D”，那么 A[i] &amp;gt; A[i+1]&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;示例 1：

输出：&quot;IDID&quot;
输出：[0,4,1,3,2]
示例 2：

输出：&quot;III&quot;
输出：[0,1,2,3]
示例 3：

输出：&quot;DDI&quot;
输出：[3,2,0,1]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-8&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：根据结果的分析是所有的I从0开始依次递增，所有D从N开始依次递减&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {string} S
 * @return {number[]}
 */
var diStringMatch = function(S) {
    let len = S.length;
    let imin = 0, dmax = len;
    let result = new Array(len + 1);
    for(let i = 0; i &amp;lt;= len; i++) {
        if(S.charAt(i) === 'I') {
            result[i] = imin;
            imin++;
        } else {
            result[i] = dmax;
            dmax--;
        }
    }
    
    return result;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-3&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;分析：乍一看这个一行的解法不是特别明白，但是分析示例答案可以看出无论给出的字符串是什么样的最后都可以补充一位，可以补I也可以补D,对于结果是没有影响的
所以先不补位置。然后逢I加一 逢D减一。
var diStringMatch = function(S) {
    let a = 0,b = S.length;
    return (S+S[S.length - 1]).split('').map((x) =&amp;gt; x=='I'?a++:b--)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;10组合两个表&quot;&gt;10.组合两个表&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combine-two-tables/&quot;&gt;组合两个表&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;表1: Person

+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键


表2: Address

+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键


编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：
FirstName, LastName, City, State
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-9&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。
考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
;
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">LeetCode刷题总结(简单版一)</title><link href="/leetcode/2019/09/03/leetcode-one/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版一)" /><published>2019-09-03T00:00:00+08:00</published><updated>2019-09-03T00:00:00+08:00</updated><id>/leetcode/2019/09/03/leetcode-one</id><content type="html" xml:base="/leetcode/2019/09/03/leetcode-one/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1宝石与石头&quot;&gt;1.宝石与石头&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jewels-and-stones/&quot;&gt;宝石与石头&lt;/a&gt;：
给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例1:
输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;
输出: 3

示例1:
输入: J = &quot;z&quot;, S = &quot;ZZ&quot;
输出: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意:
S 和 J 最多含有50个字母。
J 中的字符不重复。&lt;/p&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一：&lt;/h4&gt;
&lt;p&gt;分析：最笨的方法肯定是双层遍历。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    var jLen = J.length;
    var sLen = S.length;
    var sum = 0;
    for(var i = 0; i &amp;lt; jLen; i++) {
        var j = J.charAt(i);
        for(var k = 0; k &amp;lt; sLen; k++) {
            if(j === S.charAt(k)) {
                sum++;
            }
        }   
    }
    
    return sum;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二&quot;&gt;答案二：&lt;/h4&gt;
&lt;p&gt;通过题解得到了另一种思路就是将J进行循环遍历然后将S中的匹配值全部替换为空，这样长度的差值就是宝石的数量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    var jLen = J.length,
        sLen = S.length;
        var news= S;
    for(var i = 0; i &amp;lt; jLen; i++) {
        news = news.replace(new RegExp(J.charAt(i), 'g'), &quot;&quot;);
    }
    
    return sLen - news.length;
    
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2ip地址无效化&quot;&gt;2.IP地址无效化&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/defanging-an-ip-address/&quot;&gt;IP地址无效化&lt;/a&gt;：
给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。
所谓无效化 IP 地址，其实就是用 “[.]” 代替了每个 “.”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例1:
输入：address = &quot;1.1.1.1&quot;
输出：&quot;1[.]1[.]1[.]1&quot;

示例2:
输入：address = &quot;255.100.50.0&quot;
输出：&quot;255[.]100[.]50[.]0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-1&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：最简单直接的方案就是正则表达式替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param {string} address
 * @return {string}
 */
var defangIPaddr = function(address) {
    return address.replace(/\./g, '[.]');
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3删除链表中的节点&quot;&gt;3.删除链表中的节点&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/delete-node-in-a-linked-list/&quot;&gt;删除链表中的节点&lt;/a&gt;:
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
现有一个链表 – head = [4,5,1,9]，它可以表示为:
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/237_example.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例1
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.

示例2
输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;链表至少包含两个节点。&lt;/li&gt;
  &lt;li&gt;链表中所有节点的值都是唯一的。&lt;/li&gt;
  &lt;li&gt;给定的节点为非末尾节点并且一定是链表中的一个有效节点。&lt;/li&gt;
  &lt;li&gt;不要从你的函数中返回任何结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：说实话这道题目对于前端的同学来说其实很难理解。但是对于后台同学这个就太简单了，首先要理解&lt;a href=&quot;https://blog.csdn.net/jianyuerensheng/article/details/51200274&quot;&gt;单向链表的概念&lt;/a&gt;。对于本题只需要将删除后的节点指向新节点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void deleteNode(ListNode node) {
    node.val = node.next.val;
    node.next = node.next.next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;对于使用javascript的版本需要首先定义一个单向链表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
  node.val = node.next.val;
  node.next = node.next.next;
};

var deleteNode = function(node) {
  node = Object.assign(node, node.next)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4查找重复的电子邮箱&quot;&gt;4.查找重复的电子邮箱&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/duplicate-emails/&quot;&gt;查找重复的电子邮箱&lt;/a&gt;: 编写一个 SQL 查询，查找 &lt;code&gt;Person&lt;/code&gt; 表中所有重复的电子邮箱。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例：
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+

返回结果：
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select Email
from Person
group by Email
having count(Email) &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select Email from
(
    select Email, count(Email) as num
    from Person
    group by Email
) as statistic
where num &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5大的国家&quot;&gt;5.大的国家&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/big-countries/&quot;&gt;大的国家&lt;/a&gt;:这里有张 World 表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。&lt;/p&gt;

&lt;p&gt;编写一个SQL查询，输出表中所有大国家的名称、人口和面积。&lt;/p&gt;

&lt;p&gt;例如，根据上表，我们应该输出:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6二叉搜索树的范围和&quot;&gt;6.二叉搜索树的范围和&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-of-bst/&quot;&gt;二叉搜索树的范围和&lt;/a&gt;: 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。
二叉搜索树保证具有唯一的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例1:
输入：root = [10,5,15,3,7,null,18], L = 7, R = 15
输出：32

示例2:
输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
输出：23
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;树中的结点数量最多为 10000 个。&lt;/li&gt;
  &lt;li&gt;最终的答案保证小于 2^31。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Java官方解法&lt;/code&gt;
要理解这道题首先要知道一个概念&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9&quot;&gt;二叉查找树&lt;/a&gt;, 也称为二叉搜索树、有序二叉树、排序二叉树，指一棵空树或具有以下性质的二叉树：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；&lt;/li&gt;
  &lt;li&gt;若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；&lt;/li&gt;
  &lt;li&gt;任意节点的左、右子树也分别为二叉查找树；&lt;/li&gt;
  &lt;li&gt;没有键值相等的节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;深度优先搜索我们对树进行深度优先搜索，对于当前节点 node，如果 node.val 小于等于 L，那么只需要继续搜索它的右子树；如果 node.val 大于等于 R，那么只需要继续搜索它的左子树；如果 node.val 在区间 (L, R) 中，则需要搜索它的所有子树。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//深度优先搜索
class Solution {
    int ans;
    public int rangeSumBST(TreeNode root, int L, int R) {
        ans = 0;
        dfs(root, L, R);
        return ans;
    }

    public void dfs(TreeNode node, int L, int R) {
        if (node != null) {
            if (L &amp;lt;= node.val &amp;amp;&amp;amp; node.val &amp;lt;= R)
                ans += node.val;
            if (L &amp;lt; node.val)
                dfs(node.left, L, R);
            if (node.val &amp;lt; R)
                dfs(node.right, L, R);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//迭代实现深度优先搜索
class Solution {
    public int rangeSumBST(TreeNode root, int L, int R) {
        int ans = 0;
        Stack&amp;lt;TreeNode&amp;gt; stack = new Stack();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node != null) {
                if(L &amp;lt;= node.val &amp;amp;&amp;amp; node.val &amp;lt;= R)
                    ans += node.val;

                if(L &amp;lt; node.val)
                    stack.push(node.left);
                
                if(node.val &amp;lt; R)
                    stack.push(node.right);
            }
        }

        return ans;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-3&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;画图解题
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/tree.jpeg&quot; alt=&quot;&quot; /&gt;
假设L= 7，R=15&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果node.val &amp;gt;= 7 &amp;amp;&amp;amp; node.val &amp;lt;= 15 则直接求和&lt;/li&gt;
  &lt;li&gt;如果node.val &amp;gt; 7,则node.right的值都大于7，右侧没有搜索必要，去查找left的值&lt;/li&gt;
  &lt;li&gt;如果node.val &amp;lt; 15,则node.left的值都小于15，左侧没有搜索必要，去查找right的值&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} L
 * @param {number} R
 * @return {number}
 */
var rangeSumBST = function(root, L, R) {
    var sum = 0;
        
    const dealBinTree = node =&amp;gt; {
        if(node !== null) {
            if(L &amp;lt; node.val) {
                    dealBinTree(node.left);
            }
            if(node.val &amp;gt;= L &amp;amp;&amp;amp; node.val &amp;lt;= R) {
                sum += node.val;
            }
            if(R &amp;gt; node.val) {
                    dealBinTree(node.right);
            }
            
        }
    
    }
    
    dealBinTree(root);
    
    return sum;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7转换成小写字母&quot;&gt;7.转换成小写字母&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/to-lower-case/&quot;&gt;转换成小写字母&lt;/a&gt;:实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入: &quot;Hello&quot;
输出: &quot;hello&quot;
示例 2：

输入: &quot;here&quot;
输出: &quot;here&quot;
示例 3：

输入: &quot;LOVELY&quot;
输出: &quot;lovely&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析通过字符串的 &lt;code&gt;charCodeAt&lt;/code&gt;和&lt;code&gt;String.fromCharCode&lt;/code&gt;这两个方法来得到答案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param {string} str
 * @return {string}
 */
var toLowerCase = function(str) {
    var s = '';
    for(var i = 0, len = str.length; i &amp;lt; len; i++) {
        var c = str.charCodeAt(i);
        if(c &amp;gt;= 65 &amp;amp;&amp;amp; c &amp;lt;= 90) {
           s += String.fromCharCode(c+32); 
        }  else {
           s += str.charAt(i);    
        }
        
    }
    return s;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8唯一摩尔斯密码词&quot;&gt;8.唯一摩尔斯密码词&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-morse-code-words/&quot;&gt;唯一摩尔斯密码词&lt;/a&gt;
国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 “-…”, “c” 对应 “-.-.”, 等等。
为了方便，所有26个英文字母对应摩尔斯密码表如下：&lt;/p&gt;

&lt;p&gt;[”.-“,”-…”,”-.-.”,”-..”,”.”,”..-.”,”–.”,”….”,”..”,”.—”,”-.-“,”.-..”,”–”,”-.”,”—”,”.–.”,”–.-“,”.-.”,”…”,”-“,”..-“,”…-“,”.–”,”-..-“,”-.–”,”–..”]&lt;/p&gt;

&lt;p&gt;给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..–…“，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。&lt;/p&gt;

&lt;p&gt;返回我们可以获得所有词不同单词翻译的数量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如:
输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]
输出: 2
解释: 
各单词翻译如下:
&quot;gin&quot; -&amp;gt; &quot;--...-.&quot;
&quot;zen&quot; -&amp;gt; &quot;--...-.&quot;
&quot;gig&quot; -&amp;gt; &quot;--...--.&quot;
&quot;msg&quot; -&amp;gt; &quot;--...--.&quot;

共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;单词列表words 的长度不会超过 100。&lt;/li&gt;
  &lt;li&gt;每个单词 words[i]的长度范围为 [1, 12]。&lt;/li&gt;
  &lt;li&gt;每个单词 words[i]只包含小写字母。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string[]} words
 * @return {number}
 */
var uniqueMorseRepresentations = function(words) {
    var map = [&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;];
    
    var obj = {};

    for(var i = 0, len = words.length; i &amp;lt; len; i++) {
        
        let m = '';
        for(var j = 0, jen = words[i].length; j &amp;lt; jen; j++) {
             m += map[words[i].charCodeAt(j) - 97];
        }
        
        if(obj.hasOwnProperty(m)) {
            obj[m] = obj[m] + 1;
        } else {
            obj[m] = 1;
        }
        
    }
    

    return Object.keys(obj).length;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案二-4&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;利用Set自动去重&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        String[] s={&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;};

        Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        int index;
        for(int i = 0; i &amp;lt; words.length; i++) {
            String temp = &quot;&quot;;
            for(int j = 0; j &amp;lt; words[i].length(); j++) {
                index = (int)words[i].charAt(j) - 65 - 32;
                temp = temp.concat(s[index]);
            }
            set.add(temp);
        }
        return set.size();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9合并二叉树&quot;&gt;9.合并二叉树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-binary-trees/&quot;&gt;合并二叉树&lt;/a&gt;:给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
注意: 合并必须从两个树的根节点开始。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public TreeNode meregeTrees(TreeNode t1, TreeNode t2) {
        if(t1 == null) {
            return t2;
        }
        if(t2 == null) {
            return t1;
        }

        TreeNode result = new TreeNode(t1.val + t2.val);
        result.left = mergeTrees(t1.left, t2.left);
        result.right = mergeTrees(t1.right, t2.right);
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-5&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
var mergeTrees = function(t1, t2) {
    if(t1 === null) {
        return t2;
    }
    if(t2 === null) {
        return t1;
    }
    
    t1.val = t1.val + t2.val;
    t1.left = mergeTrees(t1.left, t2.left);
    t1.right = mergeTrees(t1.right, t2.right);
    
    return t1;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;10翻转图像&quot;&gt;10.翻转图像&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flipping-an-image/&quot;&gt;翻转图像&lt;/a&gt;给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。
水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。
反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: [[1,1,0],[1,0,1],[0,0,0]]
输出: [[1,0,0],[0,1,0],[1,1,1]]
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
示例 2:

输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
说明:

1 &amp;lt;= A.length = A[0].length &amp;lt;= 20
0 &amp;lt;= A[i][j] &amp;lt;= 1

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-8&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：最简单的方法就是按部就班来实现，先进行水平再进行图片反转。
对于1和0的翻转有两种方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1 - 当前值 得到的是1和0的翻转&lt;/li&gt;
  &lt;li&gt;1 ^ 当前值 得到的也是0和1的反转。这个符号是异或，相同为0，相异为1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var flipAndInvertImage = function(A) {
    for(let i = 0, len = A.length; i &amp;lt; len; i++) {
        let re = A[i].join('');
        let im = '';
        for(let j = 0; j &amp;lt; re.length; j++) {
               im += Number(re[j]) === 0 ? '1' : '0';
        }
        A[i] = im.split('').reverse();
        
    }
    return A;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-6&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;数组api一行解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var flipAndInvertImage = function(A) {
    return A.map(val =&amp;gt; val.reverse().map(v =&amp;gt; (1 - v)))
};

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案三&quot;&gt;答案三&lt;/h4&gt;
&lt;p&gt;双向指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var flipAndInvertImage = function(A) {
    let Alen = A.length;
    let len = A[0].length;
    for(let i = 0; i &amp;lt; Alen; i++) {
        let left = 0;
        let right = len - 1;
        while(left &amp;lt;= right) {
            let temp = A[i][left];
            A[i][left] = A[i][right] ^ 1;
            A[i][right] = temp ^ 1;
            
            left++;
            right--;
        }
    }
    return A;
};
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">搭建门户网站技术选型</title><link href="/%E8%84%9A%E6%89%8B%E6%9E%B6/2018/10/21/scaffold-front-www/" rel="alternate" type="text/html" title="搭建门户网站技术选型" /><published>2018-10-21T00:00:00+08:00</published><updated>2018-10-21T00:00:00+08:00</updated><id>/%E8%84%9A%E6%89%8B%E6%9E%B6/2018/10/21/scaffold-front-www</id><content type="html" xml:base="/%E8%84%9A%E6%89%8B%E6%9E%B6/2018/10/21/scaffold-front-www/">&lt;h2 id=&quot;起因&quot;&gt;起因&lt;/h2&gt;
&lt;p&gt;工作多年，项目越来越多，总是要做一些重复性的工作开进行开发，每次东配置西配置一大堆，效率很低无法直接投入生产。
通过这篇文章梳理一下自己的知识点，将一些常用技术做一些总结归纳和复习。并且基于此开发一套模版，用于以后网站开发直接套用，不做重复性的工作（这里的网站主要针对pc）。&lt;/p&gt;

&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;p&gt;从前端的角度来说，如何从零开始开发一个门户网站呢？ 首先是要有一些基础知识包括&lt;code&gt;JavaScript&lt;/code&gt;, &lt;code&gt;css&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;html&quot;&gt;html&lt;/h2&gt;
&lt;p&gt;关于&lt;code&gt;html&lt;/code&gt;需要了解的是，语义化的标签，还有html模版。一个html应该有什么呢，我们通过一个html模版来看下&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt;html5-boilerplate&lt;/a&gt;, 这是一个专业的前端模版html。 由于篇幅问题就不再这里展开大家可以去github仓库中的dist文件夹查看index.html。
我们简单介绍下其中用到的东西&lt;/p&gt;

&lt;p&gt;首先是通用的html5的头&lt;code&gt;&amp;lt;!doctype html&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在HTML中，doctype是所有文档顶部所需的“ 序言“。其唯一目的是防止浏览器在呈现文档时转换成所谓的“怪异”模式; 也就是说，doctype确保浏览器尽力尝试遵循相关规范，而不是使用与某些规范不兼容的不同渲染模式。DOCTYPE用来告知 Web 浏览器页面使用了哪种 HTML 版本,只有确定了一个正确的文档类型，HTML或XHTML中的标签和层叠样式表才能生效，甚至对JavaScript脚本都会有所影响。&lt;/p&gt;

&lt;p&gt;还有这个Meta标签，如果您需要支持IE9或IE8，那么建议使用该标签， 如果支持最新的IE11或Edge则考虑删除此标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个X-UA标记允许web作者选择呈现页面的Internet Explore版本，具体解释请看&lt;a href=&quot;https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后这里还用到了&lt;a href=&quot;https://necolas.github.io/normalize.css/&quot;&gt;normalize.css&lt;/a&gt;,来消除不通浏览器之间的样式差异。
还使用了&lt;a href=&quot;https://modernizr.com/&quot;&gt;modernizr&lt;/a&gt;，来进行浏览器功能检查。
以及大家最熟悉的jQuery(如果只兼容IE9+则可以放心使用最新版本，如果需要支持IE8则需要使用2.0以下的版本)&lt;/p&gt;

&lt;h2 id=&quot;css&quot;&gt;css&lt;/h2&gt;
&lt;p&gt;css我们先前在模版中已经引入了&lt;a href=&quot;https://necolas.github.io/normalize.css/&quot;&gt;normalize.css&lt;/a&gt;, 其余css基础知识的获取就需要大家自行补充了，建议读一下《css权威指南》，算是css内功方面的书籍了，再就是了解css的布局包括栅格布局，flex布局， 还有更早期的双飞翼布局，圣杯布局等等。&lt;/p&gt;

&lt;p&gt;除了这些基础实战中我们通常会用到css预处理器，&lt;a href=&quot;https://sass-lang.com/&quot;&gt;Sass&lt;/a&gt;、&lt;a href=&quot;http://lesscss.org/&quot;&gt;Less&lt;/a&gt;和&lt;a href=&quot;http://stylus-lang.com/&quot;&gt;Stylus&lt;/a&gt;. 最开始我使用的是sass，但是这个的npm包经常会被墙下载不下来，相关依赖感觉也比较重。至于选哪种看大家喜好了，我推荐使用stylus，语法自由度很高，代码非常简洁。&lt;/p&gt;

&lt;h2 id=&quot;javascript&quot;&gt;JavaScript&lt;/h2&gt;
&lt;p&gt;什么是最轻量的JavaScript框架,那就是&lt;a href=&quot;http://vanilla-js.com/&quot;&gt;vanilla-js&lt;/a&gt; 来自&lt;a href=&quot;https://segmentfault.com/a/1190000000355277&quot;&gt; Vanilla JS——世界上最轻量的JavaScript框架（没有之一）&lt;/a&gt;,这里是个玩笑，因为这里说的框架其实就是原生Js。
大型网站的开发还是需要依赖各种js的库或者框架。这里简单列几种，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;jQuery，虽然有些人抵触，但是为了保证代码兼容性，我还是愿意引入jQuery的&lt;/li&gt;
  &lt;li&gt;Backbone， 一款轻量级的框架，不过需要配合underscore或者lodash使用&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/wycats/handlebars.js&quot;&gt;Handlebars&lt;/a&gt;, js模版用来处理html代码片段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体代码可以考虑使用ES5如果这样的话需要引入&lt;a href=&quot;https://babeljs.io/&quot;&gt;babeljs&lt;/a&gt;,做转换这样就可以愉快的使用新语法了，除此之外我们的选择还有&lt;a href=&quot;https://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt;, 和&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;代码规范可以可以参考&lt;a href=&quot;https://codeburst.io/5-javascript-style-guides-including-airbnb-github-google-88cbc6b2b7aa&quot;&gt;这篇文章&lt;/a&gt;
我推荐使用其中更为广泛的&lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;Airbnb Standard&lt;/a&gt; 比&lt;a href=&quot;https://github.com/standard/standard&quot;&gt;JavaScript Standard Style&lt;/a&gt; 更多的star。&lt;/p&gt;

&lt;h2 id=&quot;搭建&quot;&gt;搭建&lt;/h2&gt;
&lt;p&gt;好了前期准备工作已经完成现在我们开始正式开始&lt;/p&gt;</content><author><name>toshiba</name></author><category term="工具" /><category term="脚手架" /><summary type="html">起因 工作多年，项目越来越多，总是要做一些重复性的工作开进行开发，每次东配置西配置一大堆，效率很低无法直接投入生产。 通过这篇文章梳理一下自己的知识点，将一些常用技术做一些总结归纳和复习。并且基于此开发一套模版，用于以后网站开发直接套用，不做重复性的工作（这里的网站主要针对pc）。</summary></entry><entry><title type="html">安卓和IOS前端页面调试</title><link href="/%E8%B0%83%E8%AF%95/2018/10/20/debug-webview/" rel="alternate" type="text/html" title="安卓和IOS前端页面调试" /><published>2018-10-20T00:00:00+08:00</published><updated>2018-10-20T00:00:00+08:00</updated><id>/%E8%B0%83%E8%AF%95/2018/10/20/debug-webview</id><content type="html" xml:base="/%E8%B0%83%E8%AF%95/2018/10/20/debug-webview/">&lt;h2 id=&quot;场景&quot;&gt;场景&lt;/h2&gt;

&lt;p&gt;我们通常会有这样的开发场景， 开发了一些前端页面，可能在手机浏览器打开，也可能在客户端的webview打开，对应不同的场景我们可能需要不通的手段来进行调试。
对于简单的页面我们一般可以通过chrome的开发工具来调试或者通过safari来直接对手机打开的页面直接进行调试。 但是对于复杂webview我们可能需要一些特殊手段来进行debug.&lt;/p&gt;

&lt;p&gt;在本文将总结一部分调试技巧&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法分类&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;难度&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;调试目标&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;调试效果&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;优先级&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Chrome自带模拟器&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;简单&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;所有&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模拟效果，基本能调试 UI 及标准 JS 所有问题&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;极高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;chrome://inspect&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;简单&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;安卓的自带浏览器+webview&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真机调试效果显著&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spy-debugger&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;所有页面不管是否是webview&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;效果可以&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;safari开发模式&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;简单&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;手机safari的所有页面&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真机调试效果显著&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;xcode的iPhone模拟器&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;较难&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;webview和手机浏览器&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;调试效果显著&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;中等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;weinre&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;所有页面不管是否是webview&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;需要注入代码效果一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;微信开发者工具&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模拟手机&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TBS Studio&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模拟手机&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;未测试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Browsersync&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模拟手机&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;未测试&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;抓包&quot;&gt;抓包&lt;/h2&gt;
&lt;p&gt;对于抓包有很多工具比如 mac上面有 charles，wireShark， windows上面有fiddler 等等。
我常用的一个抓包工具叫 &lt;a href=&quot;https://mitmproxy.org/&quot;&gt;mitmproxy&lt;/a&gt;, 在github已经一万多star了，使用起来比较简单。 一条命令 &lt;code&gt;mitmproxy -p 4000 --set console_mouse=false&lt;/code&gt;, 启动后 手机手动代理到 ip+端口就可以开始抓包了，对于https可能需要&lt;a href=&quot;http://mitm.it/&quot;&gt;安装证书&lt;/a&gt;.至于安装过程就不重复了，官网已有&lt;a href=&quot;https://docs.mitmproxy.org/stable/&quot;&gt;教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;charles抓包请查看&lt;a href=&quot;https://www.jianshu.com/p/fdd7c681929c&quot;&gt;这篇教程&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;安卓的webview页面&quot;&gt;安卓的webview页面&lt;/h2&gt;
&lt;p&gt;现在的安卓应用内的页面进行调试是真的方便。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先打开手机的usb调试，连接到电脑。&lt;/li&gt;
  &lt;li&gt;第二在chrome输入 &lt;code&gt;chrome://inspect/#devices&lt;/code&gt; （开发环境安卓桌面版Chrome32+ 并且 Android 系统高于 4.4）&lt;/li&gt;
  &lt;li&gt;第三 选择app中的页面进行调试即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;safari调试iphone页面&quot;&gt;safari调试iPhone页面&lt;/h2&gt;
&lt;p&gt;这种方式适合手机上面的浏览器页面
需要几步配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先打开电脑的safari
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/Safari设置.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后打开iPhone进行设置
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/iPhone设置.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后通过电脑的safari打开进行调试
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/开启调试.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;调试iphone的webview&quot;&gt;调试iPhone的webview&lt;/h2&gt;
&lt;p&gt;iPhone的webview可行的方法就是下载xcode，然后跟客户端开发借来一个xxx.app然后用模拟器打开，这样调试页面的时候可以调试各种情况下的页面，包括safari和应用内的页面。
这是目前唯一靠谱的调试方案。 还有一些 &lt;a href=&quot;https://github.com/google/ios-webkit-debug-proxy&quot;&gt;ios-webkit-debug-proxy&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter&quot;&gt;remotedebug-ios-webkit-adapter&lt;/a&gt; 类似方案， 这些方案只能够调试手机的safari 对于app中的webview就无能为力了，而且经过本人实践效果并不理想，如果只是为了调试safari那还不如直接usb连接方便快捷，而且安装过程会有很多坑，因此不推荐使用。&lt;/p&gt;

&lt;p&gt;简化方案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//打开首页
xcrun simctl openurl booted taobao://h5.m.taobao.com/guang/index.html
// 打开模拟器
open -a &quot;Simulator.app&quot; --args -CurrentDeviceUDID &quot;FCE2CFE8-64C3-4DBE-906B-B9BF4180DE49&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前提是安装了xcode， 本地需要一个sdk与测试网站进行交互方便获取app和执行本地shell命令
根据&lt;a href=&quot;http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/&quot;&gt;此文章&lt;/a&gt;, 后期开发一个测试环境用的本地调试网站。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/&quot;&gt;http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;weinre&quot;&gt;weinre&lt;/h2&gt;

&lt;p&gt;Weinre 是一款较老的远程调试工具，功能与 Chrome DevTools 相似，需要在页面中插入一段 JS 脚本来实时调试页面 DOM 结构、样式、JS 等，另外它使用的是代理的方式，所以兼容性很好，无论是新老设备系统通吃，但对于样式调试不友善，缺少断点调试及 Profiles 等常用功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装 Weinre
    &lt;pre&gt;&lt;code&gt;$ sudo npm -g install weinre
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;启动Weinre监听服务
    &lt;pre&gt;&lt;code&gt;$ weinre --boundHost 10.10.2.144 --httpPort 8090 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;使用chrome访问
&lt;a href=&quot;http://10.10.2.144:8090&quot;&gt;http://10.10.2.144:8090&lt;/a&gt;, 然后将一段 JS 脚本 &lt;script src=&quot;http://10.10.2.144:8090/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt; 插入到需要调试的页面中，插入代码后手机访问调试页面。
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/weinre.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到这里还不算完，因为手动插入js不够优雅，所以这里采用js脚本注入
Tools –&amp;gt; Rewrite 选中Enable Rewrite
这里我们需要使用到的是 Body，它的作用是对请求或响应内容进行匹配替换，按照下图的配置，通过将匹配到的响应内容 &amp;lt;/body&amp;gt; 标签替换成需要插入到页面中的 JS 脚本，从而实现动态插入。
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/Charles_Rewrite.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/Charles_Rewrite_Rule.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;spy-debugger&quot;&gt;spy-debugger&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wuchangming/spy-debugger&quot;&gt;spy-debugger&lt;/a&gt;跟微信开发这工具都在weinre的基础上简化了给页面添加js的步骤，它还对HTTPS的支持&lt;/p&gt;

&lt;p&gt;安装spy-debugger
spy-debugger内部集成了&lt;a href=&quot;http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html&quot;&gt;weinre&lt;/a&gt;、&lt;a href=&quot;https://github.com/wuchangming/node-mitmproxy&quot;&gt;node-mitmproxy&lt;/a&gt;、&lt;a href=&quot;https://github.com/alibaba/anyproxy&quot;&gt;AnyProxy&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$  sudo npm install spy-debugger -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装https证书包括手机和PC。
执行启动特别酸爽&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ spy-debugger -p 8888
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;tbs-studio&quot;&gt;TBS Studio&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://x5.tencent.com/guide/debug.html&quot;&gt;TBS Studio&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;微信-webview-调试&quot;&gt;微信 WebView 调试&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://x5.tencent.com/tbs/guide/debug/season1.html&quot;&gt;https://x5.tencent.com/tbs/guide/debug/season1.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;browsersync&quot;&gt;browserSync&lt;/h2&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://75team.com/post/webview-debug.html&quot;&gt;前端 WebView 指南之调试篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://elevenbeans.github.io/2017/06/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/&quot;&gt;移动端浏览器调试方法汇总&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aotu.io/notes/2017/02/24/Mobile-debug/index.html&quot;&gt;移动端真机调试指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/riskers/blog/issues/11&quot;&gt;打造最舒适的webview调试环境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://yujiangshui.com/multidevice-frontend-debug/&quot;&gt;移动端前端开发调试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="工具" /><category term="调试" /><summary type="html">场景</summary></entry><entry><title type="html">你不知道的JavaScript中卷(一)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/18/read-book-you-known-middle-one/" rel="alternate" type="text/html" title="你不知道的JavaScript中卷(一)" /><published>2018-10-18T00:00:00+08:00</published><updated>2018-10-18T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/18/read-book-you-known-middle-one</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/18/read-book-you-known-middle-one/">&lt;h2 id=&quot;字符串&quot;&gt;字符串&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var a = &quot;foo&quot;;
b = [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;];

var c = Array.prototype.join.call(a, &quot;-&quot;);

var d = Array.prototype.map.call(a, function(v) {
	return v.toUpperCase() + &quot;.&quot;
}).join(&quot;&quot;);


c; // &quot;f-o-o&quot;

d; // &quot;F.O.O.&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;数字&quot;&gt;数字&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var a = 5E10;

a; // 50000000000

a.toExponential(); // &quot;5e+10&quot;


// toFixed 用来显示小数部分的显示位数
var a = 42.59;

a.toFixed(0);  // &quot;43&quot;

a.toFixed(1);  // &quot;42.6&quot;

a.toFixed(2);  // &quot;42.59&quot;


42.toFixed(3); // SyntaxError 报错 42. 被视为一个整体 所以没有访问toFixed

以下访问方式都没有问题

(42).toFixed(3);  // &quot;42.000&quot;
0.42.toFixed(3);  // &quot;0.420&quot;
42..toFixed(3);   // &quot;42.000&quot;


// toPrecision 方法用来制定有效数位的显示位数

var a = 42.59;

a.toPrecision(1); // &quot;4e+1&quot;
a.toPrecision(2); // &quot;43&quot;
a.toPrecision(3); // &quot;42.6&quot;
a.toPrecision(4); // &quot;42.59&quot;
a.toPrecision(5); // &quot;42.590&quot;



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;浮点数&quot;&gt;浮点数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;0.1 + 0.2 === 0.3; // false

由于浮点数的精读问题导致
0.1 + 0.2; // 0.3000000000000004;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如果判断0.1 + 0.2 和 0.3 是否相等呢， 最常见的做法是设置一个误差范围值， 通常称为”机器精度”， 对于JavaScript来说这个值通常是2^-52;
ES6开始，该值定义在&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if(!Number.EPSILON) {
	Number.EPSILON = Math.pow(2, -52);
}


function numbersCloseEnoughToEqual(n1, n2) {
	return Math.abs(n1 - n2) &amp;lt; Number.EPSILON;
}

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual(a, b);  // true;

numbersCloseEnoughToEqual(0.0000001, 0.0000002); // false;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;整数检测&quot;&gt;整数检测&lt;/h2&gt;
&lt;p&gt;要检测一个值是否是整数，可以使用ES6种的Number.isInteger方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.isInteger(42);     // true

Number.isInteger(42.00);  // true

Number.isInteger(45.3);   // false

// ES6 之前的polyfill Number.isInteger

if(!Number.isInteger) {
	Number.isInteger = function(num) {
		return typeof num == 'number' &amp;amp;&amp;amp; num % 1 == 0;
	}
}


// 最大安全数

Numbe.isSafeInteger(Number.MAX_SAFE_INTEGER); // true
Numbe.isSafeInteger(Math.pow(2, 53)); // false
Numbe.isSafeInteger(Math.pow(2, 53) - 1); // true

// ES6 之前的polyfill Number.isSafeInteger

if(!Number.isSafeInteger) {
	Number.isSafeInteger = function(num) {
		return Number.isInteger(num) &amp;amp;&amp;amp; Math.abs(num) &amp;lt;= Number.MAX_SAFE_INTEGER;
	}
}



&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;零值&quot;&gt;零值&lt;/h2&gt;
&lt;p&gt;JavaScript有一个常规的0(+0), 和一个-0
-0， 除了可以作为常量以外，也可以是某些数学运算的返回值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var a = 0 / -3; // -0

var b = 0 * -3; // -0

加法和减法运算不会得到负零


根据规范对于负零进行字符串化操作会返回&quot;0&quot;
var a = -0;

a.toString();
a + &quot;&quot;;
String(a);
JSON.stringify(a)

以上都会返回 &quot;0&quot;, 但是返回来将其从字符串转换为数字，得到的结果是准确的

+&quot;-0&quot;;            // -0
Number(&quot;-0&quot;);     // -0
JSON.parse(&quot;-0&quot;); // -0


0 === -0; // true

0 == -0;  // true

0 &amp;gt; -0;    // false

判断是否是 -0

function isNegZero(n) {
	n = Number(n);

	return (n === 0) &amp;amp;&amp;amp; (1 / n === -Infinity);
}


isNegZero(-0);      // true
isNegZero(0 / -3);  // true
isNegZero(0);       // false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们为什么需要-0呢，有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度), 数字的符号为sign用来代表其他信息(比如移动方向),此时如果一个值为0的变量失去了它的符号位，它的方向信息就回丢失。所以保留0值的符号为可以防止这类情况发生。&lt;/p&gt;

&lt;h2 id=&quot;特殊等式&quot;&gt;特殊等式&lt;/h2&gt;
&lt;p&gt;如前所述，NaN和0在相等比较时表现有些特别，由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN或者polyfill, 而 +0 和 -0 的比较我们也需要借助于 isNegZero这样的工具函数。&lt;/p&gt;

&lt;p&gt;ES6引入了一个工具方法Object.is(…)来判断两个值是否绝对相等用来处理上面特殊情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var a = 2 / &quot;foo&quot;; 
var b = -3 * 0;

Object.is(a, NaN); // true

Object.is(b, -0);  // true

Object.is(b, 0);   // false


ES6之前的polyfill

if(!Object.is) {
	Object.is = function(v1, v2) {
		//判断是否是-0
		if(v1 === 0 &amp;amp;&amp;amp; v2 === 0) {
			return 1 / v1 === 1 / v2;
		}

		// 判断是否是NaN
		if(v1 !== v1) {
			return v2 !== v2;
		}

		return v1 === v2;
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;json字符串化&quot;&gt;JSON字符串化&lt;/h2&gt;
&lt;p&gt;对于大多数简单值来说JSON字符串化和toString效果基本相同，只不过序列化的结构总是字符串
所有安全的JSON值都呈现为有效的JSON格式的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSON.stringify(42);  // &quot;42&quot;
JSON.stringify(&quot;42&quot;) // &quot;&quot;42&quot;&quot;
JSON.stringify(null) // &quot;null&quot;
JSON.stringify(true) // &quot;true&quot;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相对而言不安全的JSON值包括 undefined, function , symbol和包含循环引用的对象都不符合JSON的标准结构，其他支持JSON的语言无法处理它们。&lt;/p&gt;

&lt;p&gt;JSON.toStringify(…)在处理对象中遇到undefined,function,Symbol是会自动将其忽略，在数组中则返回null，以保证单于位置不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSON.stringify(undefined)     			// undefined
JSON.stringify(function() {}) 		    // undefined
JSON.stringify(
	[1, undefined, function() {}, 4] 	// &quot;[1, null, null, 4]&quot;
)
JSON.stringify(
	{a: 2, b: function() {}}         	// &quot;{&quot;a&quot;: 2}&quot;
) 
JSON.stringify(undefined) // undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对象定义了toJSON方法，JSON字符串化会首先调用该方法然后用它的返回值来进行序列化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var o = {};
var a = {
	b: 42,
	c: o,
	d: function() {}
}

o.e = a;

//循环引用会报错
// JSON.stringify(a);

//自定义的JSON序列化
a.toJSON = function() {
	return {b: this.b};
}

JSON.stringify(a); // &quot;{b: 42}&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jsonstringify&quot;&gt;JSON.stringify&lt;/h2&gt;
&lt;p&gt;几个不为人知的知识点,该方法可以传入一个replacer，它可以是数组或者函数，用来制定对象序列化过程中那些应该被处理，哪些应该被排除，如果replacer是一个数组，那么它必须是一个字符串数组，其中高喊序列化要处理的对象的属性名称。除此之外的其他属性被忽略。如果replacer是一个函数，它会对对象本身调用一次然后对对象中的每个属性各调用一次，每次传递两个参数key和value，如果要忽略某个key就返回undefined，否则返回指定值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = {
	b: 42,
	c: &quot;42&quot;,
	d: [1,2,3]
}

JSON.stringify(a, [&quot;b&quot;, &quot;c&quot;]); // &quot;{&quot;b&quot;: 42, &quot;c&quot;: &quot;42&quot;}&quot;

JSON.stringify(a, function(k, v) {
	if(k !== &quot;c&quot;) return v;	
});

// &quot;{&quot;b&quot;: 42, &quot;d&quot;: [1,2,3]}&quot;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSON.stringify还有一个可选参数space用来指定输出的缩进格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = {
	b: 42,
	c: &quot;42&quot;,
	d: [1,2,3]
}

JSON.stringify(a, null, 3);

JSON.stringify(a, null, '---------');


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;tonumber&quot;&gt;toNumber&lt;/h2&gt;
&lt;p&gt;true转换为1，false转换为0，undefined转换为NaN，null转为0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Number(&quot;&quot;);  // 0
Number([]);  // 0
Number([&quot;abc&quot;]);  // NaN

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;奇特的运算符&quot;&gt;奇特的～运算符&lt;/h2&gt;
&lt;p&gt;字位运算只适用于32位整数，运算符将会强制操作数使用32位格式。 ToInt32首先执行ToNumber 然后执行ToInt32，虽然严格来说并非强制类型转换，但是字位运算符和一些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字
例如&lt;code&gt;|&lt;/code&gt;的空操作,会将后面转为数字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 | -0;        // 0
0 | NaN;       // 0
0 | Infinity;  //0
0 | -Infinity; //0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单来说～ 可以理解为&lt;code&gt;-(x+1)&lt;/code&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;～42; // -43

~-1; // 0

var a = &quot;Hello world&quot;;

~a.indexOf(&quot;lo&quot;);  // -4

~a.indexOf(&quot;ol&quot;); // 0

if(!~a.indexOf(&quot;ol&quot;)) {
	// 无匹配
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字位截取&quot;&gt;~~字位截取&lt;/h2&gt;
&lt;p&gt;有些开发人员使用&lt;code&gt;~~&lt;/code&gt;来借去数字值的消暑部分，以为这和Math.floor的效果一样，实际上并非如此
~~它首先只适用于32位数字，更重要的是它对负数的处理和Math.floor不同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.floor(-49.6); // -50  
~~-49.6;      // -49 该方法会舍弃

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;显示解析数字字符串&quot;&gt;显示解析数字字符串&lt;/h2&gt;

&lt;p&gt;parseInt是解析，允许字符串中出现非数字字符，解析从左到右遇到非数字字符就停止。而转换Number不允许出现非数字字符，否则会失败并返回NaN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = &quot;42&quot;;
var b = &quot;42px&quot;;

Number(a); // 42
parseInt(a); // 42

Number(b); // NaN
parseInt(b) // 42

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parseInt和parseFloat是针对字符串值，所以传递其他类型的值是没有用的，他们会被强制类型转换成字符串。&lt;/p&gt;

&lt;p&gt;ES5之前的一个坑就是如果没有指定第二个参数来给定转换基数，则会以第一个参数的第一个字符来自行决定。如果第一个字符是 x 或者 X 则转换为十六进制， 如果是0则转换为八进制。&lt;/p&gt;

&lt;p&gt;如下代码如果值为08:09 ,转换后的值为0:0 因为 8 和 9 都不是有效的八进制数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var hour = parseInt(selectHour.value);
var minute = parseInt(selectMinute.value);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将第二个参数设置为10即可避免这个问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var hour = parseInt(selectHour.value, 10);
var minute = parseInt(selectMinute.value, 10);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;幸运的是从ES5开始&lt;code&gt;parseInt(...)&lt;/code&gt;默认转换为十进制， 除非另外指定。如果你的代码在ES5之前的环境运行，请记得将第二个值设置为10.&lt;/p&gt;

&lt;p&gt;有这样一个坑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parseInt(1/0, 19); // 18

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里parseInt接收字符串参数, 所以 Infinity 被转换为 “Infinity”; 19也不是一个正规的基数，所以这里其实是在转换 parseInt(“Infinity”, 19);&lt;/p&gt;

&lt;p&gt;按照十六进制表示规则 a =&amp;gt; 10, b =&amp;gt; 11, c =&amp;gt; 12, … i =&amp;gt; 18 … z =&amp;gt; 35; 基数是19所有小于19的字母都是有效数字。&lt;/p&gt;

&lt;p&gt;此外还有一些看起来奇怪但是解释的通的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这个例子 小数点后六位之前转为 0
parseInt(0.000008); // 0    
//但是小数点后七位就转为 8e-7 再转字符串&quot;8e-7&quot; 8是有效数字
parseInt(0.0000008); // 8


// &quot;fa&quot;都是有效数字 f = 15 a = 10;  15 * 16 + 10 = 250
parseInt(false, 16); // 250

//parseInt.toString()
//&quot;function parseInt() { [native code] }&quot;
//&quot;f&quot;解析位16进制的15
parseInt(parseInt, 16); // 15

//16进制的10 就是16
parseInt(&quot;0x10&quot;); // 16
// 3不是有效的二进制， 只解析 10, 2进制的10  就是十进制的2
parseInt(&quot;103&quot;, 2) // 2


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;隐式转换&quot;&gt;隐式转换&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;null&lt;/code&gt;和&lt;code&gt;undefined&lt;/code&gt; 之间&lt;code&gt;==&lt;/code&gt;比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果x为null， y是undefined 结果为true&lt;/li&gt;
  &lt;li&gt;如果x为undefined， y是null 结果为true&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var a = null;
var b;

a == b;    // true
a == null; // true
b == null; // true

a == false; // false
b == false; // false
a == &quot;&quot;;    // false
b == &quot;&quot;;    // false
a == 0;     // false
b == 0;     // false


var a = doSomething();

if(a == null) {
	//...
}
条件判断 a == null 仅在 doSomething() 返回 null 和 undefined时才成立，除此之外其他值不成立包括0, false 和&quot;&quot;这样的假植

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象和非对象之间的比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果Type(x)是字符串或者数字， Type(y)是对象， 则返回 x == ToPrimitive(y)的结果&lt;/li&gt;
  &lt;li&gt;如果Type(x)是对象， Type(y)是字符串或者数字， 则返回 ToPrimitive(x) == y的结果&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var a = 42;
var b = [42];

a == b; // true



var a = &quot;abc&quot;;
var b = Object(a);  // 和 new String(a) 一样

a == b;  // true

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是有一些值不这样， 原因是==算法中其他优先级更高的规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var a = null;
var b = Object(a); // 和Object()一样

a == b;  // false


var c = undefined;
var d = Object(c); // 和Object一样
c == d; // false


var e = NaN;
var f = Object(e); // 和new Number(e)一样

e == f; // false

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为没有对应的封装对象所以null和undefined不能够被封装， &lt;code&gt;Object(null)&lt;/code&gt;, &lt;code&gt;Object(undefined)&lt;/code&gt;，都返回一个常规对象。NaN能被封装为数字封装对象，但是拆封之后NaN == NaN返回false， 因为NaN不等于NaN。&lt;/p&gt;

&lt;p&gt;比较少见的情况
2 == 3 不会有这种情况， new Number会调用valueOf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.prototype.valueOf = function(){
	return 3;
}

new Numebr(2) == 3; // true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假值相等比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&quot;0&quot; == null;      // false
&quot;0&quot; == undefined; // false
&quot;0&quot; == false;     // true
&quot;0&quot; == NaN;       // false
&quot;0&quot; == 0;        // true
&quot;0&quot; == &quot;&quot;;       // false



false == null;      // false
false == undefined; // false
false == NaN;       // false
false == 0;        // true
false == &quot;&quot;;       // true
false == [];       // true
false == {};       // false



&quot;&quot; == null;      // false
&quot;&quot; == undefined; // false
&quot;&quot; == NaN;       // false
&quot;&quot; == 0;        // true
&quot;&quot; == [];       // true
&quot;&quot; == {};       // false


0 == null;      // false
0 == undefined; // false
0 == NaN;       // false
0 == [];       // true
0 == {};       // false


这个最好

[] == ![]  // true

2 == [2] // true
&quot;&quot; == [null] // true

0 == &quot;\n&quot;   // true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抽象关系的比较&lt;/p&gt;

&lt;p&gt;双方先调用toPrimitive，如果结果出现非字符串，就根据toNumber规则将双方强制转换为数字进行比较&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = [42];
var b = &quot;43&quot;;

a &amp;lt; b; // true
b &amp;lt; a; // false

如果双方都是字符串，则按照字母顺序比较

var a = [&quot;42&quot;];
var b = [&quot;043&quot;];

a &amp;lt; b;  // false
a和b不转为数字，因为你toPrimitive返回的字符串这里比较的是&quot;42&quot; 和 &quot;043&quot;两个字符串，比较的是&quot;4&quot; 和&quot;0&quot; 


var a = [4, 2];
var b = [0, 4, 3];

a &amp;lt; b; // false  比较 &quot;4, 2&quot; 和 &quot;0, 4, 3&quot;的首字母

var a = { b: 42 };
var b = { b: 43 };

a &amp;lt; b;  // false 转为&quot;[object Object]&quot; 和&quot;[object Object]&quot;所以按照字母顺序比较并不成立


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面的例子比较奇怪&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = { b: 42 };
var b = { b: 43 };

a &amp;lt; b; // false

a == b; // false

a &amp;gt; b; // false

a &amp;lt;= b; // true
a &amp;gt;= b; // true


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据规范 a &amp;lt;=b 被处理成 !(a &amp;gt; b)&lt;/p&gt;

&lt;h2 id=&quot;javascript表达式&quot;&gt;JavaScript表达式&lt;/h2&gt;
&lt;p&gt;表达式的副作用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 42;
var b = a++;

a; // 43

b; // 42


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签表达式 break; continue;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence&quot;&gt;运算符优先级&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">字符串 ``` var a = “foo”; b = [“f”, “o”, “o”];</summary></entry><entry><title type="html">你不知道的JavaScript上卷</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/08/read-book-you-known-up-one/" rel="alternate" type="text/html" title="你不知道的JavaScript上卷" /><published>2018-10-08T00:00:00+08:00</published><updated>2018-10-08T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/08/read-book-you-known-up-one</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/08/read-book-you-known-up-one/">&lt;p&gt;本书是读完 Effective JavaScript之后开的进行的阅读，整理自己需要注意的点。方便以后巩固。&lt;/p&gt;

&lt;h2 id=&quot;作用域&quot;&gt;作用域&lt;/h2&gt;
&lt;p&gt;JavaScript没有块级作用域的相关功能。但是使用&lt;code&gt;with&lt;/code&gt;、&lt;code&gt;try...catch&lt;/code&gt;可以创建块级作用域&lt;/p&gt;

&lt;h2 id=&quot;变量提升&quot;&gt;变量提升&lt;/h2&gt;

&lt;p&gt;提升时函数优先&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo();

var foo;

foo = function() {
  console.log(2);
}


function foo() {
  console.log(1);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入结果是1，函数声明优先，同名的var变量会被忽略，但是后面的重新赋值仍然有效，第二次执行foo得到的结果就是2了。&lt;/p&gt;

&lt;h2 id=&quot;作用域闭包&quot;&gt;作用域闭包&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  bar();
}

foo();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是闭包吗？ 从技术上来讲，也许是。但是确切的说不是。准确的说bar()对a的引用方法是词法作用域的查找规则，这些规则只是闭包的一部分。但确实是非常重要的一部分。&lt;/p&gt;

&lt;p&gt;来看一个清晰的闭包例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}


var baz = foo();

baz(); // 2  这是一个闭包的效果
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数 bar() 的词法作用域能够访问foo() 的内部作用域。然后我们将bar()函数本身当作一个值类型进行传递， 在这个例子中，我们将bar所引用的函数对象本身当作返回值。&lt;/p&gt;

&lt;h2 id=&quot;动态作用域&quot;&gt;动态作用域&lt;/h2&gt;
&lt;p&gt;JavaScript只有词法作用域，并没有动态作用域&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
  console.log(a);
}

function bar() {
  var a = 3;
  foo();
}


var a = 2;

bar();  // 输出结果为2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;词法作用域，让foo在查找a时，只在全局作用域找到 &lt;code&gt;var a = 2&lt;/code&gt;, 所以这里显示2。 这里可能会疑惑为什么没有找到bar方法内部， 因为这里只是执行foo方法，如果像下面这样写，才会读到a = 3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function bar() {
  var a = 3;

  function foo() {
    console.log(a);
  }

  foo();
}


var a = 2;

bar();


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;块级作用域的替代方案&quot;&gt;块级作用域的替代方案&lt;/h2&gt;

&lt;p&gt;ES5之前块级作用域的解决方案catch或with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try{ throw 2 } catch(a){
  console.log(a);  // 2
}

console.log(a);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;let作用域或着let声明还可以这样用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let(a = 2) {
  console.log(a); // 2
}

console.log(a); // ReferenceError

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与隐式的劫持一个已经存在的作用域不同， let声明会显示的创建一个作用域并与其进行绑定。显示作用域不仅更突出，在代码重构时也表现更加健壮。
但是ES6语法不包含这个我们可以选择，合法的ES6语法，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  let a = 2;
  console.log(a);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以选择使用bable转换器 let-er这个转换器然后开启 这个设置项 。这样就可以直接使用了。&lt;/p&gt;

&lt;h2 id=&quot;关于this&quot;&gt;关于this&lt;/h2&gt;

&lt;p&gt;为什么要使用this？ this提供了一种更优雅的方式来隐式的传递对象引用，因此可以将API设计的更加简洁并且易于复用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
function foo(num) {
  console.log(&quot;foo:&quot; + num);
  this.count++;
}

foo.count = 0;

var i;

for(i = 0; i &amp;lt; 10; i++) {
  if(i &amp;gt; 5) {
    foo(i);
  }
}

//foo: 6
//foo: 7
//foo: 8
//foo: 9

console.log(foo.count); // 0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的this并没有指向自身， foo被当作方法调用时，this代表的是函数的接收者。 这里非严格模式下指向的是全局对象，然而全局对象进行++运算结果是NaN，foo.count作为foo这个函数对象的一个属性从来没有改变过。&lt;/p&gt;

&lt;p&gt;我们可以这样来改进x&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function foo(num) {
  console.log(&quot;foo:&quot; + num);
  data.count++;
}

var data = {
  count: 0;
}
var i;

for(i = 0; i &amp;lt; 10; i++) {
  if(i &amp;gt; 5) {
    foo(i);
  }
}

//foo: 6
//foo: 7
//foo: 8
//foo: 9


console.log(foo.count); // 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样貌似解决了问题，但是忽略了真正的问题，无法理解this的含义和工作原理而是返回了舒适区。&lt;/p&gt;

&lt;p&gt;另一种结局方案是使用foo标识符来替代this引用函数对象，但是同样回避了this的问题，并且完全依赖于变量foo的词法作用域&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
function foo(num) {
  console.log(&quot;foo:&quot; + num);
  foo.count++;
}

foo.count = 0;

var i;

for(i = 0; i &amp;lt; 10; i++) {
  if(i &amp;gt; 5) {
    foo(i);
  }
}

//foo: 6
//foo: 7
//foo: 8
//foo: 9

console.log(foo.count); // 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以强制使用this执行foo函数对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo(num) {
  console.log(&quot;foo:&quot; + num);
  data.count++;
}

var data = {
  count: 0;
}
var i;

for(i = 0; i &amp;lt; 10; i++) {
  if(i &amp;gt; 5) {
    foo.call(foo,i);
  }
}

//foo: 6
//foo: 7
//foo: 8
//foo: 9


console.log(foo.count); // 4

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;this的绑定规则&quot;&gt;this的绑定规则&lt;/h2&gt;

&lt;h3 id=&quot;默认绑定&quot;&gt;默认绑定&lt;/h3&gt;
&lt;p&gt;这是最常用的函数调用类型，独立函数调用。 这种情况this默认指向了全局对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo() {
  console.log(this.a);
}

var a = 2;

foo(); // 2

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;隐式绑定&quot;&gt;隐式绑定&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
}

obj.foo(); // 2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式加上了对于obj对象的引用，拥有了上下文，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上细纹对象。&lt;/p&gt;

&lt;p&gt;对象属性的引用链只有上一层或者说最后一层在调用位置中起作用。举例来说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo() {
  console.log(this.a);
}

var obj2 = {
  a: 42,
  foo: foo
}

var obj1 = {
  a: 2,
  obj2: obj2
}


obj1.obj2.foo(); // 42  最后一个obj2起作用


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个最常见的this对象绑定问题就是隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而吧this绑定到全局对象或着&lt;code&gt;undefined&lt;/code&gt;这取决于是否是严格模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
}


var bar = obj.foo;

var a = &quot;oops, global&quot;;

bar(); // oops, global
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一种，参数传递也是一种隐式赋值，因此我们穿日函数时也会被隐式赋值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
  console.log(this.a);
}

function doFoo(fn) {
  fn();
}

var obj = {
  a: 2,
  foo: foo
}


var bar = obj.foo;

var a = &quot;oops, global&quot;;

doFoo(obj.foo); // oops, global

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理如果向setTimeout中传递函数对象，同样会丢失this。&lt;/p&gt;

&lt;h3 id=&quot;显示绑定&quot;&gt;显示绑定&lt;/h3&gt;
&lt;p&gt;显示绑定通常使用 &lt;code&gt;call&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;、&lt;code&gt;bind&lt;/code&gt;，这些方式来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2
}

foo.call(obj);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;foo.call(…)， 我们可以调用foo时强制把它的this绑定到obj上。&lt;/p&gt;

&lt;p&gt;可惜的是显示绑定仍然无法解决我们之前提出的丢失绑定的问题。但是显示绑定的一个变种可以帮我们解决。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2
}

var bar = function() {
  foo.call(obj);
}

bar(); // 2

setTimeout(bar, 100); // 2

bar.call(window); // 2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function foo(something) {
  console.log(this.a, something);
}

var obj = {
  a: 2
}

var bar = function() {
  return foo.apply(obj, arguments);
}


var b = bar(3); // 2, 3

console.log(b);  // 5

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种使用方法是创建一个可以重复使用的辅助函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
function foo(something) {
  console.log(this.a);
  return this.a + something;
}

function bind(fn, obj) {
  return function() {
    fn.apply(obj, arguments);
  }
}


var obj = {
  a: 2
}

var bar = bind(foo, obj);

var b = bar(3); // 2 3

console.log(b); // 5


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于硬绑定是一种非常常用的模式，所以ES5提供了内置的方法&lt;code&gt;Function.ptototype.bind&lt;/code&gt;，它的用法如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo(something) {
  console.log(this.a);
  return this.a + something;
}


var obj = {
  a: 2
}

var bar = foo.bind(obj);

var b = bar(3); // 2 3

console.log(b); // 5


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;new绑定&quot;&gt;new绑定&lt;/h3&gt;
&lt;p&gt;虽然JavaScript中也有new操作符，使用方法看起来跟那些面向类的语言意义，绝大多数开发者都认为JavaScript中的new的机制也跟那些语言一样，然而JavaScript中的new机制实际上跟面向类的语言完全不同。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;构造函数 首先JavaScript中的构造函数只是使用new操作符调用的函数，它们并不会属于某个类，也不会实例化一个类，实际上它们甚至不能说是一种特殊的函数类型，它们只是被new操作符调用的普通函数而已。 函数被使用new操作符调用成为构造函数调用，实际上不存在所谓的构造函数，只有对于函数的构造调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
  this.a = a;
}

var bar = new foo(2);

console.log(bar.a); // 2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们创造了一个新的对象，并把它绑定到foo调用中的this上。&lt;/p&gt;

&lt;h2 id=&quot;优先级&quot;&gt;优先级&lt;/h2&gt;

&lt;p&gt;显示绑定比隐式绑定优先级要高， new绑定比隐式绑定优先级要高， 但是new绑定会得到一个新的对象。&lt;/p&gt;

&lt;h2 id=&quot;判断this&quot;&gt;判断this&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数是否在new中调用， 如果是的话this绑定的是新创建的对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数是否通过&lt;code&gt;call&lt;/code&gt;，&lt;code&gt;apply&lt;/code&gt;,或者硬绑定调用，如果是的话this是指定的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数是否在某个上下文对象中（隐式绑定）如果是的话，this绑定的是上下文对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果都不是的话，使用默认绑定。如果在严格模式下绑定到undefined， 否则绑定到全局对象。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;被忽略的this&quot;&gt;被忽略的this&lt;/h2&gt;

&lt;p&gt;如果你把null或undefined作为this绑定对象传入call，apply或者bind，这些值会在调用时被忽略，实际应用的是默认绑定规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function foo() {
  console.log(this.a);
}

var a = 2;

foo.call(null); // 2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用null忽略this可能产生一些副作用，如果某个函数确实使用了this（比如第三方库的一个函数）， 那默认绑定规则会把this绑定到全局对象。这将导致不可预计的后果。
所以我们使用一个更安全的空对象
在JavaScript中创建一个空对象最简单的方法是Obejct.create(null), 它和{}很像，但是不会创建Object.ptototype，所以它比{}更空&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;option + o
var ø = Object.create(null);


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;间接引用&quot;&gt;间接引用&lt;/h2&gt;

&lt;p&gt;还有一个需要注意的情况你可能创建一个函数的间接引用，调用这个函数会应用默认绑定规则&lt;/p&gt;

&lt;p&gt;间接引用最容易在赋值时发生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function foo() {
  console.log(this.a);
}

var a = 2;

var o = {
  a: 3,
  foo: foo
}

var p = {
  a: 4
}

o.foo(); // 3

(p.foo = o.foo)(); // 2


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋值表达式p.foo = o.foo的返回值是目标函数的引用，因此调用位置是foo() 而不是p.foo()或者o.foo();&lt;/p&gt;

&lt;h2 id=&quot;this词法&quot;&gt;this词法&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;self = this&lt;/code&gt;和箭头函数看起来都可以取代bind但本质上想取代的是this机制。如果你经常编写this风格的代码，但是绝大部份都会是用self = this,或者箭头函数，那么你或许应该&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;只使用此法作用域并且完全抛弃错误this风格代码;&lt;/li&gt;
  &lt;li&gt;完全采用this风格，在必要时使用bind，避免使用self = this 和 箭头函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;对象&quot;&gt;对象&lt;/h2&gt;

&lt;p&gt;在对象中，属性名永远都是字符串。使用非String作为属性名它首先会被转成一个字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myObject = {};

myObject[true] = &quot;foo&quot;;
myObject[3] = &quot;bar&quot;;
myObject[myObject] = &quot;baz&quot;;


myObject[&quot;true&quot;] = &quot;foo&quot;;
myObject[&quot;3&quot;] = &quot;bar&quot;;
myObject[&quot;[object OBject]&quot;] = &quot;baz&quot;;



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;对象复制&quot;&gt;对象复制&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;浅复制
var newObj = Object.assign({}, myObject);

深复制
对于JSON安全的对象来说有一种巧妙的复制方法

var newObj = JSON.parse(JSON.stringify(someObj));

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;属性描述符&quot;&gt;属性描述符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var myObject = {
  a: 2
}

Object.getOwnPropertyDescriptor(myObject, &quot;a&quot;);

// {value: 2, writable: true, enumerable: true, configurable: true}

如果configurable: false, 则不可以再配置，也不可以被删除

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;对象常量&quot;&gt;对象常量&lt;/h3&gt;
&lt;p&gt;结合writable: false 和configurable: false就可以创建一个真正的常量属性(不可以重新定义，修改，删除)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var myObject = {};

Object.defineProterty(myObject, &quot;FAVORITE_NUMBER&quot;, {
  value: 42,
  writable: false,
  configurable: false 
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;禁止扩展&quot;&gt;禁止扩展&lt;/h3&gt;

&lt;p&gt;如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(…)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var myObject = {
  a: 2
}

Object.preventExtensions(myObject);

myObject.b = 3;

myObject.b; // undefined

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在非严格模式下，创建属性b会静默失败，在严格模式下，将会抛出TyperError错误。&lt;/p&gt;

&lt;h3 id=&quot;密封&quot;&gt;密封&lt;/h3&gt;
&lt;p&gt;Object.seal(…)会创建一个”密封”对象，这个方法实际会在一个现有对象上调用Object.preventExtensions并把所有现有属性标记为configurable: false.
所有密封后不能添加新属性，也不能重新配置和删除任何现有属性(虽然可以修改属性的值)&lt;/p&gt;

&lt;h3 id=&quot;冻结&quot;&gt;冻结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Object.freeze(...)&lt;/code&gt;，会创建一个冻结对象，这个方法是在现有对象调用了&lt;code&gt;Object.seal&lt;/code&gt;并把所有数据访问属性标记为 writable: false, 这样就无法修改它们的值&lt;/p&gt;

&lt;h3 id=&quot;getter和setter&quot;&gt;Getter和Setter&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var myObject = {
  get a() {
    return 2;
  }
}

Object.defineProperty(myObject, &quot;b&quot;, {
  get: function() {
    return this.a * 2;
  },
  enumerable: true  

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常get和set是成对出现的，只定义一个的话通常会产生意料之外的行为。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var myObject = {
  get a() {
    return this._a_;
  }

  set a(val) {
    return this._a_ = val * 2;
  }
}


myObject.a = 2;

myObject.a; // 4


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;存在性&quot;&gt;存在性&lt;/h3&gt;

&lt;p&gt;前面说过 如果本身对象中有值为undefiend的属性obj.a, 去获取该值得到的结果跟去获取一个不存在的属性结果是一样的，比如obj.b， 那么如果判断一个属性在对象中是否存在呢&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var myObject = {
  a: 2
}

(a in myObject); // true
(b in myObject); // false

myObject.hasOwnProperty(&quot;a&quot;); // true
myObject.hasOwnProperty(&quot;b&quot;); // false


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in操作符会检查属性是否存在对象及其[[prototype]]原型中，相比之下hasOwnProperty只会检查属性是否存在myObject对象中。&lt;/p&gt;

&lt;p&gt;要注意的是in操作符检查的是容器内是否有某个值，实际上检查的是某个属性名是否存在。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4 in [2, 4, 6]; // false
这个数组包含的属性名其实是0 ，1，2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是否可通过for…in操作符来枚举可以通过定义属性是设定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var myObject = {};

Object.defineProperty(myObject, &quot;a&quot;, {
  enumerable: true, value: 2  
});

Object.defineProperty(myObject, &quot;b&quot;, {
  enumerable: false, value: 3
});


myObject.b; //3
{&quot;b&quot; in myObject}; //true
myObject.hasOwnProperty(&quot;b&quot;); //true


for(var k in myObject) {
  console.log(k, myObject[k]);
}

// &quot;a&quot; 2

还可以通过另一种方式来区分属性是否可枚举

propertyIsEnumerable 会检查属性是否存在于对象中(而不是在原型链中)并且满足enumerable: true
Object.keys会返回一个数组，包含所有可枚举属性
Object.getOwnPropertyNames 返回一个数组包含所有属性无论是否可枚举

myObject.propertyIsEnumerable(&quot;a&quot;); // true

myObject.propertyIsEnumerable(&quot;b&quot;); // false

Object.keys(myObject); // [&quot;a&quot;]

Object.getOwnPropertyNames(myObject); // [&quot;a&quot;, &quot;b&quot;]


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object.keys 和Object.getOwnPropertyNames 都不回查找原型链，只会查找对象直接包含的属性&lt;/p&gt;

&lt;h3 id=&quot;遍历&quot;&gt;遍历&lt;/h3&gt;
&lt;p&gt;我们通常会通过&lt;code&gt;for...in&lt;/code&gt;来遍历一个对象，但是这样便利对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能不一样，因此在不同的环境中需要保持一致性时，一定不要相信任何观察到顺序，它们是不可靠的
那么如何直接遍历值而不是数组下标呢&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var myArray = [1, 3, 5];

for(var v of myArray) {
  console.log(v);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为数组有内置的@iterator, 因此for…of可以直接应用到数组上。&lt;/p&gt;

&lt;p&gt;我们可以使用内置的@@iterator来手动遍历数组， ES6中我们使用Symbol.iterator来获取对象的@@iterator内部属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myArray = [1, 3, 5];

var it = myArray[Symbol.iterator]();

it.next();  // {value: 1, done: false}

it.next();  // {value: 3, done: false}

it.next();  // {value: 5, done: false}

it.next();  // {value: undefined, done: undefined}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和数组不同普通的对象没有内置的@@iterator,所以无法自动完成for…of遍历，之所以这样做有许多非常复杂的原因， 简单来说，这样做是为了避免影响未来的对象类型.&lt;/p&gt;

&lt;p&gt;当然我们可以给任何想遍历的对象定义@@iterator&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var myObject = {
  a: 2,
  b: 3
};

Object.defineProperty(myObject, Symbol.iterator, {
  enumerable: false,
  writable: false,
  configurable: true,
  value: function() {
    var o = this;
    var idx = 0;
    var ks = Object.keys(o);

    return {
      next: function() {
        return {
          value: o[ks[idx++]];
          done: (idx &amp;gt; ks.length)
        }
      }
    }
  }  
});

这样手动遍历

var it = myObject[Symbol.iterator]();
it.next(); // {value:2, done: false}
it.next(); // {value:3, done: false}
it.next(); // {value: undefined, done: true}


for(var v of myObject) {
  console.log(v);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;原型风格继承&quot;&gt;原型风格继承&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
function Foo(name) {
  this.name = name;
}

Foo.prototype.myName = function() {
  return this.name;
}

function Bar(name, label) {
  Foo.call(this, name);

  this.label = label;
}

Bar.prototype = Object.create(Foo.prototype);
// 这里还可以用这种写法，ES6 的 Object.setPrototypeOf  下面的写法更好一点， 当时上面的写法更容易理解
Object.setPrototypeOf(Bar.prototype, Foo.prototype);


Bar.prototype.myLabel = function() {
  return this.label;
}

var a = new Bar(&quot;a&quot;, &quot;obj a&quot;);

a.myName(); // &quot;a&quot;

a.myLabel(); // &quot;obj a&quot;


该方法比较有用，Foo.prototype是否出现在a的[[prototype]]链中
Foo.prototype.isPrototypeOf(a);

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;委托&quot;&gt;委托&lt;/h2&gt;
&lt;p&gt;基于委托实现与上面相同功能的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Foo = {
  init: function(who) {
    this.me = who;
  },
  identify: function() {
    return &quot;I am &quot; + this.name;
  }
}

Bar = Object.create(Foo);

Bar.speak = function() {
  alert(&quot;Hello, &quot; + this.identify() + &quot; . &quot;);
}


var b1 = Object.create(Bar);
b1.init(&quot;b1&quot;);

var b2 = Object.create(Bar);
b2.init(&quot;b2&quot;);

b1.speak();
b2.speak();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过比较发现， 对象关联风格的代码更加简洁，因为这种风格的代码只关注一件事， 对象之间的关联关系。&lt;/p&gt;

&lt;h2 id=&quot;更简洁的设计&quot;&gt;更简洁的设计&lt;/h2&gt;
&lt;p&gt;一个关于登陆验证器的设计&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function Controller() {
  this.errors= [];
}

Controller.prototype.showDialog = function(title, msg) {
  // 显示给用户的消息
}

Controller.prototype.success = function(msg) {
  this.showDialog(&quot;success&quot;, msg);
}

Controller.prototype.failure = function(err) {
  this.errors.push(err);

  this.showDialog(&quot;Error&quot;, err);
}


function LoginController() {
  Controller.call(this);
}

LoginController.prototype = Object.create(Controller.prototype);

LoginController.prototype.getUser = function() {
  return document.getElementById(&quot;login_username&quot;).value;
}

LoginController.prototype.getPassword = function() {
  return document.getElementById(&quot;login_password&quot;).value;
}


LoginController.prototype.validateEntry = function(user, pw) {
  user = user || this.getUser();
  pw = pw || this.getPassword();

  if(!(user &amp;amp;&amp;amp; pw)) {
    return this.failure(&quot;Please enter a username &amp;amp; password&quot;);
  }
  else if(pw.length &amp;lt; 5) {
    return this.failure(&quot;Password must be 5+ character!&quot;);
  }

  return true;
}

LonginController.prototype.failure = function() {
  Controller.prototype.failure.call(this, &quot;Login invalid: &quot; + err);
}




function AuthController(login) {
  Controller.call(this);

  this.login = login;
}

AuthController.prototype = Object.create(Controller.prototype);

AuthController.prototype.server = function(url, data) {
  return $.ajax({
    url: url,
    data: data
  });
}

AuthController.prototype.checkAuth = function() {
  var user = this.login.getUser();
  var pw = this.login.getPassword();

  if(this.login.validateEntry(user, pw)) {
    this.server(&quot;/check-auth&quot;, {
      user: user,
      pw: pw
    })
    .then(this.success.bind(this));
    .fail(this.failure.bind(this));
  }
}


AuthController.prototype.success = function() {
  Controller.prototype.success.call(this, &quot;Authenticated;&quot;);
}

AuthController.prototype.failure = function(err) {
  Controller.prototype.failure.call(this, &quot;Auth failed: &quot; + err);
}


var auth = new AuthController(new LoginController());

auth.checkAuth();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反类，我们可以使用对象关联风格的行为委托来实现更简单的设计&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var LoginController = {
  errors: [],
  getUser: function() {
    return document.getElementById(&quot;login_username&quot;).value;
  },

  getPassword: function() {
    return document.getElementById(&quot;login_password&quot;).value;
  },
  validateEntry: function(user, pw) {
    user = user || this.getUser();
    pw = pw || this.getPassword();

    if(!(user &amp;amp;&amp;amp; pw)) {
      return this.failure(&quot;Please enter a username &amp;amp; password&quot;);
    }
    else if(pw.length &amp;lt; 5) {
      return this.failure(&quot;Password must be 5+ character!&quot;);
    }

    return true;
  },
  showDialog: function() {
    // 给用户显示的消息
  },
  failure: function() {
    this.errors.push(err);
    this.showDialog(&quot;Error&quot;, &quot;Login invalid &quot; + err);
  },
  success: function(msg) {
    this.showDialog(&quot;success&quot;, msg);
  }

}



var AuthController = Object.create(LoginController);

AuthController.errors = [];

AuthController.checkAuth = function() {
  var user = this.getUser();
  var pw = this.getPassword();

  if(this.validateEntry(user, pw)) {
    this.server(&quot;/check-auth&quot;, {
      user: user,
      pw: pw  
    })
    .then(this.accepted.bind(this))
    .fail(this.rejected.bind(this));
  }
}

AuthController.server = function(url, data) {
  return $.ajax({
    url: url,
    data: data  
  })
}

AuthController.accepted = function() {
  this.showDialog(&quot;Success&quot;, &quot;Authenticated!&quot;);
}

AuthController.rejected = function(err) {
  this.failure(&quot;Auth Failed: &quot; + err);
}


AuthController.checkAuth();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种模式我们只需要两个实体LoginController 和 AuthController
总结： 我们用一种极其简单的设计实现了同样的功能， 这既是对象关联风格代码和行为委托设计模式的力量&lt;/p&gt;

&lt;h2 id=&quot;反词法&quot;&gt;反词法&lt;/h2&gt;
&lt;p&gt;ES6简洁与法有一个非常小但重要的缺点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var Foo = {
  bar() {/**/},
  baz: function baz() {/**/}  
}

去掉语法糖

var Foo = {
  bar: function() {/**/}
  baz: function baz() {/**/}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于函数对象本身没有标识符， 所以bar()的缩写形式实际上会变成一个匿名函数表达式并赋值给bar属性。相比之下 具名函数表达式会额外的给.baz属性附加一个词法名称标识符baz。&lt;/p&gt;

&lt;p&gt;匿名函数没有name标识符会导致&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;调用栈更难追踪&lt;/li&gt;
  &lt;li&gt;自我引用（递归， 事件绑定和解除绑定）更难&lt;/li&gt;
  &lt;li&gt;代码稍微难理解&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里只有第二个缺点无法避免，因此使用简洁语法一定要小心这一点。 如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数，不要使用简洁语法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;再说一次，我们认为JavaScript种的对象关联比类风格代码更为简洁(而且功能相同)&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">本书是读完 Effective JavaScript之后开的进行的阅读，整理自己需要注意的点。方便以后巩固。</summary></entry><entry><title type="html">Effective JavaScript (十)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-ten/" rel="alternate" type="text/html" title="Effective JavaScript (十)" /><published>2018-09-28T00:00:00+08:00</published><updated>2018-09-28T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-ten</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-ten/">&lt;h2 id=&quot;并发&quot;&gt;并发&lt;/h2&gt;

&lt;p&gt;JavaScript被设计成一种嵌入式的脚本语言。它不是以单独的应用程序运行，而是作为大型应用程序环境下的脚本运行。典型的例子当然是Web浏览器。
JavaScript中编写响应多个并发事件的程序的方法非常人性化，而且强大，因为它使用了一个简单的执行模型(有时称为事件队列和事件循环并发)和被称为异步的API.
奇怪的是，到目前为止，ECMAScript标准从来没有关于并发的说明。我们讨论的都是“约定成俗”的JavaScript特性，并不是官方标准。然而，绝大多数JavaScript的环境都使用相同的并发策略，未来标准的版本很有可能会基于广泛实现的执行模型来标准化。不管标准如何定义，使用事件和异步API是JavaScript编程的基础部分。&lt;/p&gt;

&lt;h2 id=&quot;不要阻塞io事件队列&quot;&gt;不要阻塞I/O事件队列&lt;/h2&gt;

&lt;p&gt;JavaScript程序是建立在事件之上的。输入可能来自各种各样的外部源，用户的交互操作，输入的网络数据或定时警报，我们通常会写这样的代码来等待某个特定的输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var text = downloadSync(&quot;http://example.com/file.txt&quot;);

console.log(text);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的函数通常被称为同步函数或阻塞函数， 程序会停止工作，等待它的输入。这个例子是等的网络下载文件的结果。&lt;/p&gt;

&lt;p&gt;在JavaScript中，大多数的I/O操作都提供了异步的或非阻塞的API, 程序提供一个回调函数，一旦输入完成就可以被系统调用， 而不是将程序阻塞在等待结果的线程上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dowanloadAsync(&quot;http://example.com/file.txt&quot;, function(text) {
	console.log(text);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript并发的一个重要规则是绝不要在应用程序事件队列中使用阻塞I/O的API。对于Web应用程序的交互性，同步的I/O会导致灾难性的结果，在操作完成之前一直会阻塞用户于页面的交互。&lt;/p&gt;

&lt;p&gt;Web平台提供了Workder的API，使得产生大量的并行计算称为可能。不同于传统的线程执行Workders在一个完全隔离的状态下进行，没有获取全局作用域或应用程序主线程Web页面内容的能力。因此它不回妨碍主事件队列中运行的代码的执行。在一个Worker中使用XMLHttpRequest同步的变种很少出问题。下载操作的确会阻塞Worker继续运行，但这并不会组织要么的渲染或事件队列中的事件响应。&lt;/p&gt;

&lt;h2 id=&quot;在异步序列中使用嵌套或命名的回调函数&quot;&gt;在异步序列中使用嵌套或命名的回调函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, function(url) {
	//	
});

downloadAsync(url, function(text) {
	console.log(&quot;contents of &quot; + url + &quot; : &quot; + text);
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个异步函数第二个的url读取不到，我们可以使用嵌套&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, function(url) {
	downloadAsync(url, function(text) {
		console.log(&quot;contents of &quot; + url + &quot; : &quot; + text);
	});
});


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是回调函数越来越多会变得很笨拙。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, function(url) {
	downloadAsync(url, function(text) {
		downloadAsync(&quot;a.txt&quot;, function(a) {
			downloadAsync(&quot;b.txt&quot;, function(b) {
				// ...
			})	
		})
	});
});


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;减少嵌套的方法之一就是将嵌套的回调函数作为命名的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, downloadURL);


// 仍然有嵌套
function downloadURL(url) {
	downloadAsync(url, function(text) {
		showContents(url, text);
	});
}

function showContents(url, text) {
	console.log(&quot;contents of &quot; + url + &quot; : &quot; + text);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中仍然有嵌套，我们可以使用bind方法消除最深层的嵌套回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, downloadURL);


// 仍然有嵌套
function downloadURL(url) {
	downloadAsync(url, showContents.bind(null, url));
}

function showContents(url, text) {
	console.log(&quot;contents of &quot; + url + &quot; : &quot; + text);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果层级过多仍然会有问题， 比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, downloadURL);


function downloadURL(url) {
	downloadAsync(url, downloadABC.bind(null, url));
}

function downloadABC(url, file) {
	downloasAsync(&quot;a.txt&quot;, downloadFileBC.bind(null, url, file))
}

function downloadBC(url, file, a) {
	downloasAsync(&quot;b.txt&quot;, downloadFileFinish.bind(null, url, file, a))
}

function downloadFileFinish(url, file, a, b) {
	// ...
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如尴尬的函数命名，和参数传递。最好的方式还是将两种方式结合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
db.lookupAsync(&quot;url&quot;, function(url) {
	downloadURLAndFiles(url);
});


function downloadURLAndFiles(url) {
	downloadAsync(url, downloadFiles.bind(null, url));
}

function downloadFiles(url, file) {
	downloadAsync(&quot;a.txt&quot;, function(a) {
		downloadAsync(&quot;b.txt&quot;, function(b) {
			// ...
		})	
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更好的方法是抽象出一个可以下载多个文件的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function downloadFiles(url, file) {
	downloadAllAsync([&quot;a.txt&quot;, &quot;b.txt&quot;, &quot;c.txt&quot;], function(all) {
		var a = all[0], b = all[1], c = all[2];
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;当心丢弃错误&quot;&gt;当心丢弃错误&lt;/h2&gt;

&lt;p&gt;同步代码我们可以通过&lt;code&gt;try...catch&lt;/code&gt;来捕获所有错误，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
	f();
	g();
	h();
} catch(e) {
	// handle any error that occured
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是异步代码根本不可能抛出异常， 通常异步API会有一个额外的回调函数来处理网络错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
downloadAsync(&quot;url&quot;, function(text) {
		
}, function(err) {
	console.log(&quot;Error &quot; + err)	;
});

多个回调时可以提取公共部分

function onErr(err) {
	console.log(&quot;Error &quot; + err)	;
}

downloadAsync(&quot;url&quot;, function(text) {
		
}, onErr);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js 异步处理API的错误处理，我们通过if判断来控制每个回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function onErr(err) {
	console.log(&quot;Error &quot; + err)	;
}

downloadAsync(&quot;url&quot;, function(error, text) {
	if(error) {
		onError(error);
		return false;
	}

	//success
});


更简洁写法

downloadAsync(&quot;url&quot;, function(error, text) {
	if(error) return onError(error);

	//success
});


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;对异步循环使用递归&quot;&gt;对异步循环使用递归&lt;/h2&gt;

&lt;p&gt;如果一个函数接受一个URL的数组并尝试下载买每个文件，如果API是同步的很容易实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function downloadOneSync(urls) {
	for(var i = 0, n = urls.length; i &amp;lt; n; i++) {
		try {
			return downloadSync(urls[i]);
		} catch(e) {

		}
	}

	throw new Error(&quot;all downloads failed&quot;);
}
如果调用downloadAsync的话会所有文件一起下载没有顺序，所以我们需要这样做在每个回调结束调用自身

function downloadOneAsync(urls, onsuccess, onfailur) {
	var n = urls.length;

	function tryNextURL(i) {
		if(i &amp;gt;= n) {
			onfailur(&quot;all downloads failed&quot;);
			return;
		}

		downloadAsync(urls[i], onsuccess, function() {
			tryNextURL(i + 1);
		})
	}

	tryNextURL(0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;局部函数tryNextURL是一个递归函数。它的实现调用了自身。 目前典型的JavaScript环境中一个递归函数调用自身多次会导致失败。
因为当一个程序执行有太多的函数调用，它会耗尽栈空间，最终抛出异常。这种情况被称为栈溢出。&lt;/p&gt;

&lt;p&gt;该例子调用100000次会产生一个运行时错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function countdown(n) {
	if(n === 0) {
		return &quot;done&quot;;
	} else {
		return countdown(n -1);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;异步操作不需要等待递归回调返回后才返回，调用栈不回有十万个函数在等待。每次有进有出只调用一个。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;循环不能是异步的&lt;/li&gt;
  &lt;li&gt;使用递归函数在事件循环的单独轮次中执行迭代&lt;/li&gt;
  &lt;li&gt;在事件循环的单独轮次中执行递归，并不会导致栈溢出&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;不要在计算时阻塞事件队列&quot;&gt;不要在计算时阻塞事件队列&lt;/h2&gt;

&lt;p&gt;如果你的程序需要执行代价高昂的计算你该怎么办，最简单的方法就是使用想Web客户端平台的Worker API这样的并发机制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var ai = new Worker('ai.js');

var userMove = /* *** */;

ai.postMessage(JSON.stringify({
	userMOve: userMove
}));


ai.onmessage = function(event) {
	executeMove(JSON.parse(event.data).computerMove);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样会产生一个新的线程独立的事件队列的并发执行线程。该worker是一个完全隔离的状态–没有任何应用程序对象的直接访问。但是，应用程序于worker之间可以功过发送形式为字符串的message来交互。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;避免在主事件队列中执行代价高昂的计算&lt;/li&gt;
  &lt;li&gt;在支持Worker API的平台，该API可以用来在一个独立的事件队列中运行长计算程序。&lt;/li&gt;
  &lt;li&gt;在Worker API不可用活代价高昂的环境中，考虑将计算程序分解到事件循环的多个轮次中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用计数器来执行并行操作&quot;&gt;使用计数器来执行并行操作&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function downloadAllAsync(urls, onsuccess, onerror) {

	var result = [], length = urls.length;

	if(length === 0) {
		setTimeout(onsuccess.bind(null, result), 0);
		return;
	}

	urls.forEach(function(url) {
		downloadAsync(url, function(rext) {
			if(result) {
				result.push(text);
				if(result.length === urls.length) {
					onsuccess(result);
				}
			}
		}, function(error) {
			if(result) {
				result = null;
				onerror(error);
			}
		});
	})
}

这段代码有个错误

var filenames = [
	&quot;huge.txt&quot;,
	&quot;tiny.txt&quot;,
	&quot;medium.txt&quot;,
];

downloadAllAsync(filenames, function(files) {
	console.log(&quot;Huge file: &quot; + files[0].length); // tiny
	console.log(&quot;Tiny file: &quot; + files[0].length); // medium
	console.log(&quot;Medium file: &quot; + files[0].length); // huge
}, function(error) {
	console.log(&quot;Error : &quot; + error);
});


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里下载文件的顺序并不可控，因为文件是并行下载的。 调用者无法找出那个结果对应哪个文件， 上面的例子假设结果合输入有相同的顺序其实是错误的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function downloadAllAsync(urls, onsuccess, onerror) {

	var result = [], length = urls.length;

	if(length === 0) {
		setTimeout(onsuccess.bind(null, result), 0);
		return;
	}

	urls.forEach(function(url, i) {
		downloadAsync(url, function(text) {
			if(result) {
				
				result[i] = text;
				if(result.length === urls.length) {
					onsuccess(result);
				}
			}
		}, function(error) {
			if(result) {
				result = null;
				onerror(error);
			}
		});
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个版本也有问题如果先下载完成的是第三个文件则 result[2] = text; 那么result的长度也是3， 则直接在if条件中返回，用户的success回调函数将被过早调用，其参数为一个不完整的结果数组。&lt;/p&gt;

&lt;p&gt;所以正确的方式应该是这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function downloadAllAsync(urls, onsuccess, onerror) {

	var result = [], pending = urls.length;

	if(pending === 0) {
		setTimeout(onsuccess.bind(null, result), 0);
		return;
	}

	urls.forEach(function(url, i) {
		downloadAsync(url, function(text) {
			if(result) {
			
				result[i] = text;
				pending--;
				if(pending === 0) {
					onsuccess(result);
				}
			}
		}, function(error) {
			if(result) {
				result = null;
				onerror(error);
			}
		});
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;绝不要同步的调用异步的回调函数&quot;&gt;绝不要同步的调用异步的回调函数&lt;/h2&gt;

&lt;p&gt;加入下载文件的例子有一个缓存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cache = new Dict();

function downloadCachingAsync(url, onsuccess, onerrur) {
	if(cache.has(url)) {
		onsuccess(cache.get(url));  // 同步调用
	}

	return downloadAsync(url, function(file) {
		cache.set(url, file);
		onsuccess(file);
	}, onerror);
}

通常情况如果可以回立即提供数据，但这改变了用户预期

downloadAsync(&quot;file.txt&quot;, function(file) {
	console.log(&quot;finished&quot;);
});

console.log(&quot;starting&quot;);

这里按照我们预想 可能先返回 &quot;starting&quot; 然后 &quot;finished&quot;, 但是由于同步调用了函数，
这里如果文件有缓存的话 先返回了&quot;finished&quot; 然后才是 &quot;starting&quot;; 这与我们的预想不符。
所以我们应该这样来使用

if(cache.has(url)) {
	var cached = cache.get(url);
	setTimeout(onsuccess.bind(null, cached), 0);
	return;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用promise模式清洁异步逻辑&quot;&gt;使用promise模式清洁异步逻辑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
downloadAsync(&quot;file.txt&quot;, function(file) {
	console.log(&quot;file : &quot; + file);
});


相比之下，基于promise的API不接受回调函数作为参数

var p = downloadP(&quot;file.txt&quot;);

p.then(function(file) {
	console.log(&quot;file: &quot; + file);
});

promise的返回值是一个新的promise

var fileP = downloadP(&quot;file.txt&quot;);

var lengthP = fileP.then(function(file) {
	return file.length;
});

lengthP.then(function(length) {
	console.log(&quot;length: &quot; + length);
});


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;promise通常提供给一个叫做when的工具函数，或者join&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var filesP = join(downloadP(&quot;file1.txt&quot;),
				downloadP(&quot;file2.txt&quot;),
				downloadP(&quot;file3.txt&quot;));

filesP.then(function(files) {
	// files[0]
});


var fileP1 = downloadP(&quot;file1.txt&quot;);
var fileP2 = downloadP(&quot;file2.txt&quot;);
var fileP3 = downloadP(&quot;file3.txt&quot;);

when([fileP1, fileP2, fileP3], function(files) {
	console.log(&quot;file1: &quot; + files[0]);

})

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用select或choose工具函数可以使几个promise彼此竞争。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var filesP = select(downloadP(&quot;file1.txt&quot;),
				downloadP(&quot;file2.txt&quot;),
				downloadP(&quot;file3.txt&quot;));

filesP.then(function(file) {
	//file
	// 返回值最先完成下载的文件的promise
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;select函数的另一个用途是提供超时来终止长时间的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fileP = select(downloadP(&quot;file.txt&quot;), timeoutErrorP(2000));

filep.then(function(file) {
	console.log(&quot;file: &quot; + file);
}, function(error) {
	console.log(&quot;I/O error or timeout: &quot; + error);
})

&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">并发</summary></entry><entry><title type="html">Effective JavaScript (九)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-nine/" rel="alternate" type="text/html" title="Effective JavaScript (九)" /><published>2018-09-28T00:00:00+08:00</published><updated>2018-09-28T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-nine</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-nine/">&lt;h2 id=&quot;保持一致的约定&quot;&gt;保持一致的约定&lt;/h2&gt;

&lt;h2 id=&quot;将undefined当作没有值&quot;&gt;将undefined当作没有值&lt;/h2&gt;
&lt;p&gt;undefined很特殊，每当JavaScritp无法提供具体的值时，就产生undefined。为赋值的初始值即为undefiend&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x;
x // undefined;

var obj = {};
obj.x; //undefined


function f() {
	return ;
}

function g() {}


f();  //undefined
f();  //undefined

function f(x) {
	return x;
}
f(); // undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如一个Web服务器可以接受一个可选的主机名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s1 = new Server(80, &quot;example.com&quot;);

var s2 = new Server(80); //defaults to &quot;localhost&quot;

我们可以通过判断arguments.length来实现Server构造函数

function Server(port, hostname) {
	if(arguments.length &amp;lt; 2) {
		hostname = &quot;localhost&quot;;
	}

	hostname = String(hostname);
}

这种情况如果第二个值是undefined的话可能会使用undefined，这并不是我们想要的所以我们最好判断undefined

function Server(port, hostname) {
	if(hostname === undefined) {
		hostname = &quot;localhost&quot;;
	}

	host = String(hostname);
}


另一种合理的方式是测试hostname是否为真

function Server(port, hostname) {
	hostname = String(hostname || &quot;localhost&quot;);
	// ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是最后一种的真值检测并不总是安全的，如果一个函数允许接受0(或NaN，虽然不常见)为可接受的参数,则不应该使用真值测试&lt;/p&gt;

&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;

function Element(width, height) {
	this.width = width || 320;
	this.height = height || 240;
	// ...
}
var c1 = new Element(0, 0); 
c1.width; // 320
c1.height; // 240


这种情况我们需要更详细的测试来测试undefined
function Element(width, height) {
	this.width = width === undefined ? 320 : width;
	this.height = height === undefined ? 240 : height;

	// ...
}

var c1 = new Element(0, 0);
c1.width; // 0
c1.height; // 0

var c2 = new Element();
c2.width; // 320
c2.height; // 240

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;接受关键字参数的选项对象&quot;&gt;接受关键字参数的选项对象&lt;/h2&gt;
&lt;p&gt;保持参数顺序的一致约定对于帮助程序员记住每个参数在函数调用中的意义是很重要的，参数较少时它是适用的。但是参数过多后根本不可扩展&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var alert = new Alert(100, 75, 300, 200,
		&quot;Error&quot;, message,
		&quot;blue&quot;, &quot;white&quot;, &quot;black&quot;,
		&quot;error&quot;, true
	);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个函数起初很简单，但是过一段时间，随着库功能的扩展，该函数的签名便会获得越来越多的参数。&lt;/p&gt;

&lt;p&gt;幸运的是，JavaScrtip提供了一个简单、轻量的惯用法： 选项对象(options object).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var alert = new Alert({
	x: 100, y: 75,
	width: 300, height: 200,
	title: &quot;Error&quot;, message: message,
	titleColor: &quot;blue&quot;, bgColor: &quot;white&quot;, textColor: &quot;black&quot;,
	icon: &quot;error&quot;, modal: true	
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个虽然烦琐，但明显更易于阅读，每个参数都是自我描述(self-documenting)的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Alert(parent, message, opts) {
	opts = opts || {};

	this.width = opts.width === undefined ? 320 : opts.width;
	this.height = opts.width === undefined ? 240 : opts.height;
	this.title = otps.title || &quot;Alert&quot;;

}

基于 extend 的另一种实现

function extend(target, source) {
	if(source) {
		for(var key in source) {
			var val = source[key];

			if(typeof val !== &quot;undefined&quot;) {
				target[key] = val;
			}
		}
	}

	return target;
}



function Alert(parent, message, opts) {
	opts = extend({
		width: 320,
		height: 240
	});

	opts = extend({
		title: &quot;Alert&quot;	
	}, opts);

	this.width = opts.width;
	this.height = opts.height;
	this.title = opts.title;

}


进一步简化


unction Alert(parent, message, opts) {
	opts = extend({
		width: 320,
		height: 240
	});

	opts = extend({
		title: &quot;Alert&quot;	
	}, opts);

	extend(this, opts);
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;区分数组对象和类数组对象&quot;&gt;区分数组对象和类数组对象&lt;/h2&gt;

&lt;p&gt;使用instanceof的不完美选择&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringSet.prototype.add = function(x) {
	if(typeof x === 'String') {
		// xxx
	} else if(x instanceof Array) { //有局限性
		// xxx
	} else {
		// xxx
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instanceof 操作符测试一个对象是否继承自Array.prototype。 在一些允许多个全局对象的环境中可能会有标准的Array构造函数和原型对象的多份副本。在浏览器中有这种情况，每个frame会有标准库的一份单独副本，当跨frame通信时，一个frame中的数组不会继承自另一个frame的Array.prototype.出于这个原因，ES5中引入了&lt;code&gt;Array.isArray&lt;/code&gt;函数， 其用于测试一个值是否是数组，而不管原型继承。ESMAScript标准中， 该函数测试对象内部[[Class]]属性值是否是Array。它比&lt;code&gt;instanceof&lt;/code&gt;更加可靠。
所以有这个更健壮的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringSet.prototype.add = function(x) {
	if(typeof x  === 'String') {

	} else if(Array.isArray(x)) {

	} else {

	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于不支持ES5的环境中我们可以自己实现一个测试方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var toString = Object.prototype.toString;

function isArray(x) {
	return toString(x) === '[object Array]';
}


// 转为真实数组
你不能传入arguments对象并期待它被视为数组，
最好还是自己转化一下
[].slice.call(arguments);



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Object.prototype.toString&lt;/code&gt;函数使用对象内部&lt;code&gt;[[Class]]&lt;/code&gt;属性创建结果字符串，所以比&lt;code&gt;instance of&lt;/code&gt;操作符更可靠。&lt;/p&gt;

&lt;h2 id=&quot;避免过度的强制转换&quot;&gt;避免过度的强制转换&lt;/h2&gt;

&lt;p&gt;我们创建一个BitVector的构造函数guard, 这里有一个思路可以用来做检测用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function BitVector(x) {
	// 链式调用
	uint32.or(arrayLike).guard(x);
}


var guard = {
	guard: function(x) {
		if(!this.test(x)) {
			throw new TypeError(&quot;expected &quot; + this);
		}
	}
}

var uint32 = Object.create(guard);

uint32.toString = function() {
	return &quot;uint32&quot;;
}


var arrayLike = Object.create(guard);

arrayLike.test = function(x) {
	return typeof x === &quot;object&quot; &amp;amp;&amp;amp; x &amp;amp;&amp;amp; uint32.test(x.length);
}

arrayLike.toString = function() {
	return &quot;array-like object&quot;;
}


guard.or = function(other) {
	var result = Object.create(guard);

	var self = this;
	result.test = function(x) {
		return self.test(x) || other.text(x);
	};

	var description = this + &quot; or &quot; + other;

	result.toString = function() {
		return description;
	};

	return result;

}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;支持方法链&quot;&gt;支持方法链&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function escapeBasicHTML(str) {
	return str.replace(/&amp;amp;/g, &quot;&amp;amp;amp;&quot;)
			  .replace(/&amp;lt;/g, &quot;&amp;amp;lt;&quot;)
			  .replace(/&amp;gt;/g, &quot;&amp;amp;gt;&quot;)
			  .replace(/&quot;/g, &quot;&amp;amp;quot;&quot;)
			  .replace(/'/g, &quot;&amp;amp;apos;&quot;);
}

这种比下面的方法更加简洁

function escapeBasicHTML(str) {
	var str2 = str.replace(/&amp;amp;/g, &quot;&amp;amp;amp;&quot;);
	var str3 = str2.replace(/&amp;lt;/g, &quot;&amp;amp;lt;&quot;);
	var str4 = str3.replace(/&amp;gt;/g, &quot;&amp;amp;gt;&quot;);
	var str5 = str4.replace(/&quot;/g, &quot;&amp;amp;quot;&quot;);
	var str6 = str5..replace(/'/g, &quot;&amp;amp;apos;&quot;);

	return str6;
}


var users = records.map(function(record) {
		return record.username;
	})
	.filter(function(username) {
		return !!username;
	})
	.map(function(username) {
		return username.toLowerCase();
	});

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用方法链来连接无状态的操作&lt;/li&gt;
  &lt;li&gt;通过无状态的方法中返回新对象来支持方法链&lt;/li&gt;
  &lt;li&gt;通过在有状态的方法中返回this来支持方法链&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">保持一致的约定</summary></entry><entry><title type="html">Effective JavaScript (八)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/25/read-book-effective-eight/" rel="alternate" type="text/html" title="Effective JavaScript (八)" /><published>2018-09-25T00:00:00+08:00</published><updated>2018-09-25T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/25/read-book-effective-eight</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/25/read-book-effective-eight/">&lt;h2 id=&quot;使用object的直接实例构造轻量级的字典&quot;&gt;使用Object的直接实例构造轻量级的字典&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var dict = { alice: 34, bob: 24, chris: 62 };

var people = [];

for(var name in dict) {
	people.push(name + &quot;: &quot; + dict[name]);
}

people; // [&quot;alice: 34&quot;, &quot;bob: 24&quot;, &quot;chris: 62&quot;];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们创建一个自定义的字典类会怎样呢&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function NaiveDict() {}

NaiveDict.prototype.count = function() {
	var i = 0;
	for(var name in this) {
		i++;
	}

	return i;
};

NaiveDict.prototype.toString = function() {
	return &quot;[object NaiveDict]&quot;;
};

var dict = new NaiveDict();

dict.alice = 34;
dict.bob = 24;
dict.chris = 62;

dict.count(); // 5

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样有一个问题，count会枚举出所有的属性包括了toString 和count,而不仅仅是我们需要的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dict = new Array();

dict.alice = 34;
dict.bob = 24;
dict.chris = 62;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样也会有问题，代码对原型污染很脆弱，应用程序的其他库有可能会打猴子补丁，比如&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;原型污染是指当枚举字典的条目时，原型对象中的一些属性可能会导致出现一些不期望的属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Array.prototype.first = function() {
	return this[0];
}

Array.prototype.last = function() {
	return this[1];
}

var names = [];
for(var name in dict) {
	names.push(name);
}

names; [&quot;alice&quot;, &quot;bob&quot;, &quot;chris&quot;, &quot;first&quot;, &quot;last&quot;]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用使用 &lt;code&gt;new Object() &lt;/code&gt;可能会面临同样的问题，但是使用 &lt;code&gt;{}&lt;/code&gt;的方式会更好, 虽然不能保证对于原型污染时安全的，任何人仍然能增加属性到Object.prototype，但是风险可以降低到仅仅局限于Object.prototype&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;坚持使用Object的直接实例原则可以使for…in循环摆脱原型污染的影响&lt;/li&gt;
  &lt;li&gt;使用对象字面量构建轻量级字典&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用null原型以防止原型污染&quot;&gt;使用null原型以防止原型污染&lt;/h2&gt;

&lt;p&gt;防止原型污染的最简单的方式之一就是一开始就不使用原型。但是ES5发布之前并没有一个标准的方式创建一个空原型的新对象。你可能会这样做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function C() { }

C.prototype = null;

var o = new C();

Object.getPrototypeOf(o) === null; // false
Object.getPrototypeOf(o) === Object.prototype // true


// ES5之后应该这样做
var x = Object.create(null);

Object.getPrototypeOf(o) === null; // true

在不支持Object.create的JavaScript环境中特殊对象__proto__提供了对对象内部原型链的读写访问

var x = { __proto__: null };

x instanceof Object;  // false;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种貌似更方便，但是有了Object.create函数后，Object.create是更值得推荐的方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在ES5中要使用Object.create(null)创建自由原型的空对象是不太容易被污染的。&lt;/li&gt;
  &lt;li&gt;在一些老环境中考虑使用{ &lt;strong&gt;proto&lt;/strong&gt;: null }， 但是它既不是标准的也不是可移植的还有可能在未来被删除&lt;/li&gt;
  &lt;li&gt;绝对不要使用__proto__作为字典中的key&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用hasownproperty方法避免原型污染&quot;&gt;使用hasOwnProperty方法避免原型污染&lt;/h2&gt;
&lt;p&gt;JavaScript的对象操作总是以继承的方式工作，即使一个空的对象字面量也继承了Object.prototype的大量属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dict = {}
&quot;alice&quot; in dict; //false;
&quot;bob&quot; in dict; //false;
&quot;chris&quot; in dict; //false;

// toString 和valueOf方法继承自Object.prototype
&quot;toString&quot; in dict; //false;  
&quot;valueOf&quot; in dict; //false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;幸运的是Object.hasOwnProperty方法可以用来判断属性是否继承自原型对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dict.hasOwnProperty(&quot;alice&quot;);     // false
dict.hasOwnProperty(&quot;toString&quot;);  // false
dict.hasOwnProperty(&quot;valueOf&quot;);   // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不幸的是我们没有完全解决问题，当调用dict.hasOwnProperty时，我们请求调查对象的hasOwnProperty方法，通常情况下，该方法会简单的继承自Object.property对象，然而如果字典中存储一个同名的条目时，那么原型中的hasOwnProperty方法不能再被捕获到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dict.hasOwnProperty = 10;

dict.hasOwnProperty(&quot;alice&quot;);
// error dict.hasOwnProperty is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是有可能的,最安全的方式就是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var hasOwn = Object.prototype.hasOwnProperty;
或者
var hasOwn = {}.hasOwnProperty;

hasOwn.call(dict, &quot;alice&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不管起接收者的hasOwnProperty方法是否被覆盖，该方法都能工作。&lt;/p&gt;

&lt;p&gt;我们开始创建一个字典类 版本一&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Dict(elements) {
	this.elements = elements || {};
}

Dict.prototype.has = function(key) {
	return {}.hasOwnProperty.call(this.elements, key);
}

Dict.prototype.get = function(key) {
	return this.has(key) ? this.elements[key] : undefined;
}

Dict.prototype.set = function(key, val) {
	this.elements[key] = val;
}

Dict.prototype.remove = function(key) {
	delete this.elements[key];
}

var dict = new Dict({
	alice: 34,
	bob: 24,
	chris: 62
});

dict.has(&quot;alice&quot;);    // true
dict.get(&quot;bob&quot;);      // 24
dict.has(&quot;valueOf&quot;)   //false

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在一些JavaScript的环境中，特殊的属性名__proto__可能导致自身的污染问题__proto__属性只是简单的继承Object.prototype,所以我们的例子会有一个问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dict = new Dict();
dict.has(&quot;__proto__&quot;); // ?

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码在不同的环境下可能会有不同的结果，所以为了达到最大的可移植性和安全性，便有了下面更复杂但是更安全的实现
这里检测到__proto__的可以 重新设置一个新属性作为实例对象的一个属性，随对象而在但是不会去设置对象的__proto__&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Dict(elements) {
	this.elements = elements || {};
	this.hasSpecialProto = false;
	this.specialProto = undefined;
}

Dict.prototype.has = function(key) {
	if(key === &quot;__proto__&quot;) { 
		return this.hasSpecialProto;
	}
	return {}.hasOwnProperty.call(this.elements, key);
}

Dict.prototype.get = function(key) {
	if(key === &quot;__proto__&quot;) { 
		return this.specialProto;
	}
	return this.has(key) ? this.elements[key] : undefined;
}

Dict.prototype.set = function(key, val) {
	if(key === &quot;__proto__&quot;) {
		this.hasSpecialProto = true;

		this.specialProto = val;
	} else {
		this.elements[key] = val;	
	}
	
}

Dict.prototype.remove = function(key) {
	if(key === &quot;__proto__&quot;) {
		this.hasSpecialProto = false;
		this.sepcialProto = undefined;
	} else {
		delete this.elements[key];	
	}
	
}

var dict = new Dict({
	alice: 34,
	bob: 24,
	chris: 62
});

dict.has(&quot;alice&quot;);    // true
dict.get(&quot;bob&quot;);      // 24
dict.has(&quot;valueOf&quot;)   //false

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用数组而不要使用字典来存储有序集合&quot;&gt;使用数组而不要使用字典来存储有序集合&lt;/h2&gt;
&lt;p&gt;JavaScript对象是一个无序集合,ECMAScript标准并未规定属性存储的任何特定顺序，甚至对于枚举对象也未涉及。这将会导致一个问题，&lt;code&gt;for...in&lt;/code&gt;循环会挑选一个特定顺序来枚举对象属性.比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function report(highScores) {
	var result = &quot;&quot;;
	var i = 1;
	for(var name in highScores) {
		result += i + &quot; . &quot; + name + &quot; : &quot; + highScores[name] + '\n';

		i++;
	}

	return result;
}

report([{
		name: &quot;Hank&quot;,
		points: 1110100
	},{
		name: &quot;Steve&quot;,
		points: 1064500
	},{
		name: &quot;Billy&quot;,
		points: 1052000
	}]);

由于不同的环境选择不同的顺序来存储和枚举对象属性，所以这个函数得到顺序混乱的“最高分”报表
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请记住你的程序是否以来对象枚举的顺序并不总是显而易见的，如果没有在多个JavaScript环境中测试过你的程序，你甚至可能不回注意到程序的行为因为一个for…in循环的确切顺序而被改变，对于上面的例子需要使用数组,那么它完全可以工作在任何JavaScript环境中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function report(highScores) {
	var result = &quot;&quot;;
	var i = 1;
	for(var i = 0, n = highScores.length; i &amp;lt; n; i++) {
		var score = hightScores[i];
		result += (i + 1) + &quot; . &quot; + score.name + &quot; : &quot; + score.points + '\n';

		i++;
	}

	return result;
}

report([{
		name: &quot;Hank&quot;,
		points: 1110100
	},{
		name: &quot;Steve&quot;,
		points: 1064500
	},{
		name: &quot;Billy&quot;,
		points: 1052000
	}]);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个微妙的顺序以来的典型例子是浮点运算， 假设一个对象使用&lt;code&gt;for...in&lt;/code&gt; 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ratings = {
	&quot;Good will Hunting&quot;: 0.8,
	&quot;Mystic River&quot;: 0.7,
	&quot;21&quot;: 0.6,
	&quot;Doubt&quot;: 0.9
};

var total = 0, count = 0;
for(var key in. ratings) {
	total += ratings[key];
	count++;
}

total /= count;

total; //?

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实证明，流行的JavaScrtip环境实际上使用不同的顺序执行这个循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一些环境这样计算

(0.8 + 0.7 + 0.6 + 0.9) / 4  // 0.75

还有一些环境先枚举潜在的数组索引，21恰好是一个可行的数组索引，它首先被枚举，导致如下结果

(0.6 + 0.8 + 0.7 + 0.9) / 4  // 0.7499999999999999


更好的表示方法是使用整数值

(8 + 7 + 6 + 9) / 4/ 10.  //0.75

(6 + 8 + 7  + 9) / 4/ 10.  //0.75

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常当执行&lt;code&gt;for...in&lt;/code&gt; 循环时应当时刻小心，确保操作行为与顺序无关。&lt;/p&gt;

&lt;h2 id=&quot;绝不要在objectprototype中增加可枚举属性&quot;&gt;绝不要在Object.prototype中增加可枚举属性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;for...in&lt;/code&gt;非常便利，然而它很容易受到原型污染的影响。目前为止&lt;code&gt;for...in&lt;/code&gt;最常见的用法是枚举字典中的元素。这暗示着如果想允许对字典对象使用&lt;code&gt;for...in&lt;/code&gt;循环，那么不要在共享的Object.prototype中增加可枚举的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.prototype.allKeys = function() {
	var result = [];
	for(var key in this) {
		result.push(key);
	}

	return result;
}

({a: 1, b: 2, c: 3}).allKeys(); // [&quot;allkeys&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]  该方法污染了自身

更友好的做法是将allkeys定义为一个函数而不是方法，虽然着稍微有点不方便

function allKeys(obj) {
	var result = [];
	for(var key in obj) {
		result.push(key);
	}

	return result;
}



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你确实想在Object.prototype中增加属性， ES5提供了一个更加友好的机制Object.defineProperty&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;方法可以定义一个对象的属性并制定该属性的元数据。例如，我们可以用与之前完全一样的方法定义上面的属性而通过设置其可枚举属性为false使其在&lt;code&gt;for...in&lt;/code&gt;循环中不可见。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Object.defineProperty(Object.prototype, &quot;allKeys&quot;, {
	value: function() {
		var result = [];
		for(var key in this) {
			result.push(key);
		}
		return result;
	},
	writable: true,
	enumerable: false,
	configurable: true
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它不会污染其他所有&lt;code&gt;Object&lt;/code&gt;实例的所有&lt;code&gt;for...in&lt;/code&gt;循环。每当你需要增加一个不应该出现在&lt;code&gt;for...in&lt;/code&gt;循环中出现的属性时，Object.defineProperty便是你的选择&lt;/p&gt;

&lt;h2 id=&quot;避免在枚举期间修改对象&quot;&gt;避免在枚举期间修改对象&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function Member(name) {
	this.name = name;
	this.friends = [];
}

var a = new Member(&quot;Alice&quot;),
	b = new Member(&quot;Bob&quot;),
	c = new Member(&quot;Carol&quot;),
	d = new Member(&quot;Dieter&quot;),
	e = new Member(&quot;Eli&quot;),
	f = new Member(&quot;Fatima&quot;);

a.friends.push(b);
b.friends.push(c);
c.friends.push(e);
d.friends.push(b);
e.friends.push(d,f);

如果我们写了一个方法 在for...in的时候操作对象比如，删除或添加， 在许多JavaScript环境中这段代码根本不能工作。

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;ECMAScript规定了，如果被枚举的对象在枚举期间添加了新的属性，那么在枚举期间并不能保证新添加的属性能够被访问。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个隐式的规范的实际后果是： 如果我们修改了被枚举的对象则不能保证&lt;code&gt;for...in&lt;/code&gt;循环行为的可预见性。&lt;/p&gt;

&lt;p&gt;我们可以新建一个WorkSet类来追踪当前集合中元素的数量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function WorkSet() {
	this.entries = new Dict();
	this.count = 0;
}

WorkSet.prototype.isEmpty = function() {
	return this.count === 0;
}

WorkSet.prototype.add = function(key, val) {
	if(this.entries.has(key)) {
		return;
	}

	this.entries.set(key, val);
	this.count++;
}

WorkSet.prototype.get = function(key) {
	return this.entries.get(key);
}

WorkSet.prototype.remove = function(key) {
	if(!this.entries.had(key)) {
		return;
	}

	this.entries.remove(key);
	this.count--;
}

WorkSet.prototype.pick = function() {
	return this.entries.pick();
}

//这里同时需要给Dict类增加一个pick方法

Dick.prototype.pick = function() {
	for(var key in this.elements) {
		if(this.has(key)) {
			return key;
		}
	}

	throw new Error(&quot;empty dictionary&quot;);
}

// 现在我们可以实现一个inNetwork的方法
到最后发现这段代码没什么卵用
Member.prototype.inNetwork = function(other) {
	var visited = {};
	var workset = new WorkSet();
	workset.add(this.name, this);

	while(!workset.isEmpty()) {
		var name = = workset.pick();
		var member = workset.get(name);
		workset.remove(name);
		if(name in visited) {
			continue;
		}

		visited[name] = member;

		if(member === other) {
			return true;
		}

		member.friends.forEach(function(friend) {
			workset.add(friend.name, friend);
		})
	}

	return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上pick方法是一个不确定性的例子， 不确定性指的是一个操作不能保证使用语言的语意产生一个单一的可预见的结果。这个不确定性来源于这样一个事实，for…in循环可能在不同的JavaScript环境中选择不同的枚举顺序。
基于这些原因，考虑使用一个确定的工作集算法替代方案是值得的。集工作列表算法Work-list.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用for…in循环枚举一个对象属性时，确保不要修改该对象&lt;/li&gt;
  &lt;li&gt;当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环代替for…in循环&lt;/li&gt;
  &lt;li&gt;为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数组迭代优先使用for循环而不是forin&quot;&gt;数组迭代优先使用&lt;code&gt;for&lt;/code&gt;循环而不是&lt;code&gt;for...in&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;看下面代码mean的输出值时多少？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var scores = [98, 74, 85, 77, 93, 100, 89];

var total = 0;

for(score in scores) {
	total += score;
}

var mean = total / socres.length;

 mean; // ?  17636.571428571428


 请记住即使是数组的索引属性，对象属性的key始终是字符串

 total = 0 + &quot;0&quot; + &quot;1&quot; + &quot;2&quot; + &quot;3&quot; + &quot;4&quot; + &quot;5&quot; + &quot;6&quot;;

 total = &quot;00123456&quot;;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;迭代数组内容的正确方式是使用传统的for循环, 建议存储数组长度到一个局部变量中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var scores = [98, 74, 85, 77, 93, 100, 89];
var total = 0;

for(var i = 0, n = scores.length; i &amp;lt; n; i++) {
	total += socres[i];
}

var mean = toal / scores.length;

mean; // 88

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;迭代方法由于循环&quot;&gt;迭代方法由于循环&lt;/h2&gt;
&lt;p&gt;一些常见的for循环错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(var i = 0; i &amp;lt;= n; i++) {...}. // 获取最后一项错误

for(var i = 1; i &amp;lt; n; i++) {...}. // 丢失第一项

for(var i = n; i &amp;gt;= 0 ; i--) {...}. // 获取起始值错误

for(var i = n - 1; i &amp;gt; 0 ; i--) {...}. // 丢失最后一项

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们面对这样一个事实，搞清楚终止条件是一个累赘。
幸运的是ES5提供了一些便利的方法。Array.prototype.forEach是其中最简单的一个。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(var i = 0, n = players.length; i &amp;lt; n; i++) {
	players[i].score++;
}
可以用下面代码替换
players.forEach(function(p) {
	p.socre++;
})	

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码不仅更简单可读而且消除了终止条件和任何数组索引。&lt;/p&gt;

&lt;p&gt;另一个例子是对数组进行操作后建立一个新的数组我们可以这样实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var trimmed = [];
for(var i = 0, n = input.lenght; i &amp;lt; n; i++) {
	trimmed.push(input[i].trim());
}

我们同样可以使用forEach来实现

var trimmed = [];
input.forEach(function(s) {
	trimmed.push(s.trim());
});


因为这是一个十分普遍的操作，所以ES5提供了一个更简单优雅的实现Array.prototype.map

var trimmed = input.map(function(s) {
	return s.trim();	
})


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一种常见的模式是计算一个新的数组，该数组只包含现有数组的一部分元素.&lt;code&gt;Array.prototype.filter&lt;/code&gt;使其变得简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
listings.filter(function(listing) {
	return listing.price &amp;gt;= min &amp;amp;&amp;amp; listing.price &amp;lt;= max;
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些都是ES5的默认方法，我们当然可以实现自己的方法，比如我们需要这样一个模式，提取满足谓词的数组的前几个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function takeWhile(a, pred) {
	var result = [];
	for(var i = 0, n = a.length; i &amp;lt; n; i++) {
		if(!pred(a[i], i)) {
			break;
		}
		result[i] = a[i];
	}

	return result;
}

var prefix = taleWhile([1, 2, 4, 8, 16, 32], function(n) {
	return n &amp;lt; 10;
});

// [1, 2, 4, 8]


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意我们将索引i赋值给了pred, 我们可以选择使用或忽略该索引。事实上标准库中的所有迭代方法包括(forEach, map, filter)都将数组索引传递给了用户自定义函数。&lt;/p&gt;

&lt;p&gt;我们也可以将takeWhile加入到Array.prototype中参考猴子补丁的影响&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Array.prototype.takeWhile = function(pred) {
	var result = [];
	for(var i = 0, n = this.length; i &amp;lt; n; i++) {
		if(!pred(this[i], i)) {
			break;
		}

		result[i] = this[i];
	}

	return result;
}

var prefix = [1, 2, 4, 8, 16, 32].takeWhile(function(n) {
	return n &amp;lt; 10;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;循环只有一点优于迭代函数，那就是前者有控制流操作，如break 和continue。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举例来说&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function takeWhile(a, pred) {
	var result = [];
	a.forEach(function(x, i) {
		if(!pred(x)) {
			// ?
		}
		result[i] = x;
	});

	return result;
}

我们可以使用一个内部异常来提前终止该循环，但是这既尴尬又效率低下

function takeWhile(a, pred) {
	var result = [];
	var earlyExit = [];
	try {
		a.forEach(function(x, i) {
			if(!pred(x)) {
				throw earlyExit;
			}

			result[i] = x;
		});
	} catch(e) {
		if(e !== earlyExit) {
			throw e;
		}
	}

	return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES5的数组方法some和every可以用于提前终止循环。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 10, 100].some(function(x) {.return x &amp;gt; 5; });  // true
[1, 10, 100].some(function(x) {.return x &amp;lt; 0; });  // false

[1, 10, 100].every(function(x) {.return x &amp;gt; 0; });  // true
[1, 10, 100].every(function(x) {.return x &amp;lt; 3; });  // true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用这一点我们可以重新实现takeWhile方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
function takeWhile(a, pred) {
	var result = [];

	a.every(function(x, i) {
		if(!pred(x)) {
			return false; // break
		}

		result[i] = x;
		return true;  // continue
	});

	return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用迭代方法 forEach 和map替换for循环使得代码更可读，并且避免了重复循环控制逻辑&lt;/li&gt;
  &lt;li&gt;使用自定义的迭代函数来抽象未被标准库支持的常见循环模式&lt;/li&gt;
  &lt;li&gt;在需要提前终止循环的情况下， 仍然推荐使用传统的循环。另外，some和every方法也可用于提前退出&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;在类数组对象上复用通用的数组方法&quot;&gt;在类数组对象上复用通用的数组方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Array.prototype&lt;/code&gt;中的标准方法被设计成其他对象可复用的方法，即使这些对象并没有继承Array,一个很好的例子 函数的arguments对象，它并没有继承Array.prototype，因此我们不能简单的调用arguments.forEach方法来遍历每一个参数。取而代之我们提取forEach方法对象的引用并使用其call方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 同样也可先转化为一个数组 var args = [].slice.call(arguments);

function highlight() {
	[].forEach.call(arguments, function(widget) {
		widget.setBackground(&quot;yellow&quot;);
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何使一个对象“看起来像数组”，数组对象的基本契约总共有两个简单规则&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;具有一个范围在0-2^32-1的整型length属性。&lt;/li&gt;
  &lt;li&gt;length属性大于该对象的最大索引。索引的范围是0-2^32-2的整数，它的字符串表示就是该对象的一个key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arrayLike = {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3}
var result = Array.prototype.map.call(arrayLike, function(s) {
	return s.toUpperCase();
});

// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串也表现为不可变的数组，因为它们是可索引的， 并且其长度也可以通过length属性获取。因此，Array.prototype中的方法操作字符串不回修改原始数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var result = Array.prototype.map.call(&quot;abc&quot;, function(s) {
	return s.toUpperCase();	
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于使用Array.prototype中的方法，在增加或删除索引属性的时候它们都会强制的更新length属性。所有的Array.prototype方法在类数组中可以通用。&lt;/p&gt;

&lt;p&gt;只有一个Array方法不是通用的那就是数组连接方法concat。该方法可以由任意的类数组调用但是它会检查其参数的[[Class]]属性，如果是一个真实的数组才会连接，如果不是例子如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function nameColum() {
	return [&quot;Names&quot;].concat(arguments);
}

namesColumn(&quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;);


// [&quot;Names&quot;, {.0: &quot;Alice&quot;, 1: &quot;Bob&quot;, 2: &quot;Chris&quot; }]

这种时候我们可以使用数组转换的方法
function nameColum() {
	return [&quot;Names&quot;].concat([].slice.call(arguments));
}

namesColumn(&quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;);

// [&quot;Names&quot;, &quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;数组字面量优于数组构造函数&quot;&gt;数组字面量优于数组构造函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var a = [1, 2, 3, 4, 5];

也可以使用数组构造函数来替代

var a = new Array(1, 2, 3, 4, 5);


有这样几个问题
首先要保证没有人重新包装过Array变量
function f(Array) {
	return new Array(1, 2, 3, 4, 5);
}

f(String);  //  new String(1)

其次要确保没人修改过全局Array变量

Array = String;
new Array(1, 2, 3, 4, 5); // new String(1)



还有一个问题 

[&quot;hello&quot;] 和 new Array(&quot;hello&quot;) 行为虽然一致

但是

[17] 和 new Array(17) 行为完全不同了

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用数组字面量替代数组构造函数&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">使用Object的直接实例构造轻量级的字典</summary></entry></feed>