<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-06-27T15:16:05+08:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">Effective JavaScript (四)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four/" rel="alternate" type="text/html" title="Effective JavaScript (四)" /><published>2018-06-27T00:00:00+08:00</published><updated>2018-06-27T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four/">&lt;h2 id=&quot;了解分号插入的局限性&quot;&gt;了解分号插入的局限性&lt;/h2&gt;

&lt;p&gt;JavaScript的一个便利是能够离开 语句结束分号 工作。 删除分号后，结果变得轻量而优雅，比如下面这个例子去掉所有分号，JavaScript会自动插入分号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  function Point(x, y) {
    this.x = x || 0
    this.y = y || 0
  }

  Point.prototype.isOrigin = function() {
    return this.x === 0 &amp;amp;&amp;amp; this.y === 0
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段没有分号的代码能够工作依赖于JavaScript的&lt;code&gt;自动分号插入技术(automatic semicolon insertion)&lt;/code&gt;, 它是一种程序解析技术。它能够推断出上下文省略的分号，然后有效的将分号自动插入到程序中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;像隐式的强制转换一样，分号插入也有其陷阱，你根本不能避免学习其规则， 即使你从来不省略分号，受分号插入的影响，JavaScript语法也有一些额外的限制。一旦学会分号插入机制，你会从删除不必要的分号的痛苦中解脱出来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;规则一&quot;&gt;规则一&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;分号仅在 } 标记之前、一个或多个换行之后和程序输入的结尾被插入。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  //合法省略分号
  function square(x) {
    var n = +x
    return n * n
  }

  function area(r) { r = +r; return Math.PI * r * r }

  function add1(x) { return x + 1 }

  // 不合法
  function area(r) { r = +r return Math.PI * r * r }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;规则二&quot;&gt;规则二&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;分号进在随后的输入标记不能被解析时插入
换句话说分号插入是一种错误矫正机制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascipt&quot;&gt;  a = b
  (f()); // 这个例子会被解析为 a = b(f()); 所以不会插入分号，因为能够正确解析

  a = b
  f();   // 这个例子会被解析为 a = b f(); 解析有误，所以会插入分号
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;有5个明确有问题的字符需要密切注意&quot;&gt;有5个明确有问题的字符需要密切注意&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(、[、+、-和/&lt;/strong&gt;， 每一个字符都能作为一个表达式运算符或一条语句的前缀， 这依赖于具体上下文。，如果下一行以这五个有问题的字符串之一来时，则不会自动插入分号。向上面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  [&quot;r&quot;, &quot;g&quot;, &quot;b&quot;].forEach(function(key) {
    background[key] = foreground[key] / 2;
  });
  // 这看起来像两条语句但是使用了&amp;lt;code&amp;gt;[&amp;lt;/code&amp;gt;，所以被解析为一条语句
  // 这里例子看起来有点奇怪，但是，JavaScript允许逗号分隔表达式。
  // 逗号分隔表达式从左至右依次执行，并返回最后一个表达式的值。
  a = b[&quot;r&quot;, &quot;g&quot;, &quot;b&quot;].forEach(function(key) {
    background[key] = foreground[key] / 2;
  });

  // /通常作为正则表达式的开始
  /Error/i.test(str) &amp;amp;&amp;amp; fail();

  //这种情况会被解析到一行不会插入分号
  a = b
  /Error/i.test(str) &amp;amp;&amp;amp; fail();

  a = b/Error/i.test(str) &amp;amp;&amp;amp; fail();  //  / 解析为除法运算符


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又一个例子,这是一个完全正确的例子，因为会自动插入分号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  var x
  (f())

  // 但是如果重构时被意外的修改过如下，第二个分号不会插入, 会被错误的解析为 a = b(f())
  var x
  a = b
  (f())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个不幸的结果就是，你总是需要注意省略的分号， 并且检查接下来的一行开始的标记是否会禁用自动插入分号。所以你可以采用在&lt;strong&gt;(、[、+、-和/&lt;/strong&gt;，字符的开始前置一个额外的分号语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  var x
  ;(f())

  // 但是如果重构时被意外的修改过如下，第二个分号不会插入, 会被错误的解析为 a = b(f())
  var x
  a = b
  ;(f())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个常用的情况就是脚本连接的情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // file1.js
  (function() {

  })()

  // file2.js
  (function() {

  })()

  // 当文件连接到一起时
  (function() {

  })()
  (function() {

  })()

  // 被视为一条单一的语句，等价于：

  (function() {

  })()(function() {

  })();

  // 所以如果文件最开始的语句以这5个字符开始，你应该防御性的给每个前缀一个额外的分号

  // file1.js
  ;(function() {

  })()

  // file2.js
  ;(function() {

  })()

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;最安全的选择就是防御性的增加分号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可能认为 “我从来不省略分号，我会没事的。” 事实并不是这样。也有一些情况，尽管不会出现解析错误，但是也会强制性的插入分号，
这是所谓的JavaScript的语法限制式（restricted production），它不允许两个字符之间存在换行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  return {};    // 返回一个对象

  return  // 这段代码被解析为
  {};

  return;
  {}
  ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的JavaScript的语法限制产生式包括： return, throw, break, continue, 后置自增或自减运算符。
在&lt;code&gt;return, throw, break, continue, ++, --&lt;/code&gt;,参数之前决不能出现换行&lt;/p&gt;

&lt;p&gt;关于自增和自减运算符 是为了避免以下代码出现的歧义，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a
  ++
  b
  // ++既可以作为前置也可以作为后置，但是后置根据语法限制式,不允许a++之间存在换行 所以上面代码解析为

  a; ++b;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;第三条也是最后一条规则&quot;&gt;第三条也是最后一条规则&lt;/h2&gt;
&lt;p&gt;分号不会作为分隔符在for循环空语句头部被自动插入，换言之，for头部里面的&lt;code&gt;;&lt;/code&gt;不能省略，必须显示的包含分号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 下面代码会解析错误
  for(var i = 0, total = 1 // parse error
      i &amp;lt; n
      i++) {
    total *= i
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的 &lt;code&gt;while&lt;/code&gt;，也是需要显示分号的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  function infiniteLoop() { while(true) }  // parse error

  function infiniteLoop() { while(true); }
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">了解分号插入的局限性</summary></entry><entry><title type="html">Effective JavaScript (三)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three/" rel="alternate" type="text/html" title="Effective JavaScript (三)" /><published>2018-06-22T00:00:00+08:00</published><updated>2018-06-22T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three/">&lt;h2 id=&quot;当心隐式的强制转换&quot;&gt;当心隐式的强制转换&lt;/h2&gt;

&lt;p&gt;JavaScript对类型的错误出奇宽容,算数运算符 - 、*、%、/都会把参数转为数字。然而 + 会根据参数来决定
位运算符不仅会将操作数转换为数字，而且还会将操作数转换为32位整数(表示数字的子集)。这些运算符包括算术运算符(~ 、&amp;amp; 、^ 、| 、«、»、»&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  3 + true; // 4
  2 + 3;    // 5
  &quot;2&quot; + 3;  // 23
  &quot;17&quot; * 3; // 51
  &quot;8&quot; | &quot;1&quot; // 9
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;注意nan&quot;&gt;注意NaN&lt;/h2&gt;
&lt;p&gt;NaN不等于其自身，所以测试一个值是否是NaN是行不通的 ，标准库里面的isNaN也是不可靠的，因为它也带有隐式的强制转换，尝试将参数转为数字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var x = NaN;
  x === NaN;  // false

  isNaN(NaN); // true

  // 由于隐式的类型转换所以以下 都会返回true
  isNaN(&quot;foo&quot;);
  isNaN(undefined);
  isNaN({});
  isNaN({ valueOf: &quot;foo&quot; });

  // 由于NaN是不等于其自身的，所以真正正确判断一个参数是否是NaN的方法是判断是否等于自身
  function isReallyNaN(x) {
    return x !== x;
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;对象的隐式转换&quot;&gt;对象的隐式转换&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // 对象转换成字符串
  &quot;the Math object: &quot; + Math; // &quot;the Math object: [object Math]&quot;
  &quot;the JSON object: &quot; + JSON; // &quot;the JSON object: [object JSON]&quot;

  // 对象转换成数字， 对象可以通过valueOf 方法转为数字,你可以控制对象的类型转换

  // 这里讲调用对象的toString 进行拼接
  &quot;J&quot; + { toString: function() { return &quot;S&quot;; } };  // &quot;JS&quot;

  // 通过valueOf将对象转为数字
  2 * { valueOf: function() { return 3; } };       // 6

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个对象同时有toString 和valueOf方法 ，运算符 + 应该调用哪个方法呢，JavaScript通过盲目的选择valueOf方法而不是toString方法来解决这种含糊的情况，这就意味着如果有人打算对一个对象执行字符串连接操作，那么产生的行为会出乎意料&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var obj = {
    toString: function() {
      return &quot;[object MyObject]&quot;;
    },
    valueOf: function() {
      return 17;
    }
  }

  &quot;object: &quot; + obj; // &quot;object: 17&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;这里例子说明，valueOf方法才真正是为那些代表数值的对象(如 Number对象)而设计的。对于这些对象toString 和valueOf方法应返回一致的结果。一般情况下，字符串的强制转换远比数字转换更常见、更有用。 最好避免使用valueOf方法，除非对象的确是一个数字的抽象，并且obj.toString()能产生一个obj.valueOf() 的字符串表示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;真值运算&quot;&gt;真值运算&lt;/h2&gt;
&lt;p&gt;if、||、&amp;amp;&amp;amp;等运算符逻辑上需要布尔值作为操作参数，但实际上可以接受任何值。JavaScript会按照简单的隐式强制转换规则将值解释为布尔值。&lt;/p&gt;

&lt;p&gt;false, 0, -0,””, NaN,null, undefined 外的所有值会转换为false， 其他所有值都为真值。&lt;/p&gt;

&lt;p&gt;因为数字0和字符串”“会转换为false,因此通过隐式转换来判断一个值是否已经定义是不准确的需要通过判断，应该通过以下方式来进行判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  if(typeof x === 'undefined') {}
  if(x === undefined) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;原始类型优于封装对象&quot;&gt;原始类型优于封装对象&lt;/h2&gt;
&lt;p&gt;除了对象之外，JavaScript有5个原始值类型： 布尔值，数字，字符串，null, undefined;
以String为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var s = new String('hello');

  s + &quot;world&quot;;  // &quot;hello world&quot;

  s[4]          // &quot;o&quot;

  typeof &quot;hello&quot; // &quot;string&quot;

  typeof s        // &quot;Object&quot;

  // 每个string都是一个单独的对象其总等于自身，对于非严格相等运算符，结果相同
  var s1 = new String(&quot;hello&quot;);

  var s2 = new String(&quot;hello&quot;);

  s1 === s2; // false

  s1 == s2 // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些封装的行为并不十分正确所以&lt;code&gt;用处不大&lt;/code&gt; ， 其存在的理由是他们的使用方法。例如
隐式封装后会有一个奇怪的结果，你可以对原始类型的值设置属性，但是对其没有丝毫影响.
每次隐式的封装都会产生一个新的String对象 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 每次写这个相当于声明了一个新的对象，更新第一个对象的someProperty不会对第二个对象产生影响&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&quot;hello&quot;.toUpperCase();  // HELLO



  &quot;hello&quot;.someProperty = 17;

  &quot;hello&quot;.someProperty; // undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;避免对混合类型使用运算符&quot;&gt;避免对混合类型使用==运算符&lt;/h2&gt;

&lt;p&gt;下面的表达式的值其实是true， 对于看似无关的值使用==实际是相等的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &quot;1.0e0&quot; == { valueOf: function() { return true } }    // true

  // 理由如下
  Number(&quot;1.0e0&quot;)   // 转换为数字 1

  // 对象调用 valueOf方法返回true， 再转换为数字，得到1

  // 所以结果相等

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用隐式的强制转换做一些事情，但是仍然推荐使用严格模式进行比较。&lt;/p&gt;

&lt;p&gt;例子一, 这个例子使用了隐式的类型转换，跟数字进行比较会将字符串转为数字，从而得到正确的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(form.month.value == (today.getMonth() + 1) &amp;amp;&amp;amp;
    form.day.value == today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子二， 这个例子使用了显示的 Number，或者一元运算符 + 将字符串转为数字, 从而清晰的向大家表达了代码到底在做什么样的转换， 不要求读者记住这些转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(+form.month.value == (today.getMonth() + 1) &amp;amp;&amp;amp;
   +form.day.value == today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子三， 一个更好的例子 使用严格相等运算， 这个过程没有涉及任何转换，读者读起来更加清晰，否则读者需要记住这些强制转换来解读代码的行为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(+form.month.value === (today.getMonth() + 1) &amp;amp;&amp;amp;
    +form.day.value === today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-运算符强制转换规则&quot;&gt;== 运算符强制转换规则&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数类型1&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;参数类型2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;参数类型3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;null&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不转换，总是返回true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;null或undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;其他任何非null或undefined的类型&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不转换，总是返回false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Date对象&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字，将Date对象转换为原始类型（优先尝试toString方法，再尝试valueOf方法）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;非Date对象&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字，将非Date对象转换为原始类型（优先尝试valueOf方法，再尝试toString方法）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">当心隐式的强制转换</summary></entry><entry><title type="html">Effective JavaScript (二)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/21/read-book-effective-two/" rel="alternate" type="text/html" title="Effective JavaScript (二)" /><published>2018-06-21T00:00:00+08:00</published><updated>2018-06-21T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/21/read-book-effective-two</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/21/read-book-effective-two/">&lt;h2 id=&quot;理解javascript的浮点数&quot;&gt;理解JavaScript的浮点数&lt;/h2&gt;

&lt;p&gt;大多数编程语言都有多种数据类型，但是Javascript 却只有一种。使用 &lt;code&gt;typeof&lt;/code&gt; 运算符查看无论是 ，整数还是浮点数JavaScript都简单的返回一个结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; typeof 17; // number
 typeof 98.6; // number
 typeof -2.1; // number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上JavaScript中所有的数字都是双精度浮点数。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这是由IEEE 745标准定制的64位编码数字 —即 “doubles”； JavaScript使用双精度浮点数来完美的表达高到53位精度的整数，-2^53次方到2^53次方的所有整数都是有效的双精度浮点数。因此尽管JavaScript中缺少明显的整数类型，但是完全可以进行整数运算。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;位运算比较特殊JavaScript不会直接将操作数作为浮点数进行运算，而是会将其隐式的转换为32位整数后进行运算。以按位或为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;  8 | 1

  00000000000000000000000000001000

  00000000000000000000000000000001

  00000000000000000000000000001001

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将8 和1分别转为32位的二进制序列然后进行运算， 所有的位运算符的工作方式是相同的。他们先将操作数转换为整数，然后使用整数位模式进行运算，最后将结果转换为标准的JavaScript浮点数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;浮点数的运算需要时刻保持警惕，因为它们出了明的不精确，甚至一些看起来最简单的算术运算都会产生不正确的结果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; 0.1 + 0.2;  // 0.30000000000000004
 // 实数满足结合律 即实数 x, y, z 总是满足 (x + y) + z = x + (y + z); 但是对于浮点数来说却不总是这样

  (0.1 + 0.2) + 0.3  // 0.6000000000000001

  0.1 + (0.2 + 0.3) // 0.6

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;浮点数权衡了精度和性能。当我们关心精度时，要小心浮点数的局限性。一个有效的解决方法是尽可能采用整数值运算，因为整数在表示时不需要舍入。只需要担心范围符合 -2^53 到 2^53的整数&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">理解JavaScript的浮点数</summary></entry><entry><title type="html">Effective JavaScript(一)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/19/read-book-effective-one/" rel="alternate" type="text/html" title="Effective JavaScript(一)" /><published>2018-06-19T00:00:00+08:00</published><updated>2018-06-19T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/19/read-book-effective-one</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/19/read-book-effective-one/">&lt;h2 id=&quot;了解你使用的javascript版本&quot;&gt;了解你使用的JavaScript版本&lt;/h2&gt;

&lt;p&gt;由于不同的浏览器，对于JS的实现不同，我们必须精心编写代码保证他们在所有浏览器下工作如一。否则你可能面临这样的困境–应用程序在你自己的计算机上运行良好，但是部署到不同的环境时却无法运行。
例如，const关键字在支持非标准特性的JavaScript引擎上测试时运行良好，但是当将它部署到不识别const关键字的web浏览器上就会出现语法错误。
为此，ES5引入了一种版本控制的考量&lt;code&gt;严格模式&lt;/code&gt;。此特性允许你选择在受限制的JavaScript版本中禁止使用一些JavaScript语言中问题较多或者易于出错的特性。
由于其语法设计向后兼容，因此即使在那些没有实现严格模式检查的环境中仍然可以执行严格代码（strict code）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&quot;use strict&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该指令只有定义到脚本或函数的顶部才能生效。需要注意的是脚本连接时可能会将非严格模式脚本运行到严格模式下如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&quot;use strict&quot;;
function f() {}

// no strict-mode
function g() {
  var arguments = [];
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种情况会报错，为了解决这个问题，我们通常会使用 立即调用的函数表达式(IIFE Immediately Invoked Function Expression) 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function(){
  &quot;use strict&quot;;
  function f() {}
})();

(function(){
  function g() {
    var arguments = [];
  }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;编写文件使其在两种模式下行为一致&quot;&gt;编写文件使其在两种模式下行为一致&lt;/h2&gt;
&lt;p&gt;想要编写一个库来获得最大的兼容性最简单的方法就是在严格模式下编写代码，并显示的将代码内容包裹在本地启用了严格模式的函数中，这种类似前面所说的 将库文件包裹到一个立即调用的函数表达式中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; (function(){
  &quot;use strict&quot;
  function g() {
    var arguments = [];
  }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;为了达到更普遍的兼容性建议在严格模式下编写代码。&lt;/code&gt;&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">了解你使用的JavaScript版本</summary></entry><entry><title type="html">React初步学习</title><link href="/reactjs/2018/06/19/react-lesson-one/" rel="alternate" type="text/html" title="React初步学习" /><published>2018-06-19T00:00:00+08:00</published><updated>2018-06-19T00:00:00+08:00</updated><id>/reactjs/2018/06/19/react-lesson-one</id><content type="html" xml:base="/reactjs/2018/06/19/react-lesson-one/">&lt;h1 id=&quot;react&quot;&gt;React&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.react-china.org/docs/handling-events.html&quot;&gt;react中文文档&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;事件处理&quot;&gt;事件处理&lt;/h1&gt;
&lt;p&gt;你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。
这并不是 React 的特殊行为；它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // This binding is necessary to make `this` work in the callback
    this.handleClick1 = this.handleClick1.bind(this);
  }
    //推荐方法一
  handleClick1() {
    this.setState(prevState =&amp;gt; ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  //推荐方法二
   handleClick2 = () =&amp;gt; {
    console.log('this is:', this);
  }


  render() {
    return (
      &amp;lt;button onClick={this.handleClick1}&amp;gt;
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      &amp;lt;/button&amp;gt;
       &amp;lt;button onClick={this.handleClick2}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
      &amp;lt;!-- 方法三不推荐 --&amp;gt;
      &amp;lt;button onClick={(e) =&amp;gt; this.handleClick3(e)}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    );
  }
}

ReactDOM.render(
  &amp;lt;Toggle /&amp;gt;,
  document.getElementById('root')
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;方法三不推荐的原因&quot;&gt;方法三不推荐的原因：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;使用这个语法有个问题就是每次 LoggingButton 渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。我们通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。
在render方法中使用Function.prototype.bind会在每次组件渲染时创建一个新的函数，可能会影响性能（参见下文）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;向事件处理程序传递参数&quot;&gt;向事件处理程序传递参数&lt;/h3&gt;
&lt;p&gt;通常我们会为事件处理程序传递额外的参数。例如，若是 id 是你要删除那一行的 id，以下两种方式都可以向事件处理程序传递参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;button onClick={(e) =&amp;gt; this.deleteRow(id, e)}&amp;gt;Delete Row&amp;lt;/button&amp;gt;
&amp;lt;button onClick={this.deleteRow.bind(this, id)}&amp;gt;Delete Row&amp;lt;/button&amp;gt;


class Popper extends React.Component{
    constructor(){
        super();
        this.state = {name:'Hello world!'};
    }

    preventPop(name, e){    //事件对象e要放在最后
        e.preventDefault();
        alert(name);
    }

    render(){
        return (
            &amp;lt;div&amp;gt;
                &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;
                {/* Pass params via bind() method. */}
                &amp;lt;a href=&quot;https://reactjs.org&quot; onClick={this.preventPop.bind(this,this.state.name)}&amp;gt;Click&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="reactjs" /><summary type="html">React react中文文档</summary></entry><entry><title type="html">vim快捷键和配置</title><link href="/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2018/03/15/vim-config/" rel="alternate" type="text/html" title="vim快捷键和配置" /><published>2018-03-15T00:00:00+08:00</published><updated>2018-03-15T00:00:00+08:00</updated><id>/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2018/03/15/vim-config</id><content type="html" xml:base="/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2018/03/15/vim-config/">&lt;h3 id=&quot;vim快捷键和配置&quot;&gt;vim快捷键和配置&lt;/h3&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/SpaceVim/SpaceVim&quot;&gt;SpaceVim&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://vim-bootstrap.com/&quot;&gt;vim-bootstrap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="生产工具" /><category term="Vim" /><category term="IDE" /><summary type="html">vim快捷键和配置</summary></entry><entry><title type="html">使用electron进行桌面开发笔记</title><link href="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2018/03/15/electron-develop-step1/" rel="alternate" type="text/html" title="使用electron进行桌面开发笔记" /><published>2018-03-15T00:00:00+08:00</published><updated>2018-03-15T00:00:00+08:00</updated><id>/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2018/03/15/electron-develop-step1</id><content type="html" xml:base="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2018/03/15/electron-develop-step1/">&lt;h3 id=&quot;使用electron进行桌面开发笔记&quot;&gt;使用electron进行桌面开发笔记&lt;/h3&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wizardforcel.gitbooks.io/electron-doc/content/tutorial/devtools-extension.html&quot;&gt;electron文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="Nodejs" /><category term="javascript" /><summary type="html">使用electron进行桌面开发笔记</summary></entry><entry><title type="html">Css布局研究之Flex布局总结（一）</title><link href="/css/2017/12/25/css-layout/" rel="alternate" type="text/html" title="Css布局研究之Flex布局总结（一）" /><published>2017-12-25T00:00:00+08:00</published><updated>2017-12-25T00:00:00+08:00</updated><id>/css/2017/12/25/css-layout</id><content type="html" xml:base="/css/2017/12/25/css-layout/">&lt;h2 id=&quot;flex布局&quot;&gt;Flex布局&lt;/h2&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-examples.html&quot;&gt;Flex 布局教程：实例篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="Flex - Css布局" /><summary type="html">Flex布局</summary></entry><entry><title type="html">初涉Android</title><link href="/android/2017/12/20/android-start/" rel="alternate" type="text/html" title="初涉Android" /><published>2017-12-20T00:00:00+08:00</published><updated>2017-12-20T00:00:00+08:00</updated><id>/android/2017/12/20/android-start</id><content type="html" xml:base="/android/2017/12/20/android-start/">&lt;h2 id=&quot;android环境安装&quot;&gt;Android环境安装&lt;/h2&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.androiddevtools.cn/&quot;&gt;AndroidDevTools&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="Android" /><summary type="html">Android环境安装</summary></entry><entry><title type="html">高性能网站建设指南</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2017/12/20/read-book-web/" rel="alternate" type="text/html" title="高性能网站建设指南" /><published>2017-12-20T00:00:00+08:00</published><updated>2017-12-20T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2017/12/20/read-book-web</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2017/12/20/read-book-web/">&lt;h1 id=&quot;高性能网站建设指南-前端工程师技能精髓&quot;&gt;高性能网站建设指南-前端工程师技能精髓&lt;/h1&gt;

&lt;h2 id=&quot;减少http请求&quot;&gt;减少HTTP请求&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;性能黄金法则&lt;/code&gt;提示了只有10%~20%响应时间花在了HTML文档上其他都用在了加载各种组件包括（图片，样式表，脚本，falsh）进行的HTTP请求上。因此改善响应时间的最简单途径就是减少组件数量，并由此减少请求数量&lt;/p&gt;

&lt;p&gt;可以以下通过方式&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;CSS Sprites&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;内联图片 data:URL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;合并脚本和样式表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;data:URL模式首次在1995年被提议其格式如下 :&lt;code&gt;data:mediatype;base64,data&lt;/code&gt;
其他类似的模式还有
 ftp:，file:， mailto:， smtp:， pop:， dns:， whois:， finger:， daytime:，news: ， run:
需要注意的是内联图片不被IE支持，而且增加了文档的大小如果存在于HTML当中首次下载的文档大小会变大，鉴于此可以将内联图片放到css当中这样可以让图片可以被缓存而且这样减少了一个图片的http请求。&lt;/p&gt;

&lt;h2 id=&quot;使用内容发布网络cdn&quot;&gt;使用内容发布网络CDN&lt;/h2&gt;
&lt;p&gt;合理使用cdn会很大程度增加网站响应速度而且价格不贵，比如本站使用的又拍云（非广告），即使被DDOS了也花不了多少&lt;/p&gt;

&lt;h2 id=&quot;添加expires头&quot;&gt;添加Expires头&lt;/h2&gt;
&lt;p&gt;通过设置一个长久有效的Expires头可以使web组件被缓存。web服务器通过Expires头来告诉Web客户端它可以使用一个组件的当前副本直到制定的时间为止。
但是由于Expires是一个特定时间，它要求服务器跟客户端始终严格同步（通常很难保证），所以需要跟Cache-Control: max-age=31500000 配合使用该项配置告诉客户端该组件过多长时间才会失效而不是到某一个时间失效。
如果两者同时出现max-age指令会覆盖Expires头。
比较幸运的是mod_expires Apache模块能够使用Expires头时能像max-age那样以相对的方式设置日期。使用Expire-Default指令来完成。设置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;FilesMatch &quot;\.(gif|jpg|js|css)$&quot;&amp;gt;
        ExpiresDefault &quot;access plus 10 years&quot;
    &amp;lt;/FileMatch&amp;gt;
    //该指令会同时向响应中发送Expires头和Cache-Contral max-age,响应格式如下：
    Expires: Wed, 16 Oct 2024 05:43:02 GMT
    Cache-control: max-age=315360000

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过设置Expires头可以避免额外的http请求，减少一半的响应时间。&lt;/p&gt;

&lt;p&gt;##压缩组件
使用gzip来压缩组件，从HTTP1.1开始Web客户端可以通过HTTP请求中的: Accept-Enconding: gzip,deflate  来表示对于压缩的支持，如果Web服务器看到请求中有这个头就会使用客户端列出来的方法中的一种来压缩响应。Web服务器通过响应中的Content-Encoding头来通知客户端 : Content-Encoding: gzip.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;gzip是目前最流行和最有效的压缩方法， 另外一种deflate的方式效果略逊且不流行，因此gzip使最理想的压缩方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配置gzip使用的模块取决于Apache的版本&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Apache1.3使用mod_gzip&lt;/li&gt;
  &lt;li&gt;Apache2.x使用mod_deflate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前的状况是浏览器与服务器直接连接并没有任何问题，但是如果中间有代理服务器的话有两种情况
情况一：Web客户端不支持gzip发送到代理服务器，代理服务器向服务器请求得到未压缩的组件，然后组件被代理服务器缓存，此后对该组件的所有请求都走缓存，组件失去了压缩的机会，即使以后的客户端支持gzip也没用了
情况二：如何顺序相反缓存的则是gzip压缩后的组件，这样一个不支持gzip的Web浏览器无法正常解压导致组件可能失效。
无论哪种情况都不是我们希望见到的，解决这个问题的方式是在Web服务器的响应中添加Vary头。Web服务器可以告诉代理根据一个或多个请求头来改变缓存响应，由于压缩决定基于Accept-Encoding请求头的，因此需要在服务器的Vary响应中包含Accept-Encoding.  如 Vary: Accept-Encoding
这使得代理会缓存两个版本的内容如果有设置Accept-Encoding: gzip,deflate的返回压缩版本，没有设置的返回未压缩版本。
还可以把在Apache设置支持和不支持gzip白名单将User-Agent加入Vary如 &lt;code&gt;Vary: Accept-Encoding,User-Agent&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;将样式表放在顶部&quot;&gt;将样式表放在顶部&lt;/h2&gt;
&lt;p&gt;最好的实践是将Css放到head标签中防止FOUC（Flash Of Unstyled Content）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;和A不一样，[LINK]只能出现在文档的HEAD中，但出现的次数时任意的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CSS放到底部会在IE导致白屏&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;在新窗口打开时&lt;/li&gt;
    &lt;li&gt;重新加载时&lt;/li&gt;
    &lt;li&gt;作为主页时&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;将脚本放到底部&quot;&gt;将脚本放到底部&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;脚本会阻塞后面组件的下载&lt;/li&gt;
    &lt;li&gt;脚本会阻塞后面内容的呈现&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以最佳的位置就是放到页面body最底部&lt;/p&gt;

&lt;h2 id=&quot;避免css表达式&quot;&gt;避免CSS表达式&lt;/h2&gt;
&lt;p&gt;css表达式使用不当会导致频繁的求值导致地下的性能&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以明确的一点是不了解底层影响的情况下使用css表达式是非常危险的，所以尽量避免使用CSS表达式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用外部的javascript和css&quot;&gt;使用外部的Javascript和CSS&lt;/h2&gt;

&lt;p&gt;组件的引入不外乎内联和外置。就纯粹而已内联要快一些但是我们还是会使用外置的css和脚本，这是因为外置的组件是会被缓存的导致以后的请求会从浏览器缓存读渲染会更快，而内联的脚本会导致html体积增大但是HTML是不会缓存的这样每次请求的html体积都会很大，造成额外的带宽消耗。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加载后下载脚本可以在第一次加载内联的组件然后异步加载外部组件以便为下次加载提供便利这里使用的html是不一样的需要注意。&lt;/li&gt;
  &lt;li&gt;动态内联，使用cookie来让后台决定返回那个页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;减少dns查找&quot;&gt;减少DNS查找&lt;/h2&gt;
&lt;p&gt;根据HTTP1.1规范，建议浏览器从每个主机名并行下载两个组件，如果一个web页面平均的将组件放到两个主机名下整体响应时间会减少一半。
Yahoo研究表明使用两个主机名比使用1，4，10个主机名能带来更好的性能。因此建议将组件分别放到至少两个但是不超过四个与主机名下，这样不会造成过多的DNS查找，又可以为并行下载。&lt;/p&gt;

&lt;h2 id=&quot;精简javascript&quot;&gt;精简Javascript&lt;/h2&gt;

&lt;p&gt;可以使用gulp等工具对脚本和css进行混淆，精简和压缩，服务端开启gzip，以减少文件的体积大小。&lt;/p&gt;

&lt;h2 id=&quot;避免重定向&quot;&gt;避免重定向&lt;/h2&gt;
&lt;p&gt;比如为了使用www.xxx.com 重定向到 www.xxx.com/ 这种是不推荐的，我们只需要使用服务端配置，无需重定向就能拥有如此简洁的url即可&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;寻找一种避免重定向的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;删除重复脚本&quot;&gt;删除重复脚本&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;确保脚本只被包含一次&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以添加文件MD5后缀或者时间戳来保证文件是不同的&lt;/p&gt;

&lt;h2 id=&quot;配置或删除etag&quot;&gt;配置或删除ETag&lt;/h2&gt;
&lt;p&gt;ETag，一般建议移除ETag&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;比较最新修改日期 Last-Modified
比较实体标签 ETag&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使ajax可缓存&quot;&gt;使Ajax可缓存&lt;/h2&gt;
&lt;p&gt;真实情况ajax一般不缓存
缓存可以缓存的ajax请求，通过修改cache-control&lt;/p&gt;

&lt;h2 id=&quot;析构网站的工具&quot;&gt;析构网站的工具&lt;/h2&gt;
&lt;p&gt;YSlow&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">高性能网站建设指南-前端工程师技能精髓</summary></entry></feed>