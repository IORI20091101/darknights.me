<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-01-22T12:14:12+08:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">Gatsby入门</title><link href="/gatsby/2021/01/22/gatsby/" rel="alternate" type="text/html" title="Gatsby入门" /><published>2021-01-22T00:00:00+08:00</published><updated>2021-01-22T00:00:00+08:00</updated><id>/gatsby/2021/01/22/gatsby</id><content type="html" xml:base="/gatsby/2021/01/22/gatsby/">&lt;h1 id=&quot;gatsby&quot;&gt;Gatsby&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.com/&quot;&gt;Gatsby&lt;/a&gt;是React的开源框架用于创建网站和应用程序。 无论用来构建个人博客或者公司主页都是一个不错的选择，本文做一个简单的功能介绍和入门。&lt;/p&gt;

&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;

&lt;p&gt;首先，以Mac为例 首先安装 &lt;a href=&quot;https://brew.sh/&quot;&gt;&lt;code&gt;brew&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装Homebrew
/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;

brew -v

# 安装命令行工具
xcode-select --install

# 安装Nodejs
brew install node

# 安装git
brew install git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装&lt;strong&gt;&lt;code&gt;gatsby-cli&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install -g gatsby-cli

# 安装成功可以看到可用命令
gatsby --help

# 我们可以快速生成一个站点

gatsby new [SITE_DIRECTORY_NAME] [URL_OF_STARTER_GITHUB_REPO]

gatsby new hello-world https://github.com/gatsbyjs/gatsby-starter-hello-world

cd hello-world

gatsby develop

# 访问 http://localhost:8000/ 就可以看到
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目录如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;%E5%B0%86%E5%AE%98%E7%BD%91%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%2033f5f91bda404798bda15f55e9f1bf96/directory.png&quot; alt=&quot;%E5%B0%86%E5%AE%98%E7%BD%91%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%2033f5f91bda404798bda15f55e9f1bf96/directory.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/pages/index.js&lt;/code&gt; 即是首页地址，按照约定 &lt;code&gt;src/pages&lt;/code&gt; 下面所有的文件都是一个页面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &quot;react&quot;

export default function Home() {
  return (
    &amp;lt;div style=&amp;gt;
      &amp;lt;h1&amp;gt;Hello Gatsby!&amp;lt;/h1&amp;gt;
      &amp;lt;p&amp;gt;What a world.&amp;lt;/p&amp;gt;
      &amp;lt;img src=&quot;https://source.unsplash.com/random/400x200&quot; alt=&quot;&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们新加一个页面 &lt;code&gt;src/pages/about.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &quot;react&quot;

export default function About() {
  return (
    &amp;lt;div style=&amp;gt;
      &amp;lt;h1&amp;gt;About Gatsby&amp;lt;/h1&amp;gt;
      &amp;lt;p&amp;gt;Such wow. Very React.&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就有了两个页面分别是通过访问 &lt;a href=&quot;http://localhost:8000&quot;&gt;http://localhost:8000&lt;/a&gt; 和 &lt;a href=&quot;https://localhost:8000/about&quot;&gt;https://localhost:8000/about&lt;/a&gt; 访问。 到这里就可以愉快的添加页面了。&lt;/p&gt;

&lt;h3 id=&quot;使用组件&quot;&gt;使用组件&lt;/h3&gt;

&lt;p&gt;在上面的页面中假设我们页面有公共的&lt;code&gt;header&lt;/code&gt; 或 &lt;code&gt;footer&lt;/code&gt;，我们不需要在每个页面中定义，这时候就需要用到组件，同样的Gatsby约定 &lt;code&gt;src/components&lt;/code&gt; 文件夹下的都是放的组件，我们新建一个&lt;code&gt;src/components/header.js&lt;/code&gt;的组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &quot;react&quot;
export default function Header(props) {
  return &amp;lt;h1&amp;gt;{props.headerText}&amp;lt;/h1&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在about页面中使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &quot;react&quot;
import Header from &quot;../components/header&quot;
export default function About() {
  return (
    &amp;lt;div style=&amp;gt;
      &amp;lt;Header headerText=&quot;About Gatsby&quot; /&amp;gt;
      &amp;lt;p&amp;gt;Such wow. Very React.&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到了这里页面已经大概出来了，我也通过 &lt;code&gt;[surge.sh](https://surge.sh/)&lt;/code&gt; 部署了一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --global surge

# Then create a (free) account with them
surge login
# 提示输入邮箱密码

gatsby build

ls public

surge public/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过访问&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://arrogant-station.surge.sh/&quot;&gt;https://arrogant-station.surge.sh/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://arrogant-station.surge.sh/about/&quot;&gt;https://arrogant-station.surge.sh/about/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;就可以看到刚刚的效果&lt;/p&gt;

&lt;h3 id=&quot;自定义样式表&quot;&gt;自定义样式表&lt;/h3&gt;

&lt;p&gt;当我们想自定义样式时，我们可以在src下的styles下建立global.css，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── package.json
├── src
│   └── pages
│       └── index.js
│   └── styles
│       └── global.css
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/ * src/styles/global.css */
html {
  background-color: lavenderblush;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想让该文件生效，需要在项目根目录下新建一个 &lt;code&gt;gatsby-browser.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import &quot;./src/styles/global.css&quot;

// or:
// require('./src/styles/global.css')
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;创建组件级作用域的样式&quot;&gt;创建组件级作用域的样式&lt;/h3&gt;

&lt;p&gt;我们创建一个 &lt;code&gt;Container&lt;/code&gt; 组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;├── package.json
├── src
│   └── components
│       └── container.js
│       └── container.module.css

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们以  &lt;code&gt;.module.css&lt;/code&gt; 作为后缀即可创建一个组件级别作用域样式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &quot;react&quot;
import containerStyles from &quot;./container.module.css&quot;

export default function Container({ children }) {
  return &amp;lt;div className={containerStyles.container}&amp;gt;{children}&amp;lt;/div&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.container {
  margin: 3rem auto;
  max-width: 600px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建一个页面用来使用这个组件 &lt;code&gt;src/pages/about-css-modules.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &quot;react&quot;

import Container from &quot;../components/container&quot;

export default function About() {
  return (
    &amp;lt;Container&amp;gt;
      &amp;lt;h1&amp;gt;About Css Modules&amp;lt;/h1&amp;gt;
      &amp;lt;p&amp;gt;CSS Module are cool&amp;lt;/p&amp;gt;
    &amp;lt;/Container&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;使用插件和布局组件&quot;&gt;使用插件和布局组件&lt;/h3&gt;

&lt;p&gt;Gatsby 有着丰富的组件库 &lt;code&gt;[Plugin Library](https://www.gatsbyjs.com/plugins)&lt;/code&gt; ,我们使用组件的一个初衷就是让构建站点或博客变得简单。我们将通过使用 &lt;code&gt;[gatsby-plugin-typography](https://www.gatsbyjs.com/plugins/gatsby-plugin-typography/)&lt;/code&gt; 来了解如何使用插件&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;[Typography.js](https://kyleamathews.github.io/typography.js/)&lt;/code&gt; is a JavaScript library which generates global base styles for your site’s typography. The library has a corresponding Gatsby plugin to streamline using it in a Gatsby site.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我们安装这个插件以及相关依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install gatsby-plugin-typography react-typography typography typography-theme-fairy-gates
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 &lt;code&gt;gatsby-config.js&lt;/code&gt; 如下 ，关于该文件的详细配置在&lt;strong&gt;&lt;code&gt;[这里](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-config/)&lt;/code&gt; 。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;module.exports = {
  plugins: [
    {
      resolve: `gatsby-plugin-typography`,
      options: {
        pathToConfigModule: `src/utils/typography`,
      },
    },
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typography.js 需要一个配置文件放到 &lt;code&gt;src/utils/typography.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import Typography from &quot;typography&quot;
import fairyGateTheme from &quot;typography-theme-fairy-gates&quot;

const typography = new Typography(fairyGateTheme)

export const { scale, rhythm, options } = typography
export default typography
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以愉快的使用选中的主题来作为网站的基本样式了。接下来自定义&lt;code&gt;Layout&lt;/code&gt; 组件，&lt;code&gt;src/components/layout.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// src/components/layout.js
import React from &quot;react&quot;

export default function Layout({ children }) {
  return (
    &amp;lt;div style=&amp;gt;
      {children}
    &amp;lt;/div&amp;gt;
  )
}

//改进版本

import React from &quot;react&quot;
import { Link } from &quot;gatsby&quot;
const ListLink = props =&amp;gt; (
  &amp;lt;li style=&amp;gt;
    &amp;lt;Link to={props.to}&amp;gt;{props.children}&amp;lt;/Link&amp;gt;
  &amp;lt;/li&amp;gt;
)

export default function Layout({ children }) {
  return (
    &amp;lt;div style=&amp;gt;
      &amp;lt;header style=&amp;gt;
        &amp;lt;Link to=&quot;/&quot; style=&amp;gt;
          &amp;lt;h3 style=&amp;gt;MySweetSite&amp;lt;/h3&amp;gt;
        &amp;lt;/Link&amp;gt;
        &amp;lt;ul style=&amp;gt;
          &amp;lt;ListLink to=&quot;/&quot;&amp;gt;Home&amp;lt;/ListLink&amp;gt;
          &amp;lt;ListLink to=&quot;/about/&quot;&amp;gt;About&amp;lt;/ListLink&amp;gt;
          &amp;lt;ListLink to=&quot;/contact/&quot;&amp;gt;Contact&amp;lt;/ListLink&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/header&amp;gt;
      {children}
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// src/pages/index.js
import React from &quot;react&quot;
import Layout from &quot;../components/layout&quot;

export default function Home() {
  return (
    &amp;lt;Layout&amp;gt;
      &amp;lt;h1&amp;gt;Hi! I'm building a fake Gatsby site as part of a tutorial!&amp;lt;/h1&amp;gt;
      &amp;lt;p&amp;gt;
        What do I like to do? Lots of course but definitely enjoy building
        websites.
      &amp;lt;/p&amp;gt;
      &amp;lt;img src=&quot;https://source.unsplash.com/random/400x200&quot; alt=&quot;&quot; /&amp;gt;
    &amp;lt;/Layout&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到了这里我们已经有了一个大概的博客模型，效果可以在这里看到 &lt;a href=&quot;https://wretched-weight.surge.sh/&quot;&gt;https://wretched-weight.surge.sh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过在这个过程中碰到一个&lt;code&gt;css&lt;/code&gt; 被  强制转成 &lt;code&gt;cssFloat&lt;/code&gt; 的问题issue地址在这里 &lt;a href=&quot;https://github.com/stylelint/stylelint/issues/4490&quot;&gt;https://github.com/stylelint/stylelint/issues/4490&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用数据graphql&quot;&gt;使用数据Graphql&lt;/h3&gt;

&lt;p&gt;我们新建一个项目&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gatsby new gatsby-lesson-two https://github.com/gatsbyjs/gatsby-starter-hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装插件以及新的主题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install gatsby-plugin-typography typography react-typography typography-theme-kirkham gatsby-plugin-emotion @emotion/react
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大部分代码跟之前类似，直接上代码，我会在最后把代码地址贴上来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// src/components/layout.js

import React from &quot;react&quot;
import { css } from &quot;@emotion/react&quot;
import { Link } from &quot;gatsby&quot;

import { rhythm } from &quot;../utils/typography&quot;

export default function Layout({ children }) {
  return (
    &amp;lt;div
      css={css`
        margin: 0 auto;
        max-width: 700px;
        padding: ${rhythm(2)};
        padding-top: ${rhythm(1.5)};
      `}
    &amp;gt;
      &amp;lt;Link to={`/`}&amp;gt;
        &amp;lt;h3
          css={css`
            margin-bottom: ${rhythm(2)};
            display: inline-block;
            font-style: normal;
          `}
        &amp;gt;
          Pandas Eating Lots
        &amp;lt;/h3&amp;gt;
      &amp;lt;/Link&amp;gt;
      &amp;lt;Link
        to={`/about/`}
        css={css`
          float: right;
        `}
      &amp;gt;
        About
      &amp;lt;/Link&amp;gt;
      {children}
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// src/pages/index.js
import React from &quot;react&quot;
import Layout from &quot;../components/layout&quot;

export default function Home() {
  return (
    &amp;lt;Layout&amp;gt;
      &amp;lt;h1&amp;gt;Amazing Pandas Eating Things&amp;lt;/h1&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;img
          src=&quot;https://2.bp.blogspot.com/-BMP2l6Hwvp4/TiAxeGx4CTI/AAAAAAAAD_M/XlC_mY3SoEw/s1600/panda-group-eating-bamboo.jpg&quot;
          alt=&quot;Group of pandas eating bamboo&quot;
        /&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/Layout&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// about.js

import React from &quot;react&quot;
import { graphql } from &quot;gatsby&quot;
import Layout from &quot;../components/layout&quot;

export default function About({ data }) {
  return (
    &amp;lt;Layout&amp;gt;
      &amp;lt;h1&amp;gt;About {data.site.siteMetadata.title}&amp;lt;/h1&amp;gt;
      &amp;lt;p&amp;gt;
        We're the only site running on your computer dedicated to showing the
        best photos and videos of pandas eating lots of food.
      &amp;lt;/p&amp;gt;
    &amp;lt;/Layout&amp;gt;
  )
}

export const query = graphql`
  query {
    site {
      siteMetadata {
        title
      }
    }
  }
`
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// src/utils/typography.js

import Typography from &quot;typography&quot;
import kirkhamTheme from &quot;typography-theme-kirkham&quot;

const typography = new Typography(kirkhamTheme)

export default typography
export const rhythm = typography.rhythm
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// gatsby-config.js

module.exports = {
	siteMetadata: {
    title: `Title from siteMetadata`,
  },
  plugins: [
    `gatsby-plugin-emotion`,
    {
      resolve: `gatsby-plugin-typography`,
      options: {
        pathToConfigModule: `src/utils/typography`,
      },
    },
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终结果如下  &lt;a href=&quot;https://clumsy-texture.surge.sh/&quot;&gt;https://clumsy-texture.surge.sh/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.gatsbyjs.com/static/9a136a7536d2f4b315d446f6a1a83725/321ea/start.png&quot; alt=&quot;https://www.gatsbyjs.com/static/9a136a7536d2f4b315d446f6a1a83725/321ea/start.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;about&lt;/code&gt; 页面中我们通过 graphql 来查询到了 siteMetadata中的数据并进行了渲染，接下来我们将继续学习使用 &lt;code&gt;StaticQuery&lt;/code&gt; ，它允许我们在非页面组件中（比如 &lt;code&gt;layout.js&lt;/code&gt;）来查询数据,我们修改layout.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// src/components/layout.js

import React from &quot;react&quot;
import { css } from &quot;@emotion/react&quot;
import { useStaticQuery, Link, graphql } from &quot;gatsby&quot;

import { rhythm } from &quot;../utils/typography&quot;
export default function Layout({ children }) {
  const data = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            title
          }
        }
      }
    `
  )
  return (
    &amp;lt;div
      css={css`
        margin: 0 auto;
        max-width: 700px;
        padding: ${rhythm(2)};
        padding-top: ${rhythm(1.5)};
      `}
    &amp;gt;
      &amp;lt;Link to={`/`}&amp;gt;
        &amp;lt;h3
          css={css`
            margin-bottom: ${rhythm(2)};
            display: inline-block;
            font-style: normal;
          `}
        &amp;gt;
          {data.site.siteMetadata.title}
        &amp;lt;/h3&amp;gt;
      &amp;lt;/Link&amp;gt;
      &amp;lt;Link
        to={`/about/`}
        css={css`
          float: right;
        `}
      &amp;gt;
        About
      &amp;lt;/Link&amp;gt;
      {children}
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到目前为止已经可以通过graphql来获取数据无论是页面还是组件中都可以愉快的工作了。&lt;/p&gt;

&lt;h3 id=&quot;插件&quot;&gt;插件&lt;/h3&gt;

&lt;p&gt;安装 &lt;a href=&quot;https://www.gatsbyjs.com/plugins/gatsby-source-filesystem/&quot;&gt;gatsby-source-filesystem&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install gatsby-source-filesystem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;gatsby-config.js&lt;/code&gt;中增加一段新的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;module.exports = {
  siteMetadata: {
    title: `Pandas Eating Lots`,
  },
  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `src`,
        path: `${__dirname}/src/`,
      },
    },
    `gatsby-plugin-emotion`,
    {
      resolve: `gatsby-plugin-typography`,
      options: {
        pathToConfigModule: `src/utils/typography`,
      },
    },
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以在调试请求的页面中 [http://localhost:8000/__&lt;em&gt;graphql](http://localhost:8000/&lt;/em&gt;__graphql) 看到结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;query MyQuery {
  allFile(sort: {fields: sourceInstanceName, order: ASC}) {
    edges {
      node {
        id
        base
        accessTime
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;data&quot;: {
    &quot;allFile&quot;: {
      &quot;edges&quot;: [
        {
          &quot;node&quot;: {
            &quot;id&quot;: &quot;4adb1b72-3a75-57ee-87d7-a61196fe33a9&quot;,
            &quot;base&quot;: &quot;typography.js&quot;,
            &quot;accessTime&quot;: &quot;2021-01-21T09:40:46.525Z&quot;
          }
        },
        {
          &quot;node&quot;: {
            &quot;id&quot;: &quot;2ac5932a-8346-5197-9dd4-cd96775203f8&quot;,
            &quot;base&quot;: &quot;about.js&quot;,
            &quot;accessTime&quot;: &quot;2021-01-21T09:40:46.525Z&quot;
          }
        },
        {
          &quot;node&quot;: {
            &quot;id&quot;: &quot;e4f28a9d-ce43-59ea-9e93-607960b0f563&quot;,
            &quot;base&quot;: &quot;index.js&quot;,
            &quot;accessTime&quot;: &quot;2021-01-21T09:40:46.526Z&quot;
          }
        },
        {
          &quot;node&quot;: {
            &quot;id&quot;: &quot;ecdff8d0-0225-5f40-966d-84b66a4c3a56&quot;,
            &quot;base&quot;: &quot;layout.js&quot;,
            &quot;accessTime&quot;: &quot;2021-01-21T09:40:46.527Z&quot;
          }
        }
      ]
    }
  },
  &quot;extensions&quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们新建一个页面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// /src/pages/my-files.js

import React from &quot;react&quot;
import { graphql } from &quot;gatsby&quot;
import Layout from &quot;../components/layout&quot;

export default function MyFiles({ data }) {
  console.log(data)
  return (
    &amp;lt;Layout&amp;gt;
      &amp;lt;div&amp;gt;Hello world&amp;lt;/div&amp;gt;
    &amp;lt;/Layout&amp;gt;
  )
}

export const query = graphql`
  query {
    allFile {
      edges {
        node {
          relativePath
          prettySize
          extension
          birthTime(fromNow: true)
        }
      }
    }
  }
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过访问 &lt;a href=&quot;http://localhost:8000/my-files&quot;&gt;http://localhost:8000/my-files&lt;/a&gt; 即可看到我们请求到的数据详情&lt;/p&gt;

&lt;h3 id=&quot;转换插件&quot;&gt;转换插件&lt;/h3&gt;

&lt;p&gt;通常来说我们的博客数据都存储在一个Markdown文件中 &lt;code&gt;src/pages/sweet-pandas-eating-sweets.md&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;---
title: &quot;Sweet Pandas Eating Sweets&quot;
date: &quot;2017-08-10&quot;
---

Pandas are really sweet.

Here's a video of a panda eating sweets.

&amp;lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/4n0xNbfJLR8&quot; frameborder=&quot;0&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们如果我们想让该文件正常显示需要将其转换成我们需要的样子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install gatsby-transformer-remark
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gatsby-config.js中增加一个新的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;module.exports = {
  siteMetadata: {
    title: `Pandas Eating Lots`,
  },
  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `src`,
        path: `${__dirname}/src/`,
      },
    },
    `gatsby-transformer-remark`,
    `gatsby-plugin-emotion`,
    {
      resolve: `gatsby-plugin-typography`,
      options: {
        pathToConfigModule: `src/utils/typography`,
      },
    },
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们查询接口的位置会显示两个新的选项 &lt;code&gt;allMarkdownRemark&lt;/code&gt; 和 &lt;code&gt;markdownRemark&lt;/code&gt; 通过查询我们可以看到结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;query MyQuery {
  allMarkdownRemark {
    edges {
      node {
        id
        frontmatter {
          date
          title
        }
        excerpt
        html
        timeToRead
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;data&quot;: {
    &quot;allMarkdownRemark&quot;: {
      &quot;edges&quot;: [
        {
          &quot;node&quot;: {
            &quot;id&quot;: &quot;7cbc5c7a-e49e-5c45-a47e-3dd49a55d64f&quot;,
            &quot;frontmatter&quot;: {
              &quot;date&quot;: &quot;2017-08-10&quot;,
              &quot;title&quot;: &quot;Sweet Pandas Eating Sweets&quot;
            },
            &quot;excerpt&quot;: &quot;Pandas are really sweet. Here's a video of a panda eating sweets.&quot;,
            &quot;html&quot;: &quot;&amp;lt;p&amp;gt;Pandas are really sweet.&amp;lt;/p&amp;gt;\n&amp;lt;p&amp;gt;Here's a video of a panda eating sweets.&amp;lt;/p&amp;gt;\n&amp;lt;iframe width=\&quot;560\&quot; height=\&quot;315\&quot; src=\&quot;https://www.youtube.com/embed/4n0xNbfJLR8\&quot; frameborder=\&quot;0\&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&quot;,
            &quot;timeToRead&quot;: 1
          }
        }
      ]
    }
  },
  &quot;extensions&quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们利用动态数据来渲染首页 &lt;code&gt;src/pages/index.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;import React from &quot;react&quot;
import { graphql } from &quot;gatsby&quot;
import { css } from &quot;@emotion/react&quot;
import { rhythm } from &quot;../utils/typography&quot;
import Layout from &quot;../components/layout&quot;

export default function Home({ data }) {
  console.log(data)
  return (
    &amp;lt;Layout&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;h1
          css={css`
            display: inline-block;
            border-bottom: 1px solid;
          `}
        &amp;gt;
          Amazing Pandas Eating Things
        &amp;lt;/h1&amp;gt;
        &amp;lt;h4&amp;gt;{data.allMarkdownRemark.totalCount} Posts&amp;lt;/h4&amp;gt;
        {data.allMarkdownRemark.edges.map(({ node }) =&amp;gt; (
          &amp;lt;div key={node.id}&amp;gt;
            &amp;lt;h3
              css={css`
                margin-bottom: ${rhythm(1 / 4)};
              `}
            &amp;gt;
              {node.frontmatter.title}{&quot; &quot;}
              &amp;lt;span
                css={css`
                  color: #bbb;
                `}
              &amp;gt;
                — {node.frontmatter.date}
              &amp;lt;/span&amp;gt;
            &amp;lt;/h3&amp;gt;
            &amp;lt;p&amp;gt;{node.excerpt}&amp;lt;/p&amp;gt;
          &amp;lt;/div&amp;gt;
        ))}
      &amp;lt;/div&amp;gt;
    &amp;lt;/Layout&amp;gt;
  )
}

export const query = graphql`
  query {
    allMarkdownRemark(sort: { fields: [frontmatter___date], order: DESC }) {
      totalCount
      edges {
        node {
          id
          frontmatter {
            title
            date(formatString: &quot;DD MMMM, YYYY&quot;)
          }
          excerpt
        }
      }
    }
  }
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在的顺序是最新的在底下我们可以通过调整参数来改变文章排列顺序将&lt;code&gt;allMarkdownRemark&lt;/code&gt; 改成&lt;code&gt;allMarkdownRemark(sort: { fields: [frontmatter___date], order: DESC })&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;文章列表已经就绪，接下来显示文章详情，我们来自动创建页面以及其路径，通常如果使用了&lt;code&gt;CMS&lt;/code&gt; 比如&lt;code&gt;notion&lt;/code&gt;  , &lt;code&gt;Contentful&lt;/code&gt; , &lt;code&gt;Netlify CMS&lt;/code&gt; ,会自动提供页面路径或者 &lt;code&gt;slug&lt;/code&gt; , 但如果我们使用markdown 文件来生成页面需要使用这两个 &lt;code&gt;API&lt;/code&gt; ：&lt;code&gt;onCreateNode&lt;/code&gt; 和 &lt;code&gt;createPages&lt;/code&gt; ,我们需要在&lt;code&gt;gatsby-node.js&lt;/code&gt;这个文件中使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;
const { createFilePath } = require(`gatsby-source-filesystem`)
exports.onCreateNode = ({ node, getNode, actions }) =&amp;gt; {
	/**
	if (node.internal.type === `MarkdownRemark`) {
    const fileNode = getNode(node.parent)
    console.log(`\n`, fileNode.relativePath)
  }

	if (node.internal.type === `MarkdownRemark`) {
		console.log(createFilePath({ node, getNode, basePath: `pages` }))
  }
	*/

  const { createNodeField } = actions
  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` })
    createNodeField({
      node,
      name: `slug`,
      value: slug,
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在有了一个新的字段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;{
  allMarkdownRemark {
    edges {
      node {
        fields {
          slug
        }
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;data&quot;: {
    &quot;allMarkdownRemark&quot;: {
      &quot;edges&quot;: [
        {
          &quot;node&quot;: {
            &quot;fields&quot;: {
              &quot;slug&quot;: &quot;/pandas-and-bananas/&quot;
            }
          }
        },
        {
          &quot;node&quot;: {
            &quot;fields&quot;: {
              &quot;slug&quot;: &quot;/sweet-pandas-eating-sweets/&quot;
            }
          }
        }
      ]
    }
  },
  &quot;extensions&quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就可以根据这个字段来找到对应的文章路径了。&lt;/p&gt;

&lt;p&gt;仅仅是这样并不够，因为页面还不存在我们需要将页面生成出来，&lt;code&gt;src/pages/xxx.js&lt;/code&gt; 下的文件会自动生成页面，但是其他的需要我们调用 &lt;code&gt;createPages&lt;/code&gt;来生成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const { createFilePath } = require(`gatsby-source-filesystem`)

exports.onCreateNode = ({ node, getNode, actions }) =&amp;gt; {
  const { createNodeField } = actions
  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` })
    createNodeField({
      node,
      name: `slug`,
      value: slug,
    })
  }
}

// 这一段的是意思是先走接口将所有的数据拉过来
// 将所有的markdown的文件生成对应的页面
exports.createPages = async ({ graphql, actions }) =&amp;gt; {
  // **Note:** The graphql function call returns a Promise
  // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise for more info
  const result = await graphql(`
    query {
      allMarkdownRemark {
        edges {
          node {
            fields {
              slug
            }
          }
        }
      }
    }
  `)
  console.log(JSON.stringify(result, null, 4))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要生成页面还需要一个额外的操作，我们需要建立一个模版文件 &lt;code&gt;src/templates/blog-post.js&lt;/code&gt; 根据这个文件模版以及数据来生成对应的页面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &quot;react&quot;
import Layout from &quot;../components/layout&quot;

export default function BlogPost() {
  return (
    &amp;lt;Layout&amp;gt;
      &amp;lt;div&amp;gt;Hello blog post&amp;lt;/div&amp;gt;
    &amp;lt;/Layout&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来继续更新 &lt;code&gt;gatsby-node.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const path = require(`path`)
const { createFilePath } = require(`gatsby-source-filesystem`)

exports.onCreateNode = ({ node, getNode, actions }) =&amp;gt; {
  const { createNodeField } = actions
  if (node.internal.type === `MarkdownRemark`) {
    const slug = createFilePath({ node, getNode, basePath: `pages` })
    createNodeField({
      node,
      name: `slug`,
      value: slug,
    })
  }
}

exports.createPages = async ({ graphql, actions }) =&amp;gt; {
  const { createPage } = actions
  const result = await graphql(`
    query {
      allMarkdownRemark {
        edges {
          node {
            fields {
              slug
            }
          }
        }
      }
    }
  `)

  result.data.allMarkdownRemark.edges.forEach(({ node }) =&amp;gt; {
    createPage({
      path: node.fields.slug,
      component: path.resolve(`./src/templates/blog-post.js`),
      context: {
        // Data passed to context is available
        // in page queries as GraphQL variables.
        slug: node.fields.slug,
      },
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随便访问一个不存在的链接 &lt;a href=&quot;http://localhost:8000/sdf&quot;&gt;http://localhost:8000/sdf&lt;/a&gt; 即可看到能够访问的文章列表，点进去即可看到模版文件的内容，接下来我们更新模版数据让他显示该显示的数据即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;// src/templates/blog-post.js
import React from &quot;react&quot;
import { graphql } from &quot;gatsby&quot;
import Layout from &quot;../components/layout&quot;

export default function BlogPost({ data }) {
  const post = data.markdownRemark
  return (
    &amp;lt;Layout&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;{post.frontmatter.title}&amp;lt;/h1&amp;gt;
        &amp;lt;div dangerouslySetInnerHTML= /&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/Layout&amp;gt;
  )
}

export const query = graphql`
  query($slug: String!) {
    markdownRemark(fields: { slug: { eq: $slug } }) {
      html
      frontmatter {
        title
      }
    }
  }
`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一步更新首页中链接&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://special-shape.surge.sh/&quot;&gt;https://special-shape.surge.sh/&lt;/a&gt;&lt;/p&gt;</content><author><name>toshiba</name></author><category term="blog" /><category term="Gatsby" /><summary type="html">Gatsby</summary></entry><entry><title type="html">VSCode使用指南</title><link href="/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2020/10/12/vscode-quick/" rel="alternate" type="text/html" title="VSCode使用指南" /><published>2020-10-12T00:00:00+08:00</published><updated>2020-10-12T00:00:00+08:00</updated><id>/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2020/10/12/vscode-quick</id><content type="html" xml:base="/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/2020/10/12/vscode-quick/">&lt;h3 id=&quot;高频操作&quot;&gt;高频操作&lt;/h3&gt;

&lt;h4 id=&quot;自定义快捷键&quot;&gt;自定义快捷键&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + P 输入 打开键盘快捷方式&lt;/code&gt; 或者 &lt;code&gt;Command k + Command r&lt;/code&gt; 打开快捷键 pdf 链接&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;光标移动&quot;&gt;光标移动&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Opts + 左右箭头&lt;/code&gt; 光标在单词间跳转&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + 左右箭头&lt;/code&gt; 光标在行首行末之际跳转&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + 上下箭头&lt;/code&gt; 光标在文件开始和末尾之际跳转&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + \&lt;/code&gt; 光标在文件开始和末尾之际跳转&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;文本选择&quot;&gt;文本选择&lt;/h4&gt;

&lt;p&gt;你单击鼠标左键就可以把光标移动到相应的位置。而双击鼠标左键，则会将当前光标下的单词选中。连续三次按下鼠标左键，则会选中当前这一行代码。最后是连续四次按下鼠标左键，则会选中整个文档&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Opts + Shift + 左右箭头&lt;/code&gt; 选中单词&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + P 输入选择括号所有内容&lt;/code&gt; 将光标所在打括号的内容选中&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;在编辑器的最左边拖动行号的位置选中拖动可以选中多行&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;代码行编辑&quot;&gt;代码行编辑&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + K&lt;/code&gt; 删除一行代码或多行&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + X&lt;/code&gt; 剪切代码&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Enter&lt;/code&gt; 无论在一行的什么位置会在下面新建一行不会将一行分成两端&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + Enter&lt;/code&gt; 无论在一行的什么位置会在上面新建一行不会将一行分成两端&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Option + up/down&lt;/code&gt; 移动行&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Option + Shift + up/down&lt;/code&gt; 复制所在行到上面或者下面&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;合并代码行&quot;&gt;合并代码行&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Ctrl + j&lt;/code&gt; 将选中的代码行合并&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;调整字符大小写&quot;&gt;调整字符大小写&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;你可以选中一串字符，然后在命令面板里运行“转换为大写”或 “转换为小写”, 来变换字符的大小写。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;代码格式化&quot;&gt;代码格式化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Option + Shift + F&lt;/code&gt; 对整个文档进行格式化&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + K Command + F&lt;/code&gt; 对选中代码进行格式化&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;添加代码注释&quot;&gt;添加代码注释&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Option + Shift + A&lt;/code&gt; 对选中内容进行注释&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + /&lt;/code&gt; 对选中内容进行注释&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;代码补全&quot;&gt;代码补全&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Ctrl + 空格&lt;/code&gt; 调出建议列表或者 tab 键调出&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + 空格&lt;/code&gt; 调出建议参数预览&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;快速修复&quot;&gt;快速修复&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + .&lt;/code&gt; 对于拼错的 css 或者 js 进行修复&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;重构&quot;&gt;重构&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;F2&lt;/code&gt; 修改一个函数或者变量的名字时候，我们只需把光标放到函数或者变量名上，然后按下 F2，这样这个函数或者变量出现的地方就都会被修改。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一个常用的重构的操作就是把一段长代码抽取出来转成一个单独的函数。在 VS Code 中，我们只需选中那段代码，点击黄色的灯泡图标，然后选择对应的重构操作即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;多行操作多光标&quot;&gt;多行操作多光标&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Option + 鼠标点击&lt;/code&gt; 对于点中的地方会有一个光标，对于点击到的位置可以操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Command + Option + up/down&lt;/code&gt; 可以移动时可以产生光标，可以再通过 &lt;code&gt;Command + 左右方向键&lt;/code&gt; 可以移动到每一行末尾&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Command + D&lt;/code&gt; ，第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它。这样只需要按下三次，你就选中了所有的“5”。这个时候你再按下 “右方向键”，输入“px”，即可完成任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Option + Shift + i&lt;/code&gt; 首先你选择多行代码，然后按下 “Option + Shift + i” （Windows 上是 Alt + Shift + i），这样操作的结果是：每一行的最后都会创建一个新的光标。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;VS Code 中还有一个更加便捷的鼠标创建多光标的方式。当然，这首先要求你的鼠标拥有中键。你只需按下鼠标中键，然后对着一段文档拖出一个框，在这个框中的代码就都被选中了，而且每一行被选中的代码，都拥有一个独立的光标。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;折叠代码&quot;&gt;折叠代码&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Option + [&lt;/code&gt; 光标所在位置代码片段折叠一层&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Option + ]&lt;/code&gt; 光标所在位置代码片段展开一层&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + K Command + [&lt;/code&gt; 将一直到最外层所有折叠&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + K Command + ]&lt;/code&gt; 将一直到最外层所有展开&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + K Command + 0&lt;/code&gt; 代码全部合并&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + K Command + j&lt;/code&gt; 代码全部展开&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;单文件搜索&quot;&gt;单文件搜索&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + F&lt;/code&gt; 在文件内搜索&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Enter 或者 Shift + Enter&lt;/code&gt; 在搜索内容中跳转&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + G&lt;/code&gt; 首先我们将光标移动到我们想要搜索的单词处，然后不断按下快捷键就可以从上往下查找搜索内容并移动光标&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + G&lt;/code&gt; 从下往上查找搜索内容并移动光标&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Option + F&lt;/code&gt; 在文件内替换&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;多文件搜索&quot;&gt;多文件搜索&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + F&lt;/code&gt; 在文件夹内搜索跟替换&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;行跳转&quot;&gt;行跳转&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Ctrl + G&lt;/code&gt; 输入 10:3 跳到第 10 行第三列&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;符号跳转&quot;&gt;符号跳转&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + O&lt;/code&gt; 可以看到当前文件的所有符号，如方法名&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;文件跳转&quot;&gt;文件跳转&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Ctrl + tab&lt;/code&gt; 罗列现在已经打开到文件列表&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + P&lt;/code&gt; 跳出一个最近打开文件的列表，同时在列表的顶部还有一个搜索框&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Cmd + Enter&lt;/code&gt; （Windows 上是 Ctrl + Enter）组合键。这个文件在一个新的编辑器窗口中打开了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常规操作&quot;&gt;常规操作&lt;/h3&gt;

&lt;h4 id=&quot;命令行的使用&quot;&gt;命令行的使用&lt;/h4&gt;

&lt;p&gt;我们可以通过命令行直接启动&lt;code&gt;VSCode&lt;/code&gt;，windows 用户可以通过添加安装目录到系统环境变量 PATH 中,如果是 mac 用户&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + P&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;搜索框中输入 Shell 命令：在 PATH 中安装 “Code” 命令&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;重启VSCode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后就可以在终端中通过 code 命令直接打开&lt;code&gt;VSCode&lt;/code&gt;了，
常用的命令行使用命令&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;code -r .&lt;/code&gt; 打开当前目录 -r 代表窗口复用&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;code -r -g package.json:10:15&lt;/code&gt; 打开当前目录 -g 跳转到某个文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;code -r -d a.txt b.txt&lt;/code&gt; 打开当前目录 -d 比较两个文件差异&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有一个比较好的就是接受管道数据&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ls | code -&lt;/code&gt; 改命令可以将目录下的所有文件名展示到&lt;code&gt;VSCode&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;设置中文&quot;&gt;设置中文&lt;/h4&gt;

&lt;p&gt;首先我们可能需要为&lt;code&gt;VSCode&lt;/code&gt;设置语言，这个并不是必要操作但是可以为英语不好的同学提供一个过渡选择&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + P&lt;/code&gt; or &lt;code&gt;F1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;搜索框中输入 configure display language 然后安装其他语言选择简体中文&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;重启VSCode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;删除操作&quot;&gt;删除操作&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Backspace&lt;/code&gt; 删除该行左边&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Command + Delete&lt;/code&gt; 删除该行右边&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;撤销光标移动&quot;&gt;撤销光标移动&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + u&lt;/code&gt; 移动光标到上次的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;行排序&quot;&gt;行排序&lt;/h4&gt;

&lt;p&gt;你都可以把代码行按照字母序进行重新排序。不过这个命令比较小众，VS Code 并没有给这个命令指定快捷键，你可以调出命令面板，然后搜索 “按升序排列行” 或者 “按降序排列行” 命令执行。&lt;/p&gt;

&lt;h4 id=&quot;调整字符的位置&quot;&gt;调整字符的位置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Ctrl + t&lt;/code&gt; 交互字符位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;定义与实现之间的跳转&quot;&gt;定义与实现之间的跳转&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;F12 or Command + F12&lt;/code&gt; 按下 F12，就可以跳转到函数的定义处。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;跳到引用的地方&quot;&gt;跳到引用的地方&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Shift + F12&lt;/code&gt; 打开函数引用预览&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;代码片段&quot;&gt;代码片段&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Command + Shift + P&lt;/code&gt;： 配置用户代码片段 configure user snippets&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&quot;Print to console&quot;: {
    &quot;prefix&quot;: &quot;log&quot;,
    &quot;body&quot;: [
        &quot;console.log(${1:i});&quot;,
        &quot;$2&quot;
    ],
&quot;description&quot;: &quot;Log output to console&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;工作区&quot;&gt;工作区&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;首先打开一个文件夹 然后 打开命令面板 F1 或者 &lt;code&gt;Command + Shift + P&lt;/code&gt; 输入 将文件夹添加到工作去（add folder to workspace）&lt;/li&gt;
  &lt;li&gt;再一次打开命令面板 输入 “将工作区另存为” （save workspace as） 这样下次可以一次打开一个工作区&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Ctrl + W&lt;/code&gt; 可以切换工作区&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Ctrl + R&lt;/code&gt; 显示最近打开的文件夹列表&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Ctrl + R &lt;/code&gt; 选中后 &lt;code&gt;Command + Enter&lt;/code&gt; 可以在新窗口打开&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;显示终端&quot;&gt;显示终端&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Ctrl + ` 可以打开或者隐藏终端&lt;/li&gt;
  &lt;li&gt;新建一个文件在其中输入内容&lt;code&gt;ls -al&lt;/code&gt; 打开命令面板在其中输入 “在活动终端中运行活动文件” 这个脚本会在继承终端中运行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;拆分编辑器&quot;&gt;拆分编辑器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;命令面板中搜索 拆分编辑器&lt;/code&gt; 可以将编辑器拆分多个&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Cmd + 1、Cmd + 2 和 Cmd + 3&lt;/code&gt; 在三个编辑器中跳转&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Cmd + Option + 0&lt;/code&gt; 可以在纵向拆分跟横向拆分之间切换&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Cmd + Option + up/down&lt;/code&gt; 可以在窗口之间切换&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;命令面板中搜索 2 x 2 网格编辑器布局&lt;/code&gt; 可以将编辑器拆分 2 x 2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Cmd + B&lt;/code&gt; 打开或者关闭整个视图；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Cmd + J&lt;/code&gt; 来打开或者关闭面板； 跟 Ctrl + ` 作用一样&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;缩放&quot;&gt;缩放&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Cmd + +/-&lt;/code&gt; 缩放整个工作区；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;markdown&quot;&gt;Markdown&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;命令面板中搜索 打开侧边预览&lt;/code&gt; 可以一边编辑 markdown 文档一边预览&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-mac-introduce.html&quot;&gt;IntelliJ IDEA For Mac 快捷键&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;intellij-idea-for-mac-快捷键&quot;&gt;IntelliJ IDEA For Mac 快捷键&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;根据官方 pdf 翻译：&lt;a href=&quot;https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf&quot;&gt;https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;在 IntelliJ IDEA 中有两个 Mac 版本的快捷键，一个叫做：Mac OS X，一个叫做：Mac OS X 10.5+&lt;/li&gt;
  &lt;li&gt;目前都是用：Mac OS X 10.5+&lt;/li&gt;
  &lt;li&gt;有两套的原因：&lt;a href=&quot;https://intellij-support.jetbrains.com/hc/en-us/community/posts/206159109-Updated-Mac-OS-X-keymap-Feedback-needed&quot;&gt;https://intellij-support.jetbrains.com/hc/en-us/community/posts/206159109-Updated-Mac-OS-X-keymap-Feedback-needed&lt;/a&gt;
    &lt;blockquote&gt;
      &lt;p&gt;建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="生产工具" /><category term="IDE" /><category term="VSCode" /><summary type="html">高频操作</summary></entry><entry><title type="html">小程序开发填坑</title><link href="/%E5%B0%8F%E7%A8%8B%E5%BA%8F/2020/05/21/miniprogram-pit/" rel="alternate" type="text/html" title="小程序开发填坑" /><published>2020-05-21T00:00:00+08:00</published><updated>2020-05-21T00:00:00+08:00</updated><id>/%E5%B0%8F%E7%A8%8B%E5%BA%8F/2020/05/21/miniprogram-pit</id><content type="html" xml:base="/%E5%B0%8F%E7%A8%8B%E5%BA%8F/2020/05/21/miniprogram-pit/">&lt;p&gt;最近连续开发了几个小程序，总是有一些需要重复解决的问题，因此在此记录一下&lt;/p&gt;

&lt;h3 id=&quot;自定义头部组件&quot;&gt;自定义头部组件&lt;/h3&gt;

&lt;p&gt;我们开发小程序的时候通常是用的统一的头部，一般是白底黑字或者简单定义一下背景色和文字颜色，比如这样
在 &lt;code&gt;page/example.json&lt;/code&gt; 中定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;usingComponents&quot;: {},
  &quot;navigationBarBackgroundColor&quot;: &quot;#557dde&quot;,
  &quot;navigationBarTitleText&quot;: &quot;二维码收款&quot;,
  &quot;navigationBarTextStyle&quot;: &quot;white&quot;,
  &quot;backgroundColor&quot;: &quot;#557dde&quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在&lt;code&gt;page/example.wxss&lt;/code&gt; 中定义背景色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;page {
  background-color: #557dde;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/miniprogram/code.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时定义了顶部状态栏的颜色和背景栏的颜色，通常也能够满足需求了。&lt;/p&gt;

&lt;p&gt;但是仅仅这样是不够的比如我想像这样
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/miniprogram/example1.png&quot; alt=&quot;&quot; /&gt;
头部图片可以做滑动效果而且展开到整个头部。这时候就需要自定义组件出马了,比如在首页 index.json 中要引入自定义组建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;enablePullDownRefresh&quot;: false,
  &quot;onReachBottomDistance&quot;: 50,
  &quot;navigationStyle&quot;: &quot;custom&quot;,
  &quot;usingComponents&quot;: {
    &quot;nav-bar&quot;: &quot;/component/navbar/navbar&quot;,
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中最关键的点就是要计算状态栏的各种高度，首先头部导航包括两部分工具栏和 title 栏
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/miniprogram/navigator.png&quot; alt=&quot;&quot; /&gt;
其中上部分是工具栏通过小程序提供的&lt;code&gt;wx.getSystemInfoSync()&lt;/code&gt;方法能够拿到系统的一些信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SDKVersion: &quot;2.11.3&quot;,
  batteryLevel: 100,
  benchmarkLevel: 1,
  brand: &quot;devtools&quot;,
  deviceOrientation: &quot;portrait&quot;,
  devicePixelRatio: 2,
  fontSizeSetting: 16,
  language: &quot;zh_CN&quot;,
  model: &quot;iPhone 6/7/8&quot;,
  pixelRatio: 2,
  platform: &quot;devtools&quot;,
  safeArea: {
    bottom: 667,
    height: 647,
    left: 0,
    right: 375,
    top: 20,
    width: 375
  },
  screenHeight: 667,
  screenWidth: 375,
  statusBarHeight: 20,
  system: &quot;iOS 10.0.1&quot;,
  version: &quot;7.0.4&quot;,
  windowHeight: 603,
  windowWidth: 375,
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下 &lt;code&gt;screenHeight - windowHeight&lt;/code&gt; 所得到的就是顶部工具栏+title 栏的高度， 但是在自定义了头部组件后即设置了&lt;code&gt;&quot;navigationStyle&quot;: &quot;custom&quot;&lt;/code&gt;，这两个值是相等的,还有一个比较重要的字段 statusBarHeight 通常这个就是代表工具栏的高度而且这个值是值得信赖的。 有个点需要注意就是单位一定要设置为&lt;code&gt;px&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：由于胶囊按钮是原生组件，为表现一致，其单位在各种手机中都为 px，所以我们自定义导航栏的单位都必需是 px（切记不能用 rpx），才能完美适配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决了工具栏部分，主要需要搞定的就是 title 栏的高度了，主要是为了适配胶囊的位置。
&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/design/#%E5%9B%BE%E6%A0%87&quot;&gt;官方文档&lt;/a&gt;，有一张图片
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/miniprogram/bar.png&quot; alt=&quot;&quot; /&gt;
这里安卓跟 ios 的表现是不一样的,胶囊距离工具栏的高度是不一样的，差了 6 个 pt，更闹心的是开发工具跟真机的表现也是不一样的， 不过好在一点就是胶囊的宽和高是一样的都是&lt;code&gt;87&lt;/code&gt;*&lt;code&gt;32&lt;/code&gt;，我们所做的一切努力都是想让胶囊的上下间距跟跟不自定义组件的显示效果是一样的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;真机和开发者工具模拟器上的胶囊按钮不一样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;# iOS
	top 4px
	right 7px
	width 87px
	height 32px

# Android
	top 8px
	right 10px
	width 95px
	height 32px

# 开发者工具模拟器（iOS）
	top 6px
	right 10px
	width 87px
	height 32px

# 开发者工具模拟器（Android）
	top 8px
	right 10px
	width 87px
	height 32px

可以看出，iOS胶囊按钮与状态栏之间距离为：4px， Android为8px，是不是所有手机都是这种情况呢？
答案是:苹果手机确实都是4px,安卓大部分都是7和8 也会有其他的情况
(可以自己打印getSystemInfo验证)如何快速便捷算出这个高度,请接着往下看

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;粗暴计算方法一&quot;&gt;粗暴计算方法一&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/000aa842274d58cb15f74f81f56013&quot;&gt;自定义导航栏所有机型的适配方案&lt;/a&gt;,简单粗暴根据上面规律来计算胶囊的位置&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/s/Q79g6kmo7w5J&quot;&gt;代码片段&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
   * 获取胶囊按钮位置
   */
  getMenuPosition () {
    let top = 4
    let right = 7
    let width = 87
    let height = 32
    if (systemInfo.platform === 'devtools' &amp;amp;&amp;amp; systemInfo.system.indexOf('Android') === -1) {
      top = 6
      right = 10
    }
    else if (systemInfo.platform === 'devtools' &amp;amp;&amp;amp; systemInfo.system.indexOf('Android') != -1) {
      top = 8
      right = 10
    }
    else if (systemInfo.system.indexOf('Android') != -1) {
      top = 8
      right = 10
      width = 95
    }
    return {
      top: systemInfo.statusBarHeight + top,
      left: systemInfo.windowWidth - width - right,
      width: width,
      height: height
    }
  }

/**
   * 获取工具栏样式
   */
  getStatusBarStyle () {
    let statusBarPosition = {
      top: 0,
      left: 0,
      width: systemInfo.windowWidth,
      height: systemInfo.statusBarHeight
    }
    return this.formatStyle(statusBarPosition)
  },

   /**
   * 获取导航栏样式
   */
  getNavigationBarStyle () {
    let menuPosition = this.getMenuPosition()
    let navigationBarPosition = {
      top: systemInfo.statusBarHeight,
      left: 0,
      width: systemInfo.windowWidth,
      height: (menuPosition.top - systemInfo.statusBarHeight) * 2 + menuPosition.height
    }
    return this.formatStyle(navigationBarPosition)
  },
  /**
   * 获取导航样式
   */
  getNavigationStyle () {
    let menuPosition = this.getMenuPosition()
    let padding = systemInfo.windowWidth - menuPosition.left - menuPosition.width
    let navigationPosition = {
      top: menuPosition.top,
      left: padding,
      width: systemInfo.windowWidth - padding * 3 - menuPosition.width,
      height: menuPosition.height
    }
    return this.formatStyle(navigationPosition)
  },
  /**
   * 获取胶囊按钮样式
   */
  getMenuStyle() {
    return this.formatStyle(this.getMenuPosition())
  },
  /**
   * 格式化Style
   */
  formatStyle (position) {
    let styles = []
    for (let key in position) {
      styles.push(`${key}: ${position[key]}px;`)
    }
    return styles.join(' ')
  }


wxml 文件如下

&amp;lt;view&amp;gt;
  &amp;lt;!-- status-bar --&amp;gt;
  &amp;lt;view class=&quot;status-bar&quot; style=&quot;&quot;/&amp;gt;
  &amp;lt;!-- navigation-bar --&amp;gt;
  &amp;lt;view class=&quot;navigation-bar&quot; style=&quot;&quot;&amp;gt;
    &amp;lt;!-- title --&amp;gt;
    &amp;lt;view class=&quot;navigation&quot; style=&quot;&quot;&amp;gt;
      这是最佳可操作区域
    &amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;!-- menu --&amp;gt;
  &amp;lt;view class=&quot;menu&quot; style=&quot;&quot;/&amp;gt;
&amp;lt;/view&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下这种计算只是区分了最常规的几种显示方案，包括开发工具的安卓，开发工具的 IOS， 真机的安卓，真机的 IOS,只是囊括了最通用的显示方案，但是如果真机范围足够广的话应该会有问题，需要对出现问题的机型逐一兼容。&lt;/p&gt;

&lt;h4 id=&quot;拼多多官方不稳的方案二&quot;&gt;拼多多+官方不稳的方案二&lt;/h4&gt;

&lt;p&gt;其实官方提供了一个方法来获取胶囊的位置
&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.getMenuButtonBoundingClientRect.html&quot;&gt;wx.getMenuButtonBoundingClientRect&lt;/a&gt;
,但是这个方法可能获取不到或者根本不准确
问题列表如下：
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/miniprogram/error.png&quot; alt=&quot;&quot; /&gt;
到目前为止还是没有完美解决这个问题，所以该方法还是要慎重使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
try {
  const systemInfo = wx.getSystemInfoSync();
  rect = wx.getMenuButtonBoundingClientRect ? wx.getMenuButtonBoundingClientRect() : null;
  if (rect === null) {
    throw 'getMenuButtonBoundingClientRect error';
  }
  //取值为0的情况
  if (!rect.width) {
    throw 'getMenuButtonBoundingClientRect error';
  }
} catch (error) {
  let gap = ''; //胶囊按钮上下间距 使导航内容居中
  let width = 96; //胶囊的宽度，android大部分96或者95，ios为88或者87
  if (systemInfo.platform === 'android') {
    gap = 8;
    width = 96;
  } else if (systemInfo.platform === 'devtools') {
    if (ios) {
      gap = 6; //开发工具中ios手机 5.5
    } else {
      gap = 8; //开发工具中android和其他手机 7.5
    }
  } else {
    gap = 4;
    width = 88;
  }
  if (!systemInfo.statusBarHeight) {
    //开启wifi的情况下修复statusBarHeight值获取不到
    systemInfo.statusBarHeight = systemInfo.screenHeight - systemInfo.windowHeight - 20;
  }
  rect = {
    //获取不到胶囊信息就自定义重置一个
    bottom: systemInfo.statusBarHeight + gap + 32,
    height: 32,
    left: systemInfo.windowWidth - width - 10,
    right: systemInfo.windowWidth - 10,
    top: systemInfo.statusBarHeight + gap,
    width: width
  };
  console.log('error', error);
  console.log('rect', rect);
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过兼容官方的&lt;code&gt;wx.getMenuButtonBoundingClientRect&lt;/code&gt;方法，再加上方法一中的设定默认值的方案基本就能满足所有场景了。&lt;/p&gt;

&lt;h3 id=&quot;swiper-高度问题&quot;&gt;swiper 高度问题&lt;/h3&gt;

&lt;p&gt;我们开发时还有这样一个问题比如我们需要使用&lt;code&gt;swiper&lt;/code&gt;组件，但是问题就是， swiper 中的内容高度是 100%的，这样如果在 swiper 中同时有上滑加载更多
就会有内容显示不全的问题，为了解决这个问题我用的方法一是动态调整 swiper 内容的高度，代码如下&lt;/p&gt;

&lt;h4 id=&quot;方法一&quot;&gt;方法一&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;swiper  style=&quot;width:100%; height: {\{swiperHeight px;}\}&quot; &amp;gt;
    &amp;lt;block wx:for=&quot;&quot; wx:key=&quot;*this&quot; wx:for-item=&quot;currentType&quot;&amp;gt;
      &amp;lt;swiper-item&amp;gt;
        &amp;lt;view id=&quot;start_view&quot; class=&quot;start-view&quot; wx:if=&quot;&quot;&amp;gt;&amp;lt;/view&amp;gt;
        &amp;lt;view class=&quot;tips-con&quot; wx:if=&quot;&quot;&amp;gt;
          &amp;lt;view class=&quot;tips-item&quot;&amp;gt;若小程序定位已开启&amp;lt;/view&amp;gt;
          &amp;lt;view class=&quot;tips-item&quot;&amp;gt;请进入系统“设置”-“隐私”-“定位服务”中打开开关&amp;lt;/view&amp;gt;
          &amp;lt;view class=&quot;tips-item&quot;&amp;gt;允许使用定位系统&amp;lt;/view&amp;gt;
          &amp;lt;view class=&quot;btn open-setting-btn&quot; bindtap=&quot;openSetting&quot; wx:if=&quot;&quot;&amp;gt;
            开启定位
          &amp;lt;/view&amp;gt;
        &amp;lt;/view&amp;gt;
        &amp;lt;view id=&quot;end_view&quot; class=&quot;start-view&quot; wx:if=&quot;&quot;&amp;gt;&amp;lt;/view&amp;gt;
      &amp;lt;/swiper-item&amp;gt;
    &amp;lt;/block&amp;gt;
  &amp;lt;/swiper&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;swiperHeight&lt;/code&gt;是动态参数， 我们在请求拿到数据后，通过 &lt;code&gt;setData({ list,}) &lt;/code&gt;之后，获取 &lt;code&gt;start_view&lt;/code&gt; 和 &lt;code&gt;end_view&lt;/code&gt; 之间内容的高度来重新计算高度&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;autoHeight() {
    wx.createSelectorQuery()

      .select(&quot;#end_view&quot;)
      .boundingClientRect()

      .select(&quot;#start_view&quot;)
      .boundingClientRect()
      .exec((rect) =&amp;gt; {
        let _space = rect[0].top - rect[1].top;

        this.setData({
          swiperHeight: _space,
        });
      });
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;方法二&quot;&gt;方法二&lt;/h4&gt;

&lt;p&gt;方法一我们只是用了&lt;code&gt;swiper&lt;/code&gt;组件，另一种实现方式是同时使用 &lt;code&gt;swiper&lt;/code&gt; 和 &lt;code&gt;scroll&lt;/code&gt;，
计算可视内容高度然后将 scroll 设置成固定高度，向上拖动自动追加新内容，只需要计算一次&lt;/p&gt;

&lt;h3 id=&quot;统一请求拦截&quot;&gt;统一请求拦截&lt;/h3&gt;

&lt;p&gt;小程序发送请求我们会使用&lt;code&gt;wx.request&lt;/code&gt;，如果需要设置统一的&lt;code&gt;Content-Type&lt;/code&gt;或者在&lt;code&gt;headers&lt;/code&gt;带上&lt;code&gt;token&lt;/code&gt;， 就需要将请求封装&lt;/p&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5d2748486fb9a07ed2249914&quot;&gt;小程序之自定义头部导航栏&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5d557e2e5188255af1619716&quot;&gt;微信小程序自定义导航栏组件(完美适配所有手机),可自定义实现任何你想要的功能&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/000aa842274d58cb15f74f81f56013&quot;&gt;自定义导航栏所有机型的适配方案&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/00048e5ed784b037b959757385b413&quot;&gt;小程序顶部自定义导航组件实现原理及坑分享&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5ca0c4fc51882567ba6a6422#heading-3&quot;&gt;小程序自定义导航栏适配（完美版）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5b496d5d5188251a90187635#heading-8&quot;&gt;【微信小程序】性能优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5e56762fe51d45271a03a2e6&quot;&gt;小程序订阅消息用户拒绝/关闭后，如何引导用户再次开启？并获得用户的操作状态？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="小程序" /><summary type="html">最近连续开发了几个小程序，总是有一些需要重复解决的问题，因此在此记录一下</summary></entry><entry><title type="html">Babel最简单配置</title><link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/24/babel-config/" rel="alternate" type="text/html" title="Babel最简单配置" /><published>2020-04-24T00:00:00+08:00</published><updated>2020-04-24T00:00:00+08:00</updated><id>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/24/babel-config</id><content type="html" xml:base="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/24/babel-config/">&lt;p&gt;本文需要重新整理&lt;/p&gt;

&lt;h3 id=&quot;babel&quot;&gt;Babel&lt;/h3&gt;

&lt;p&gt;关于 Babel 相信大家都不陌生，自从 ES2015 提供了一些新的语法让众多前端爱好者们爱不释手，但是现在的浏览器对于大部分的语法并不支持，那么如何才能在自己的项目中用上自己喜欢的语法呢？这里少不了这个工具&lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;code&gt;Babel&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;它是一个转换器，作用就是将新的语法转换成能被大部分浏览器识别的代码。换言之，只要安装了 Babel 你就可以在你的项目中随心所欲的使用最新的语法。下面我们来看一下它的配置(主要针对 babel@7)
配置文件一般为&lt;code&gt;.babelrc&lt;/code&gt;或者 &lt;code&gt;babel.config.js&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先安装&lt;code&gt;@babel/core&lt;/code&gt;，这是 babel 的核心。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ npm install @babel/core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装 &lt;code&gt;@@babel/cli&lt;/code&gt;以便能够在命令行使用 babel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;$ npm install @babel/cli
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;plugins&quot;&gt;Plugins&lt;/h3&gt;

&lt;p&gt;如果需要转换剪头函数我们需要在&lt;code&gt;.babelrc&lt;/code&gt;中，配置 Plugin&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;plugins&quot;: [&quot;@babel/plugin-transform-arrow-functions&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换前&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* 转换前 */
const fn = () =&amp;gt; {};

/* 转换后 */
const fn = function () {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果再想添加结构赋值的语法怎么办呢再加插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;plugins&quot;: [
    &quot;@babel/plugin-transform-arrow-functions&quot;,
    &quot;@babel/plugin-transform-destructuring&quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不可能将所有新的语法都加到插件里所以&lt;code&gt;Babel&lt;/code&gt;向我们提供了&lt;code&gt;presets&lt;/code&gt;,它是一个插件的合集这样我们就不需要一个个的引入了。官方提供了很多 presets，比如 preset-env（处理 es6+规范语法的插件集合）、preset-stage（处理尚处在提案语法的插件集合）、preset-react（处理 react 语法的插件集合）等，这里我们主要介绍下 preset-env：&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;$ npm install @babel/preset-env
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;preset-env&quot;&gt;preset-env&lt;/h3&gt;

&lt;p&gt;preset-env 可以让你使用 es6 的语法去写代码，并且只转换需要转换的代码。默认情况下 preset-env 什么都不需要配置，此时他转换所有 es6+的代码，然而我们可以提供一个 targets 配置项指定运行环境，以下配置会将 es6 的代码转换成 IE8 以上浏览器支持的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;presets&quot;: [
    [&quot;@babel/preset-env&quot;, {
      &quot;targets&quot;: &quot;ie &amp;gt;= 8&quot;
    }]
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;babelpolyfill&quot;&gt;@babel/polyfill&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Babel&lt;/code&gt;只会去转换语法，但是新的 Api(Promise,Proxy,WeekSet, WeekMap) 并不能转换，需要通过 @babel/polyfill 来 plofill,因此我们需要安装&lt;code&gt;@babel/polyfill&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;$ npm install @babel/polyfill --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;美中不足的是这个包很大我们可能并不需要加载全部，我们希望能够按需加载 &lt;code&gt;preset-env&lt;/code&gt;可以通过配置&lt;code&gt;useBuiltIns&lt;/code&gt;来解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;presets&quot;: [
    [&quot;@babel/preset-env&quot;, {
      &quot;modules&quot;: false,
      &quot;useBuiltIns&quot;: &quot;entry&quot;,
      &quot;targets&quot;: &quot;ie &amp;gt;= 8&quot;
    }]
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;useBuiltIns&lt;/code&gt;得值可以是&lt;code&gt;entry&lt;/code&gt;或者&lt;code&gt;useage&lt;/code&gt;， &lt;code&gt;entry&lt;/code&gt;会在入口处将所有 IE8 以上浏览器不支持 api 的 polyfile 引入进来，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* test.js */
import '@babel/polyfill'

const fn = () =&amp;gt; {}
new Promise(() =&amp;gt; {})


/* test-compiled.js */
import &quot;core-js/modules/es6.array.copy-within&quot;;
import &quot;core-js/modules/es6.array.every&quot;;
import &quot;core-js/modules/es6.array.fill&quot;;
...   //省略若干引入
import &quot;core-js/modules/web.immediate&quot;;
import &quot;core-js/modules/web.dom.iterable&quot;;
import &quot;regenerator-runtime/runtime&quot;;

var fn = function fn() {};
new Promise(function () {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样通常就满足需要了，另一个配置&lt;code&gt;useage&lt;/code&gt;更强大可以扫描代码只将所用到的 API 引入进来这样更加智能，只不过该功能还处于试验阶段。&lt;/p&gt;

&lt;h3 id=&quot;babelruntime&quot;&gt;@babel/runtime&lt;/h3&gt;

&lt;p&gt;当我们进行编写一些复杂的语法时比如&lt;code&gt;class&lt;/code&gt;，会有一些重复的&lt;code&gt;helper&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* test.js */
class Test {}

/* test-compiled.js */
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError(&quot;Cannot call a class as a function&quot;);
  }
}

var Test = function Test() {
  _classCallCheck(this, Test);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果每个文件都要重复定义&lt;code&gt;\_classCallCheck&lt;/code&gt;会有重复代码，这时候可以使用&lt;code&gt;@babel/runtime&lt;/code&gt;,它里面有各种各样的辅助函数。但是引入时如果全部引入又是一种浪费， 这时又需要&lt;code&gt;@babel/plugin-transform-runtime&lt;/code&gt;这个插件了，他会帮我们自动引入 helper 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npm install @babel/runtime @babel/plugin-transform-runtime

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@babel/plugin-transform-runtime&lt;/code&gt;还提供了一个 corejs 的配置，作用是将 polyfill 代码中使用的变量隔离到局部作用域中，防止在 polyfill 的时候污染全局变量。&lt;/p&gt;

&lt;p&gt;安装插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npm install @babel/runtime-corejs2 --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;presets&quot;: [
    [&quot;@babel/preset-env&quot;, {
      &quot;modules&quot;: false,
      &quot;useBuiltIns&quot;: &quot;usage&quot;,
      &quot;targets&quot;: &quot;ie &amp;gt;= 8&quot;
    }]
  ],
  &quot;plugins&quot;: [
    [&quot;@babel/plugin-transform-runtime&quot;, {
      &quot;corejs&quot;: 2
    }]
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：这里一定要配置 corejs，同时安装@babel/runtime-corejs2，不配置的情况下@babel/plugin-transform-runtime 默认是不引入这些 polyfill 的 helper 的。corejs 的值现阶段一般指定为 2，可以近似理解为是@babel/runtime 的版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;配置文件&quot;&gt;配置文件&lt;/h3&gt;

&lt;p&gt;到目前为止配置文件已经够用了配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */

{
  &quot;presets&quot;: [
    [&quot;@babel/preset-env&quot;, {
      &quot;useBuiltIns&quot;: &quot;entry&quot;, // useage
      &quot;modules&quot;: false,
      &quot;targets&quot;: &quot;ie &amp;gt;= 8&quot;
    }]
  ],
  &quot;plugins&quot;: [
    [&quot;@babel/plugin-transform-runtime&quot;, {
      &quot;corejs&quot;: 2
    }]
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000018721165&quot;&gt;史上最清晰易懂的 babel 配置解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.windstone.cc/es6/babel/babel-v7.html#preset&quot;&gt;Babel 7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qetiJo47IyssYWAr455xHQ&quot;&gt;一口(很长的)气了解 Babel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000019577505&quot;&gt;babel-polyfill 的相关知识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5ddff3abe51d4502d56bd143&quot;&gt;不容错过的 Babel7 知识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://vince.xin/2019/06/29/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8B-%E2%80%94%E2%80%94-babel-%E5%85%A8%E5%AE%B6%E6%A1%B6/#babel-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B&quot;&gt;傻傻分不清之 —— babel 全家桶&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ShowJoy-com/showjoy-blog/issues/39&quot;&gt;import、require、export、module.exports 混合使用详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22782487&quot;&gt;在 2016 年学 JavaScript 是一种什么样的体验？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://printempw.github.io/how-could-i-use-es6-modules-in-production/&quot;&gt;我 TMD 到底要怎样才能在生产环境中用上 ES6 模块化？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="Babel" /><category term="前端工程化" /><summary type="html">本文需要重新整理</summary></entry><entry><title type="html">使用Eslint&amp;amp;Prettier来统一代码风格</title><link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/23/eslint-prettier/" rel="alternate" type="text/html" title="使用Eslint&amp;Prettier来统一代码风格" /><published>2020-04-23T00:00:00+08:00</published><updated>2020-04-23T00:00:00+08:00</updated><id>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/23/eslint-prettier</id><content type="html" xml:base="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/23/eslint-prettier/">&lt;h3 id=&quot;代码风格&quot;&gt;代码风格&lt;/h3&gt;

&lt;p&gt;当我们进行开发的时候，每个人写的代码风格不统一是很让人不爽的一件事情，那么如何来解决这个问题呢，首先我们需要选定一种规范；这里常用的规范有这两种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/airbnb&quot;&gt;Airbnb&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://standardjs.com/&quot;&gt;Standardjs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/eslint/airbnb.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/eslint/standard.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个两种规范都可以，但是这里推荐使用第一种。在选择了一种规范后如何来遵守呢。这里就要使用我们的神器&lt;code&gt;Eslint&lt;/code&gt;,Eslint 是一个 JS Linter 工具&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;它的灵感来源于 PHP Linter，将源代码解析成 AST，然后检测 AST 来判断代码是否符合规则。ESLint 使用 esprima 将源代码解析吃成 AST，然后你就可以使用任意规则来检测 AST 是否符合预期，这也是 ESLint 高可扩展性的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lint 工具&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不过我们通常不会单独来使用，一般情况都是在编辑器上安装插件，这样开发的时候才能直接看到不符合规范的地方别将其解决。另外，编辑器仍然推荐&lt;code&gt;vscode&lt;/code&gt;或者&lt;code&gt;webstorm&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;到这里我们已经有了规范标准跟代码的校验工具，我们还需要&lt;code&gt;Prettier&lt;/code&gt;,有了它我们就可以随心所欲的写代码，同字面意思 Prettier 让我们的代码更漂亮一些。可以选择启动一个 nodejs 服务来监听文件变化也可以使用编辑器自带的 watch 功能，通常我们希望格式化的过程是自动的因此我们选择设置编辑器自动保存，自动保存的时候执行代码检查跟格式化的操作,这样也不需要单独起服务。&lt;/p&gt;

&lt;h3 id=&quot;vscode&quot;&gt;vsCode&lt;/h3&gt;

&lt;p&gt;以&lt;code&gt;vscode&lt;/code&gt;为例，首先安装这两款插件&lt;code&gt;Prettier&lt;/code&gt;，&lt;code&gt;Eslint&lt;/code&gt;。
然后全局安装 &lt;code&gt;Prettier&lt;/code&gt;跟&lt;code&gt;Eslint&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yarn add prettier --dev --exact
# or globally
yarn global add prettier


$ npm install -g eslint

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后开始配置 Prettier,这个一般按照官方给出的&lt;a href=&quot;https://prettier.io/docs/en/options.html&quot;&gt;基本配置&lt;/a&gt;,一般需要调节就这几项或者使用默认配置即可，另外还可以通过 override 来对不同类型的文件执行一些规则。prettier 本身的可配置项确实比较少，他本身就是为了让用户少思考这些风格，把代码风格全部交给他.&lt;/p&gt;

&lt;p&gt;废话说完直接开干&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir awesome-project
$ cd awesome-project
$ npm init -y
$ eslint --init

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置-prettier&quot;&gt;配置 Prettier&lt;/h3&gt;

&lt;p&gt;一共有三种方式支持对 Prettier 进行配置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根目录创建.prettierrc 文件，能够写入 YML、JSON 的配置格式，并且支持.yaml/.yml/.json/.js 后缀；&lt;/li&gt;
  &lt;li&gt;根目录创建.prettier.config.js 文件，并对外 export 一个对象；&lt;/li&gt;
  &lt;li&gt;在 package.json 中新建 prettier 属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们选择&lt;code&gt;.prettierrc.js&lt;/code&gt;来配置,一下配置可以根据自己的喜好来配置或者使用 Prettier 的默认配置也没毛病&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.exports = {
  printWidth: 100,
  // tab缩进大小,默认为2
  tabWidth: 2,
  // 使用tab缩进，默认false
  useTabs: true,
  // 使用分号, 默认true
  semi: true,
  // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
  singleQuote: true,
  // use double quotes instead of single quotes in jsx
  jsxSingleQuote: false,
  // 行尾逗号,默认none,可选 none|es5|all
  // es5 包括es5中的数组、对象
  // all 包括函数对象等所有可选
  trailingComma: &quot;none&quot;,
  // JSX标签闭合位置 默认false
  // false: &amp;lt;div
  //          className=&quot;&quot;
  //          style=
  //       &amp;gt;
  // true: &amp;lt;div
  //          className=&quot;&quot;
  //          style= &amp;gt;
  jsxBracketSameLine: true,
  bracketSpacing: true, //对象大括号直接是否有空格，默认为true，效果：{ foo: bar }
  // 箭头函数参数括号 默认avoid 可选 avoid| always
  // avoid 能省略括号的时候就省略 例如x =&amp;gt; x
  // always 总是有括号
  arrowParens: &quot;avoid&quot;,
  // decide whether to break the html according to the display style
  htmlWhitespaceSensitivity: &quot;css&quot;,
  //parser: &quot;babylon&quot; //代码的解析引擎，默认为babylon，与babel相同。
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置-eslint&quot;&gt;配置 Eslint&lt;/h3&gt;

&lt;p&gt;接下来开始配置 Eslint&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.export = {
  root: true,
  parserOptions: {
    parser: &quot;babel-eslint&quot;,
  },
  env: {
    browser: true,
    commonjs: true,
    es6: true,
    jest: true,
    node: true,
  },
  extends: [&quot;airbnb&quot;, &quot;plugin:vue/essential&quot;, &quot;plugin:prettier/recommended&quot;],
  rules: {
    &quot;prettier/prettier&quot;: &quot;error&quot;,
    // allow async-await
    &quot;generator-star-spacing&quot;: &quot;off&quot;,
    // allow debugger during development
    &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;error&quot; : &quot;off&quot;,
    &quot;jsx-a11y/href-no-hash&quot;: [&quot;off&quot;],
    &quot;react/jsx-filename-extension&quot;: [
      &quot;warn&quot;,
      {
        extensions: [&quot;.js&quot;, &quot;.jsx&quot;],
      },
    ],
    &quot;max-len&quot;: [
      &quot;warn&quot;,
      {
        tabWidth: 2,
        ignoreComments: false,
        ignoreTrailingComments: true,
        ignoreUrls: true,
        ignoreStrings: true,
        ignoreTemplateLiterals: true,
        ignoreRegExpLiterals: true,
      },
    ],
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时这里也推荐 AlloyTeam 的 &lt;a href=&quot;https://github.com/AlloyTeam/eslint-config-alloy&quot;&gt;eslint-config-alloy&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/X2gShxrCw0ukZigjE_45kA&quot;&gt;深入理解 ESLint&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651230875&amp;amp;idx=1&amp;amp;sn=092211db96adfc85a26b457f7e9421a0&amp;amp;chksm=bd494b1f8a3ec20902ad0df7d6a3735b536fe585086abc9035fe24d69549bb4c81cf88658515&amp;amp;scene=21#wechat_redirect&quot;&gt;ESLint 工作原理探讨&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015315545&quot;&gt;使用 ESLint+Prettier 来统一前端代码风格&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.meteorlxy.cn/posts/2019/08/05/understand-and-use-prettier.html&quot;&gt;理解 Prettier 并用它统一你的代码风格&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="eslint" /><category term="prettier" /><category term="前端工程化" /><summary type="html">代码风格</summary></entry><entry><title type="html">前端工程化思考</title><link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/03/31/frontend-engineering/" rel="alternate" type="text/html" title="前端工程化思考" /><published>2020-03-31T00:00:00+08:00</published><updated>2020-03-31T00:00:00+08:00</updated><id>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/03/31/frontend-engineering</id><content type="html" xml:base="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/03/31/frontend-engineering/">&lt;h3 id=&quot;前端工程化思考&quot;&gt;前端工程化思考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.google.com.hk/search?safe=strict&amp;amp;es_sm=91&amp;amp;q=%E5%89%8D%E7%AB%AF%E9%9B%86%E6%88%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&amp;amp;revid=1986939511&amp;amp;sa=X&amp;amp;ei=uqT7VKjBAaelmQXeyIGIBg&amp;amp;ved=0CFsQ1QIoAA&amp;amp;biw=1415&amp;amp;bih=805&quot;&gt;前端集成解决方案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前端工程化出现的最终目的还是为了提升开发效率和运行性能。
从早期的选择类库与框架到&lt;code&gt;gulp/grunt&lt;/code&gt;等构建构建工具的使用都是围绕着这个最终目的来进行的。&lt;/p&gt;

&lt;p&gt;引用&lt;a href=&quot;https://github.com/fouber&quot;&gt;fouber&lt;/a&gt;的话，前端工程化大致分这几个阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一阶段：库/框架的选型&lt;/li&gt;
  &lt;li&gt;第二阶段：简单的构建化&lt;/li&gt;
  &lt;li&gt;第三阶段：JS/CSS模块化&lt;/li&gt;
  &lt;li&gt;第四阶段：组件化开发和“智能”静态资源管理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择jQuery,Vue,ReactJs等框架或者类库就属于第一阶段，使用gulp或者webpack等等不同的工具对静态资源进行处理属于第二阶段，目前可能大部分人属于第二阶段，至于JS和Css模块化目前基于Vue和React的框架都是使用webpack打包内置了这个概念。然后我们需要知道为什么要这么做以及怎样做&lt;/p&gt;

&lt;p&gt;So, 我们需要脱离这种刀耕火种的原始状态。让我们的开发更加流畅顺滑。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;前端集成解决方案，英文翻译为 Front-end Integrated Solution，缩写 fis，发音 [fɪs]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;前端：指前端领域，即 web 研发中常用的浏览器客户端相关技术，比如 html、js、css 等&lt;/li&gt;
  &lt;li&gt;集成：将一些孤立的事物或元素通过某种方式改变原有的分散状态集中在一起，产生联系，从而构成一个有机整体的过程。&lt;/li&gt;
  &lt;li&gt;解决方案：针对某些已经体现出的，或者可以预期的问题，不足，缺陷，需求等等，所提出的一个解决问题的方案，同时能够确保加以有效的执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不同的项目不同的架构&quot;&gt;不同的项目不同的架构&lt;/h3&gt;
&lt;p&gt;前端而言，我们目前接触到的项目一般会分为SPA单页应用和MPA多页应用, 通常对于门户网站我倾向于多页应用，一是可能每个页面之前可能关系不大使用多页面将功能拆分开会容易一点，再就是技术选型比较随意一点，还有一个原因是SEO,虽然可以通过服务端渲染首屏来解决这个问题但这种解决方案跟NodeJS搭配应该会比较舒服（基于Java的服务端渲染我了解不足），如果后台换了呢，我们希望能有一套通用的解决方案而不想跟后台或者前端框架绑定的太过严重。&lt;/p&gt;

&lt;p&gt;我们所有的方案都需要满足一些条件可以
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/engine/book.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;方案一&quot;&gt;方案一&lt;/h3&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/10#&quot;&gt;前端工程化基础&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/3&quot;&gt;前端工程与性能优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/4&quot;&gt;前端工程与模块化框架&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/6&quot;&gt;大公司里怎样开发和部署前端代码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/2&quot;&gt;前端开发体系建设日记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="前端工程化" /><summary type="html">前端工程化思考</summary></entry><entry><title type="html">重读React系列(一)</title><link href="/react/2020/01/02/react-read-one/" rel="alternate" type="text/html" title="重读React系列(一)" /><published>2020-01-02T00:00:00+08:00</published><updated>2020-01-02T00:00:00+08:00</updated><id>/react/2020/01/02/react-read-one</id><content type="html" xml:base="/react/2020/01/02/react-read-one/">&lt;p&gt;最近做东西的时候发现一些React的新的特性其实可以用到现有的项目中,所以打算重读一些React的文档,读的时候发现其实很多之前不理解的东西在文档中已经有答案了,
所以我认为有必要重新细读一下文档,将一些点总结下来.&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="React" /><summary type="html">最近做东西的时候发现一些React的新的特性其实可以用到现有的项目中,所以打算重读一些React的文档,读的时候发现其实很多之前不理解的东西在文档中已经有答案了, 所以我认为有必要重新细读一下文档,将一些点总结下来.</summary></entry><entry><title type="html">新年随笔</title><link href="/%E9%9A%8F%E7%AC%94/2020/01/01/onte-one/" rel="alternate" type="text/html" title="新年随笔" /><published>2020-01-01T00:00:00+08:00</published><updated>2020-01-01T00:00:00+08:00</updated><id>/%E9%9A%8F%E7%AC%94/2020/01/01/onte-one</id><content type="html" xml:base="/%E9%9A%8F%E7%AC%94/2020/01/01/onte-one/">&lt;h3 id=&quot;回顾&quot;&gt;回顾&lt;/h3&gt;
&lt;p&gt;今天是2020年元旦了,又是新的一年.回顾这一年对于我来说发生了实在太多的事情,亲人的离去,公司的变化,给看起来貌似稳定的生活带来了很多变数,我这个人不太喜欢变化,主要还是懒.因为懒导致自己没有成为心目中很优秀的人.其实家庭对于个人成长的影响真是至关重要,家庭的因为导致你缺少成为优秀人的潜质, 多少年之后你忽然意识到这个问题的时候,你可能需要更多的努力,才能改变这种状况. 既然意识到了你总是能够变得比现在更好.&lt;/p&gt;

&lt;h3 id=&quot;愿望&quot;&gt;愿望&lt;/h3&gt;
&lt;p&gt;新的一年有一些愿望希望能够努力达成:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;健身.好的身体是一切的根本&lt;/li&gt;
  &lt;li&gt;技术提升&amp;amp;实践,努力学习将技术变现&lt;/li&gt;
  &lt;li&gt;学习一门新的语言英语德语或日语&lt;/li&gt;
  &lt;li&gt;坚持每天写博客总结可以是非技术类的,也可以是小说&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今年一直在做新项目,业务缠身,感觉项目永远也做不完,在公司也没有什么提升,闭门造车无法走到最前沿.最好能够换个环境,明年看看形式,希望能够勇敢迈出这一步.&lt;/p&gt;

&lt;h3 id=&quot;打气&quot;&gt;打气&lt;/h3&gt;
&lt;p&gt;最近看了胖哥的技术文章发现,技术方面真的可以走的很远,如果有人带领的话肯定事半功倍,我会利用这段时间尝试把自己变成技术大拿. 多去看源码多去总结会成功的.
不要否定自己,不需要妄自菲薄,踏踏实实的过每一天.2020年希望遇见更好的自己~~&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av81092011/&quot;&gt;大胖逼逼叨-程序员快速成神三部曲-基础篇&lt;/a&gt;&lt;/p&gt;</content><author><name>toshiba</name></author><category term="随笔" /><summary type="html">回顾 今天是2020年元旦了,又是新的一年.回顾这一年对于我来说发生了实在太多的事情,亲人的离去,公司的变化,给看起来貌似稳定的生活带来了很多变数,我这个人不太喜欢变化,主要还是懒.因为懒导致自己没有成为心目中很优秀的人.其实家庭对于个人成长的影响真是至关重要,家庭的因为导致你缺少成为优秀人的潜质, 多少年之后你忽然意识到这个问题的时候,你可能需要更多的努力,才能改变这种状况. 既然意识到了你总是能够变得比现在更好.</summary></entry><entry><title type="html">JavaScript内置对象之数组</title><link href="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array/" rel="alternate" type="text/html" title="JavaScript内置对象之数组" /><published>2019-11-12T00:00:00+08:00</published><updated>2019-11-12T00:00:00+08:00</updated><id>/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array</id><content type="html" xml:base="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array/">&lt;p&gt;本文为了详细记录JavaScript内置对象中的一些方法&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><summary type="html">本文为了详细记录JavaScript内置对象中的一些方法</summary></entry><entry><title type="html">URL编码</title><link href="/%E5%9F%BA%E7%A1%80/2019/10/16/url-encode/" rel="alternate" type="text/html" title="URL编码" /><published>2019-10-16T00:00:00+08:00</published><updated>2019-10-16T00:00:00+08:00</updated><id>/%E5%9F%BA%E7%A1%80/2019/10/16/url-encode</id><content type="html" xml:base="/%E5%9F%BA%E7%A1%80/2019/10/16/url-encode/">&lt;h3 id=&quot;起因&quot;&gt;起因&lt;/h3&gt;
&lt;p&gt;前几天的时候做了一个领奖的公众号,回调的时候url中会自动带过来一个使用des3加密的orderId, 本来在测试环境的时候是没有问题的,但是到了线上却出现了问题,经过排查发现加密串本来是&lt;code&gt;tq+3wB8PdfY=&lt;/code&gt;, 传到后台的错误结果是&lt;code&gt;tq%203wB8PdfY%3D&lt;/code&gt;,但是真实需要传给后台的却是&lt;code&gt;tq%2B3wB8PdfY%3D&lt;/code&gt;. 因此在这里将该问题总结一下.转载自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/02/url_encoding.html&quot;&gt;关于URL编码&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;需要知道&quot;&gt;需要知道&lt;/h3&gt;
&lt;p&gt;首先需要知道的是一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。比如，世界上有英文字母的网址”http://www.abc.com”，但是没有希腊字母的网址”http://www.aβγ.com”（读作阿尔法-贝塔-伽玛.com）。这是因为网络标准RFC 1738做了硬性规定：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“…Only alphanumerics [0-9a-zA-Z], the special characters “$-_.+!&lt;em&gt;’(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.”
“只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!&lt;/em&gt;’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这意味着，如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致”URL编码”成为了一个混乱的领域。&lt;/p&gt;

&lt;h3 id=&quot;不同情况下url编码&quot;&gt;不同情况下URL编码&lt;/h3&gt;

&lt;h4 id=&quot;1当汉字出现在url中&quot;&gt;1.当汉字出现在URL中&lt;/h4&gt;
&lt;p&gt;IE现在的使用率的确低,这里出现只为了做对比.
在IE8浏览器中输入网址&lt;code&gt;http://zh.wikipedia.org/wiki/春节&lt;/code&gt;,会怎么样呢?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;我们刚刚说过汉字不可以不编码直接用于url,这里直接用的后果就是不同的浏览器会按照各种的方式进行编码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们查看请求头发现IE实际查询的网址是&lt;code&gt;http://zh.wikipedia.org/wiki/%E6%98%A5%E8%8A%82&lt;/code&gt;, 也就是说IE自动将&lt;code&gt;春节&lt;/code&gt;编码成&lt;code&gt;%E6%98%A5%E8%8A%82&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;“春”和”节”的utf-8编码分别是”E6 98 A5”和”E8 8A 82”，因此，”%E6%98%A5%E8%8A%82”就是按照顺序，在每个字节前加上%而得到的, 网址路径的编码，用的是utf-8编码(FireFox中结果也一样)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;所以当汉字出现在url中的时,网址路径的编码用的时utf-8编码.&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2汉字出现在查询字符串中&quot;&gt;2.汉字出现在查询字符串中&lt;/h4&gt;
&lt;p&gt;在IE8浏览器中输入网址&lt;code&gt;http://www.baidu.com/s?wd=春节&lt;/code&gt;, &lt;code&gt;春节&lt;/code&gt;这两个字此时属于查询字符串，不属于网址路径.
查看http请求头信息,IE将&lt;code&gt;春节&lt;/code&gt;转化成了一个乱码.切换成16进制才能清楚看到这两个字被转成了&lt;code&gt;B4 BA BD DA&lt;/code&gt;
“春”和”节”的GB2312编码（”Windows xp”中文版的默认编码）分别是”B4 BA”和”BD DA”。因此，IE实际上就是将查询字符串，以GB2312编码的格式发送出去。&lt;/p&gt;

&lt;p&gt;Firefox跟Chrome发送的请求头如下, 同样采用GB2312编码，但是在每个字节前加上了%;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;所以查询字符串的编码，用的是操作系统的默认编码。&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;3get方法生成的url包含汉字&quot;&gt;3.Get方法生成的URL包含汉字&lt;/h4&gt;
&lt;p&gt;上面的情况都是直接在浏览器中输入url的情况, 更常见的情况是，在已打开的网页上，直接用Get或Post方法发出HTTP请求。
根据&lt;a href=&quot;http://xml-nchu.blogspot.com/p/url.html&quot;&gt;台湾中兴大学吕瑞麟老师的试验&lt;/a&gt;, 这时的编码方法由网页的编码决定，也就是由HTML源码中字符集的设定决定.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=xxxx&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。&lt;/p&gt;

&lt;p&gt;举例来说，百度是GB2312编码，Google是UTF-8编码。因此，从它们的搜索框中搜索同一个词”春节”，生成的查询字符串是不一样的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;百度生成的是%B4%BA%BD%DA，这是GB2312编码。&lt;/li&gt;
  &lt;li&gt;Google生成的是%E6%98%A5%E8%8A%82，这是UTF-8编码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;GET和POST方法的编码，用的是网页的编码&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;4ajax调用url包含汉字&quot;&gt;4.Ajax调用URL包含汉字&lt;/h4&gt;
&lt;p&gt;前几种情况都是浏览器发送HTTP请求,Ajax是JavaScript来生成HTTP请求,也就是Ajax调用. 这种情况传送给服务器的参数,IE总是采用操作系统默认编码, Chrome则是Utf-8编码.&lt;/p&gt;

&lt;h3 id=&quot;编码解码的方法&quot;&gt;编码解码的方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;escape&lt;/code&gt;跟&lt;code&gt;unescape&lt;/code&gt;,已经不推荐使用. 它的具体规则是，除了ASCII字母、数字、标点符号”@ * _ + - . /”以外，对其他所有字符进行编码。在\u0000到\u00ff之间的符号被转成%xx的形式，其余符号被转成%uxxxx的形式。对应的解码函数是unescape()。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;escape(&quot;春节&quot;);
// %u6625%u8282

escape(&quot;Hello World&quot;);
// Hello%20World

unescape(&quot;%u6625%u8282&quot;)
// 春节

unescape(&quot;\u6625\u8282&quot;)
// 春节

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两个方法不推荐使用.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;encodeURI&lt;/code&gt;是Javascript中真正用来对URL编码的函数。但是对于以下网址中有特殊含义的符号不进行编码.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;; / ? : @ &amp;amp; = + $ , #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相反的&lt;code&gt;encodeURIComponent&lt;/code&gt;方法会将上面的符号也进行编码.
&lt;code&gt;decodeURI&lt;/code&gt;和&lt;code&gt;decodeURIComponent&lt;/code&gt;是相应的解码方法&lt;/p&gt;

&lt;h3 id=&quot;解决&quot;&gt;解决&lt;/h3&gt;
&lt;p&gt;再回到一开始的问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一步浏览器url拿到的查询参数是正确的&lt;code&gt;tq%2B3wB8PdfY%3D&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;第二步代码中获取到的参数变量也是正确的&lt;code&gt;tq+3wB8PdfY=&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;第三部利用该参数向url中拼接跳转下一步页面例如 /xxx/xxx?orderId=tq+3wB8PdfY 到这里其实是有问题的浏览器会自动将&lt;code&gt;+&lt;/code&gt;号转为空格&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;escape()不对”+”编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从这里开始再向后台传参数就不会拿到正确的地址了,其实要解决很简单使用&lt;code&gt;encodeURIComponent&lt;/code&gt;编码一下就可以,其实vue和react的框架其实自己可以转换,但是要正确使用跳转URL的方法.&lt;/p&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u014785687/article/details/74078512&quot;&gt;不同浏览器中URL的编码方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="JavaScript" /><summary type="html">起因 前几天的时候做了一个领奖的公众号,回调的时候url中会自动带过来一个使用des3加密的orderId, 本来在测试环境的时候是没有问题的,但是到了线上却出现了问题,经过排查发现加密串本来是tq+3wB8PdfY=, 传到后台的错误结果是tq%203wB8PdfY%3D,但是真实需要传给后台的却是tq%2B3wB8PdfY%3D. 因此在这里将该问题总结一下.转载自关于URL编码</summary></entry></feed>