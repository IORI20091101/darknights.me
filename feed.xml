<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-04-30T17:52:14+08:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">Babel最简单配置</title><link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/24/babel-config/" rel="alternate" type="text/html" title="Babel最简单配置" /><published>2020-04-24T00:00:00+08:00</published><updated>2020-04-24T00:00:00+08:00</updated><id>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/24/babel-config</id><content type="html" xml:base="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/24/babel-config/">&lt;p&gt;本文需要重新整理&lt;/p&gt;

&lt;h3 id=&quot;babel&quot;&gt;Babel&lt;/h3&gt;

&lt;p&gt;关于 Babel 相信大家都不陌生，自从 ES2015 提供了一些新的语法让众多前端爱好者们爱不释手，但是现在的浏览器对于大部分的语法并不支持，那么如何才能在自己的项目中用上自己喜欢的语法呢？这里少不了这个工具&lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;code&gt;Babel&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;它是一个转换器，作用就是将新的语法转换成能被大部分浏览器识别的代码。换言之，只要安装了 Babel 你就可以在你的项目中随心所欲的使用最新的语法。下面我们来看一下它的配置(主要针对 babel@7)
配置文件一般为&lt;code&gt;.babelrc&lt;/code&gt;或者 &lt;code&gt;babel.config.js&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先安装&lt;code&gt;@babel/core&lt;/code&gt;，这是 babel 的核心。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ npm install @babel/core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装 &lt;code&gt;@@babel/cli&lt;/code&gt;以便能够在命令行使用 babel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;$ npm install @babel/cli
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;plugins&quot;&gt;Plugins&lt;/h3&gt;

&lt;p&gt;如果需要转换剪头函数我们需要在&lt;code&gt;.babelrc&lt;/code&gt;中，配置 Plugin&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;plugins&quot;: [&quot;@babel/plugin-transform-arrow-functions&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换前&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* 转换前 */
const fn = () =&amp;gt; {};

/* 转换后 */
const fn = function () {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果再想添加结构赋值的语法怎么办呢再加插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;plugins&quot;: [
    &quot;@babel/plugin-transform-arrow-functions&quot;,
    &quot;@babel/plugin-transform-destructuring&quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不可能将所有新的语法都加到插件里所以&lt;code&gt;Babel&lt;/code&gt;向我们提供了&lt;code&gt;presets&lt;/code&gt;,它是一个插件的合集这样我们就不需要一个个的引入了。官方提供了很多 presets，比如 preset-env（处理 es6+规范语法的插件集合）、preset-stage（处理尚处在提案语法的插件集合）、preset-react（处理 react 语法的插件集合）等，这里我们主要介绍下 preset-env：&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;$ npm install @babel/preset-env
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;preset-env&quot;&gt;preset-env&lt;/h3&gt;

&lt;p&gt;preset-env 可以让你使用 es6 的语法去写代码，并且只转换需要转换的代码。默认情况下 preset-env 什么都不需要配置，此时他转换所有 es6+的代码，然而我们可以提供一个 targets 配置项指定运行环境，以下配置会将 es6 的代码转换成 IE8 以上浏览器支持的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;presets&quot;: [
    [&quot;@babel/preset-env&quot;, {
      &quot;targets&quot;: &quot;ie &amp;gt;= 8&quot;
    }]
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;babelpolyfill&quot;&gt;@babel/polyfill&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Babel&lt;/code&gt;只会去转换语法，但是新的 Api(Promise,Proxy,WeekSet, WeekMap) 并不能转换，需要通过 @babel/polyfill 来 plofill,因此我们需要安装&lt;code&gt;@babel/polyfill&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;$ npm install @babel/polyfill --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;美中不足的是这个包很大我们可能并不需要加载全部，我们希望能够按需加载 &lt;code&gt;preset-env&lt;/code&gt;可以通过配置&lt;code&gt;useBuiltIns&lt;/code&gt;来解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;presets&quot;: [
    [&quot;@babel/preset-env&quot;, {
      &quot;modules&quot;: false,
      &quot;useBuiltIns&quot;: &quot;entry&quot;,
      &quot;targets&quot;: &quot;ie &amp;gt;= 8&quot;
    }]
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;useBuiltIns&lt;/code&gt;得值可以是&lt;code&gt;entry&lt;/code&gt;或者&lt;code&gt;useage&lt;/code&gt;， &lt;code&gt;entry&lt;/code&gt;会在入口处将所有 IE8 以上浏览器不支持 api 的 polyfile 引入进来，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* test.js */
import '@babel/polyfill'

const fn = () =&amp;gt; {}
new Promise(() =&amp;gt; {})


/* test-compiled.js */
import &quot;core-js/modules/es6.array.copy-within&quot;;
import &quot;core-js/modules/es6.array.every&quot;;
import &quot;core-js/modules/es6.array.fill&quot;;
...   //省略若干引入
import &quot;core-js/modules/web.immediate&quot;;
import &quot;core-js/modules/web.dom.iterable&quot;;
import &quot;regenerator-runtime/runtime&quot;;

var fn = function fn() {};
new Promise(function () {});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样通常就满足需要了，另一个配置&lt;code&gt;useage&lt;/code&gt;更强大可以扫描代码只将所用到的 API 引入进来这样更加智能，只不过该功能还处于试验阶段。&lt;/p&gt;

&lt;h3 id=&quot;babelruntime&quot;&gt;@babel/runtime&lt;/h3&gt;

&lt;p&gt;当我们进行编写一些复杂的语法时比如&lt;code&gt;class&lt;/code&gt;，会有一些重复的&lt;code&gt;helper&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* test.js */
class Test {}

/* test-compiled.js */
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError(&quot;Cannot call a class as a function&quot;);
  }
}

var Test = function Test() {
  _classCallCheck(this, Test);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果每个文件都要重复定义&lt;code&gt;\_classCallCheck&lt;/code&gt;会有重复代码，这时候可以使用&lt;code&gt;@babel/runtime&lt;/code&gt;,它里面有各种各样的辅助函数。但是引入时如果全部引入又是一种浪费， 这时又需要&lt;code&gt;@babel/plugin-transform-runtime&lt;/code&gt;这个插件了，他会帮我们自动引入 helper 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npm install @babel/runtime @babel/plugin-transform-runtime

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@babel/plugin-transform-runtime&lt;/code&gt;还提供了一个 corejs 的配置，作用是将 polyfill 代码中使用的变量隔离到局部作用域中，防止在 polyfill 的时候污染全局变量。&lt;/p&gt;

&lt;p&gt;安装插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npm install @babel/runtime-corejs2 --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */
{
  &quot;presets&quot;: [
    [&quot;@babel/preset-env&quot;, {
      &quot;modules&quot;: false,
      &quot;useBuiltIns&quot;: &quot;usage&quot;,
      &quot;targets&quot;: &quot;ie &amp;gt;= 8&quot;
    }]
  ],
  &quot;plugins&quot;: [
    [&quot;@babel/plugin-transform-runtime&quot;, {
      &quot;corejs&quot;: 2
    }]
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：这里一定要配置 corejs，同时安装@babel/runtime-corejs2，不配置的情况下@babel/plugin-transform-runtime 默认是不引入这些 polyfill 的 helper 的。corejs 的值现阶段一般指定为 2，可以近似理解为是@babel/runtime 的版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;配置文件&quot;&gt;配置文件&lt;/h3&gt;

&lt;p&gt;到目前为止配置文件已经够用了配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* .babelrc */

{
  &quot;presets&quot;: [
    [&quot;@babel/preset-env&quot;, {
      &quot;useBuiltIns&quot;: &quot;entry&quot;, // useage
      &quot;modules&quot;: false,
      &quot;targets&quot;: &quot;ie &amp;gt;= 8&quot;
    }]
  ],
  &quot;plugins&quot;: [
    [&quot;@babel/plugin-transform-runtime&quot;, {
      &quot;corejs&quot;: 2
    }]
  ]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000018721165&quot;&gt;史上最清晰易懂的 babel 配置解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.windstone.cc/es6/babel/babel-v7.html#preset&quot;&gt;Babel 7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qetiJo47IyssYWAr455xHQ&quot;&gt;一口(很长的)气了解 Babel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000019577505&quot;&gt;babel-polyfill 的相关知识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5ddff3abe51d4502d56bd143&quot;&gt;不容错过的 Babel7 知识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://vince.xin/2019/06/29/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8B-%E2%80%94%E2%80%94-babel-%E5%85%A8%E5%AE%B6%E6%A1%B6/#babel-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B&quot;&gt;傻傻分不清之 —— babel 全家桶&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ShowJoy-com/showjoy-blog/issues/39&quot;&gt;import、require、export、module.exports 混合使用详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22782487&quot;&gt;在 2016 年学 JavaScript 是一种什么样的体验？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://printempw.github.io/how-could-i-use-es6-modules-in-production/&quot;&gt;我 TMD 到底要怎样才能在生产环境中用上 ES6 模块化？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="Babel" /><category term="前端工程化" /><summary type="html">本文需要重新整理</summary></entry><entry><title type="html">使用Eslint&amp;amp;Prettier来统一代码风格</title><link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/23/eslint-prettier/" rel="alternate" type="text/html" title="使用Eslint&amp;Prettier来统一代码风格" /><published>2020-04-23T00:00:00+08:00</published><updated>2020-04-23T00:00:00+08:00</updated><id>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/23/eslint-prettier</id><content type="html" xml:base="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/04/23/eslint-prettier/">&lt;h3 id=&quot;代码风格&quot;&gt;代码风格&lt;/h3&gt;

&lt;p&gt;当我们进行开发的时候，每个人写的代码风格不统一是很让人不爽的一件事情，那么如何来解决这个问题呢，首先我们需要选定一种规范；这里常用的规范有这两种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/airbnb&quot;&gt;Airbnb&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://standardjs.com/&quot;&gt;Standardjs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/eslint/airbnb.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/eslint/standard.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个两种规范都可以，但是这里推荐使用第一种。在选择了一种规范后如何来遵守呢。这里就要使用我们的神器&lt;code&gt;Eslint&lt;/code&gt;,Eslint 是一个 JS Linter 工具&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;它的灵感来源于 PHP Linter，将源代码解析成 AST，然后检测 AST 来判断代码是否符合规则。ESLint 使用 esprima 将源代码解析吃成 AST，然后你就可以使用任意规则来检测 AST 是否符合预期，这也是 ESLint 高可扩展性的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lint 工具&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不过我们通常不会单独来使用，一般情况都是在编辑器上安装插件，这样开发的时候才能直接看到不符合规范的地方别将其解决。另外，编辑器仍然推荐&lt;code&gt;vscode&lt;/code&gt;或者&lt;code&gt;webstorm&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;到这里我们已经有了规范标准跟代码的校验工具，我们还需要&lt;code&gt;Prettier&lt;/code&gt;,有了它我们就可以随心所欲的写代码，同字面意思 Prettier 让我们的代码更漂亮一些。可以选择启动一个 nodejs 服务来监听文件变化也可以使用编辑器自带的 watch 功能，通常我们希望格式化的过程是自动的因此我们选择设置编辑器自动保存，自动保存的时候执行代码检查跟格式化的操作,这样也不需要单独起服务。&lt;/p&gt;

&lt;h3 id=&quot;vscode&quot;&gt;vsCode&lt;/h3&gt;

&lt;p&gt;以&lt;code&gt;vscode&lt;/code&gt;为例，首先安装这两款插件&lt;code&gt;Prettier&lt;/code&gt;，&lt;code&gt;Eslint&lt;/code&gt;。
然后全局安装 &lt;code&gt;Prettier&lt;/code&gt;跟&lt;code&gt;Eslint&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yarn add prettier --dev --exact
# or globally
yarn global add prettier


$ npm install -g eslint

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后开始配置 Prettier,这个一般按照官方给出的&lt;a href=&quot;https://prettier.io/docs/en/options.html&quot;&gt;基本配置&lt;/a&gt;,一般需要调节就这几项或者使用默认配置即可，另外还可以通过 override 来对不同类型的文件执行一些规则。prettier 本身的可配置项确实比较少，他本身就是为了让用户少思考这些风格，把代码风格全部交给他.&lt;/p&gt;

&lt;p&gt;废话说完直接开干&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir awesome-project
$ cd awesome-project
$ npm init -y
$ eslint --init

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置-prettier&quot;&gt;配置 Prettier&lt;/h3&gt;

&lt;p&gt;一共有三种方式支持对 Prettier 进行配置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根目录创建.prettierrc 文件，能够写入 YML、JSON 的配置格式，并且支持.yaml/.yml/.json/.js 后缀；&lt;/li&gt;
  &lt;li&gt;根目录创建.prettier.config.js 文件，并对外 export 一个对象；&lt;/li&gt;
  &lt;li&gt;在 package.json 中新建 prettier 属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们选择&lt;code&gt;.prettierrc.js&lt;/code&gt;来配置,一下配置可以根据自己的喜好来配置或者使用 Prettier 的默认配置也没毛病&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.exports = {
  printWidth: 100,
  // tab缩进大小,默认为2
  tabWidth: 2,
  // 使用tab缩进，默认false
  useTabs: true,
  // 使用分号, 默认true
  semi: true,
  // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
  singleQuote: true,
  // use double quotes instead of single quotes in jsx
  jsxSingleQuote: false,
  // 行尾逗号,默认none,可选 none|es5|all
  // es5 包括es5中的数组、对象
  // all 包括函数对象等所有可选
  trailingComma: &quot;none&quot;,
  // JSX标签闭合位置 默认false
  // false: &amp;lt;div
  //          className=&quot;&quot;
  //          style=
  //       &amp;gt;
  // true: &amp;lt;div
  //          className=&quot;&quot;
  //          style= &amp;gt;
  jsxBracketSameLine: true,
  bracketSpacing: true, //对象大括号直接是否有空格，默认为true，效果：{ foo: bar }
  // 箭头函数参数括号 默认avoid 可选 avoid| always
  // avoid 能省略括号的时候就省略 例如x =&amp;gt; x
  // always 总是有括号
  arrowParens: &quot;avoid&quot;,
  // decide whether to break the html according to the display style
  htmlWhitespaceSensitivity: &quot;css&quot;,
  //parser: &quot;babylon&quot; //代码的解析引擎，默认为babylon，与babel相同。
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置-eslint&quot;&gt;配置 Eslint&lt;/h3&gt;

&lt;p&gt;接下来开始配置 Eslint&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.export = {
  root: true,
  parserOptions: {
    parser: &quot;babel-eslint&quot;,
  },
  env: {
    browser: true,
    commonjs: true,
    es6: true,
    jest: true,
    node: true,
  },
  extends: [&quot;airbnb&quot;, &quot;plugin:vue/essential&quot;, &quot;plugin:prettier/recommended&quot;],
  rules: {
    &quot;prettier/prettier&quot;: &quot;error&quot;,
    // allow async-await
    &quot;generator-star-spacing&quot;: &quot;off&quot;,
    // allow debugger during development
    &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;error&quot; : &quot;off&quot;,
    &quot;jsx-a11y/href-no-hash&quot;: [&quot;off&quot;],
    &quot;react/jsx-filename-extension&quot;: [
      &quot;warn&quot;,
      {
        extensions: [&quot;.js&quot;, &quot;.jsx&quot;],
      },
    ],
    &quot;max-len&quot;: [
      &quot;warn&quot;,
      {
        tabWidth: 2,
        ignoreComments: false,
        ignoreTrailingComments: true,
        ignoreUrls: true,
        ignoreStrings: true,
        ignoreTemplateLiterals: true,
        ignoreRegExpLiterals: true,
      },
    ],
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时这里也推荐 AlloyTeam 的 &lt;a href=&quot;https://github.com/AlloyTeam/eslint-config-alloy&quot;&gt;eslint-config-alloy&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/X2gShxrCw0ukZigjE_45kA&quot;&gt;深入理解 ESLint&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651230875&amp;amp;idx=1&amp;amp;sn=092211db96adfc85a26b457f7e9421a0&amp;amp;chksm=bd494b1f8a3ec20902ad0df7d6a3735b536fe585086abc9035fe24d69549bb4c81cf88658515&amp;amp;scene=21#wechat_redirect&quot;&gt;ESLint 工作原理探讨&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015315545&quot;&gt;使用 ESLint+Prettier 来统一前端代码风格&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.meteorlxy.cn/posts/2019/08/05/understand-and-use-prettier.html&quot;&gt;理解 Prettier 并用它统一你的代码风格&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="eslint" /><category term="prettier" /><category term="前端工程化" /><summary type="html">代码风格</summary></entry><entry><title type="html">前端工程化思考</title><link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/03/31/frontend-engineering/" rel="alternate" type="text/html" title="前端工程化思考" /><published>2020-03-31T00:00:00+08:00</published><updated>2020-03-31T00:00:00+08:00</updated><id>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/03/31/frontend-engineering</id><content type="html" xml:base="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/2020/03/31/frontend-engineering/">&lt;h3 id=&quot;前端工程化思考&quot;&gt;前端工程化思考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.google.com.hk/search?safe=strict&amp;amp;es_sm=91&amp;amp;q=%E5%89%8D%E7%AB%AF%E9%9B%86%E6%88%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&amp;amp;revid=1986939511&amp;amp;sa=X&amp;amp;ei=uqT7VKjBAaelmQXeyIGIBg&amp;amp;ved=0CFsQ1QIoAA&amp;amp;biw=1415&amp;amp;bih=805&quot;&gt;前端集成解决方案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前端工程化出现的最终目的还是为了提升开发效率和运行性能。
从早期的选择类库与框架到&lt;code&gt;gulp/grunt&lt;/code&gt;等构建构建工具的使用都是围绕着这个最终目的来进行的。&lt;/p&gt;

&lt;p&gt;引用&lt;a href=&quot;https://github.com/fouber&quot;&gt;fouber&lt;/a&gt;的话，前端工程化大致分这几个阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一阶段：库/框架的选型&lt;/li&gt;
  &lt;li&gt;第二阶段：简单的构建化&lt;/li&gt;
  &lt;li&gt;第三阶段：JS/CSS模块化&lt;/li&gt;
  &lt;li&gt;第四阶段：组件化开发和“智能”静态资源管理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择jQuery,Vue,ReactJs等框架或者类库就属于第一阶段，使用gulp或者webpack等等不同的工具对静态资源进行处理属于第二阶段，目前可能大部分人属于第二阶段，至于JS和Css模块化目前基于Vue和React的框架都是使用webpack打包内置了这个概念。然后我们需要知道为什么要这么做以及怎样做&lt;/p&gt;

&lt;p&gt;So, 我们需要脱离这种刀耕火种的原始状态。让我们的开发更加流畅顺滑。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;前端集成解决方案，英文翻译为 Front-end Integrated Solution，缩写 fis，发音 [fɪs]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;前端：指前端领域，即 web 研发中常用的浏览器客户端相关技术，比如 html、js、css 等&lt;/li&gt;
  &lt;li&gt;集成：将一些孤立的事物或元素通过某种方式改变原有的分散状态集中在一起，产生联系，从而构成一个有机整体的过程。&lt;/li&gt;
  &lt;li&gt;解决方案：针对某些已经体现出的，或者可以预期的问题，不足，缺陷，需求等等，所提出的一个解决问题的方案，同时能够确保加以有效的执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不同的项目不同的架构&quot;&gt;不同的项目不同的架构&lt;/h3&gt;
&lt;p&gt;前端而言，我们目前接触到的项目一般会分为SPA单页应用和MPA多页应用, 通常对于门户网站我倾向于多页应用，一是可能每个页面之前可能关系不大使用多页面将功能拆分开会容易一点，再就是技术选型比较随意一点，还有一个原因是SEO,虽然可以通过服务端渲染首屏来解决这个问题但这种解决方案跟NodeJS搭配应该会比较舒服（基于Java的服务端渲染我了解不足），如果后台换了呢，我们希望能有一套通用的解决方案而不想跟后台或者前端框架绑定的太过严重。&lt;/p&gt;

&lt;p&gt;我们所有的方案都需要满足一些条件可以
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/engine/book.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;方案一&quot;&gt;方案一&lt;/h3&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/10#&quot;&gt;前端工程化基础&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/3&quot;&gt;前端工程与性能优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/4&quot;&gt;前端工程与模块化框架&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/6&quot;&gt;大公司里怎样开发和部署前端代码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fouber/blog/issues/2&quot;&gt;前端开发体系建设日记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="前端工程化" /><summary type="html">前端工程化思考</summary></entry><entry><title type="html">重读React系列(一)</title><link href="/react/2020/01/02/react-read-one/" rel="alternate" type="text/html" title="重读React系列(一)" /><published>2020-01-02T00:00:00+08:00</published><updated>2020-01-02T00:00:00+08:00</updated><id>/react/2020/01/02/react-read-one</id><content type="html" xml:base="/react/2020/01/02/react-read-one/">&lt;p&gt;最近做东西的时候发现一些React的新的特性其实可以用到现有的项目中,所以打算重读一些React的文档,读的时候发现其实很多之前不理解的东西在文档中已经有答案了,
所以我认为有必要重新细读一下文档,将一些点总结下来.&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="React" /><summary type="html">最近做东西的时候发现一些React的新的特性其实可以用到现有的项目中,所以打算重读一些React的文档,读的时候发现其实很多之前不理解的东西在文档中已经有答案了, 所以我认为有必要重新细读一下文档,将一些点总结下来.</summary></entry><entry><title type="html">新年随笔</title><link href="/%E9%9A%8F%E7%AC%94/2020/01/01/onte-one/" rel="alternate" type="text/html" title="新年随笔" /><published>2020-01-01T00:00:00+08:00</published><updated>2020-01-01T00:00:00+08:00</updated><id>/%E9%9A%8F%E7%AC%94/2020/01/01/onte-one</id><content type="html" xml:base="/%E9%9A%8F%E7%AC%94/2020/01/01/onte-one/">&lt;h3 id=&quot;回顾&quot;&gt;回顾&lt;/h3&gt;
&lt;p&gt;今天是2020年元旦了,又是新的一年.回顾这一年对于我来说发生了实在太多的事情,亲人的离去,公司的变化,给看起来貌似稳定的生活带来了很多变数,我这个人不太喜欢变化,主要还是懒.因为懒导致自己没有成为心目中很优秀的人.其实家庭对于个人成长的影响真是至关重要,家庭的因为导致你缺少成为优秀人的潜质, 多少年之后你忽然意识到这个问题的时候,你可能需要更多的努力,才能改变这种状况. 既然意识到了你总是能够变得比现在更好.&lt;/p&gt;

&lt;h3 id=&quot;愿望&quot;&gt;愿望&lt;/h3&gt;
&lt;p&gt;新的一年有一些愿望希望能够努力达成:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;健身.好的身体是一切的根本&lt;/li&gt;
  &lt;li&gt;技术提升&amp;amp;实践,努力学习将技术变现&lt;/li&gt;
  &lt;li&gt;学习一门新的语言英语德语或日语&lt;/li&gt;
  &lt;li&gt;坚持每天写博客总结可以是非技术类的,也可以是小说&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今年一直在做新项目,业务缠身,感觉项目永远也做不完,在公司也没有什么提升,闭门造车无法走到最前沿.最好能够换个环境,明年看看形式,希望能够勇敢迈出这一步.&lt;/p&gt;

&lt;h3 id=&quot;打气&quot;&gt;打气&lt;/h3&gt;
&lt;p&gt;最近看了胖哥的技术文章发现,技术方面真的可以走的很远,如果有人带领的话肯定事半功倍,我会利用这段时间尝试把自己变成技术大拿. 多去看源码多去总结会成功的.
不要否定自己,不需要妄自菲薄,踏踏实实的过每一天.2020年希望遇见更好的自己~~&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av81092011/&quot;&gt;大胖逼逼叨-程序员快速成神三部曲-基础篇&lt;/a&gt;&lt;/p&gt;</content><author><name>toshiba</name></author><category term="随笔" /><summary type="html">回顾 今天是2020年元旦了,又是新的一年.回顾这一年对于我来说发生了实在太多的事情,亲人的离去,公司的变化,给看起来貌似稳定的生活带来了很多变数,我这个人不太喜欢变化,主要还是懒.因为懒导致自己没有成为心目中很优秀的人.其实家庭对于个人成长的影响真是至关重要,家庭的因为导致你缺少成为优秀人的潜质, 多少年之后你忽然意识到这个问题的时候,你可能需要更多的努力,才能改变这种状况. 既然意识到了你总是能够变得比现在更好.</summary></entry><entry><title type="html">JavaScript内置对象之数组</title><link href="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array/" rel="alternate" type="text/html" title="JavaScript内置对象之数组" /><published>2019-11-12T00:00:00+08:00</published><updated>2019-11-12T00:00:00+08:00</updated><id>/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array</id><content type="html" xml:base="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array/">&lt;p&gt;本文为了详细记录JavaScript内置对象中的一些方法&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><summary type="html">本文为了详细记录JavaScript内置对象中的一些方法</summary></entry><entry><title type="html">URL编码</title><link href="/%E5%9F%BA%E7%A1%80/2019/10/16/url-encode/" rel="alternate" type="text/html" title="URL编码" /><published>2019-10-16T00:00:00+08:00</published><updated>2019-10-16T00:00:00+08:00</updated><id>/%E5%9F%BA%E7%A1%80/2019/10/16/url-encode</id><content type="html" xml:base="/%E5%9F%BA%E7%A1%80/2019/10/16/url-encode/">&lt;h3 id=&quot;起因&quot;&gt;起因&lt;/h3&gt;
&lt;p&gt;前几天的时候做了一个领奖的公众号,回调的时候url中会自动带过来一个使用des3加密的orderId, 本来在测试环境的时候是没有问题的,但是到了线上却出现了问题,经过排查发现加密串本来是&lt;code&gt;tq+3wB8PdfY=&lt;/code&gt;, 传到后台的错误结果是&lt;code&gt;tq%203wB8PdfY%3D&lt;/code&gt;,但是真实需要传给后台的却是&lt;code&gt;tq%2B3wB8PdfY%3D&lt;/code&gt;. 因此在这里将该问题总结一下.转载自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/02/url_encoding.html&quot;&gt;关于URL编码&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;需要知道&quot;&gt;需要知道&lt;/h3&gt;
&lt;p&gt;首先需要知道的是一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。比如，世界上有英文字母的网址”http://www.abc.com”，但是没有希腊字母的网址”http://www.aβγ.com”（读作阿尔法-贝塔-伽玛.com）。这是因为网络标准RFC 1738做了硬性规定：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“…Only alphanumerics [0-9a-zA-Z], the special characters “$-_.+!&lt;em&gt;’(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.”
“只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-_.+!&lt;/em&gt;’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这意味着，如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致”URL编码”成为了一个混乱的领域。&lt;/p&gt;

&lt;h3 id=&quot;不同情况下url编码&quot;&gt;不同情况下URL编码&lt;/h3&gt;

&lt;h4 id=&quot;1当汉字出现在url中&quot;&gt;1.当汉字出现在URL中&lt;/h4&gt;
&lt;p&gt;IE现在的使用率的确低,这里出现只为了做对比.
在IE8浏览器中输入网址&lt;code&gt;http://zh.wikipedia.org/wiki/春节&lt;/code&gt;,会怎么样呢?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;我们刚刚说过汉字不可以不编码直接用于url,这里直接用的后果就是不同的浏览器会按照各种的方式进行编码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们查看请求头发现IE实际查询的网址是&lt;code&gt;http://zh.wikipedia.org/wiki/%E6%98%A5%E8%8A%82&lt;/code&gt;, 也就是说IE自动将&lt;code&gt;春节&lt;/code&gt;编码成&lt;code&gt;%E6%98%A5%E8%8A%82&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;“春”和”节”的utf-8编码分别是”E6 98 A5”和”E8 8A 82”，因此，”%E6%98%A5%E8%8A%82”就是按照顺序，在每个字节前加上%而得到的, 网址路径的编码，用的是utf-8编码(FireFox中结果也一样)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;所以当汉字出现在url中的时,网址路径的编码用的时utf-8编码.&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2汉字出现在查询字符串中&quot;&gt;2.汉字出现在查询字符串中&lt;/h4&gt;
&lt;p&gt;在IE8浏览器中输入网址&lt;code&gt;http://www.baidu.com/s?wd=春节&lt;/code&gt;, &lt;code&gt;春节&lt;/code&gt;这两个字此时属于查询字符串，不属于网址路径.
查看http请求头信息,IE将&lt;code&gt;春节&lt;/code&gt;转化成了一个乱码.切换成16进制才能清楚看到这两个字被转成了&lt;code&gt;B4 BA BD DA&lt;/code&gt;
“春”和”节”的GB2312编码（”Windows xp”中文版的默认编码）分别是”B4 BA”和”BD DA”。因此，IE实际上就是将查询字符串，以GB2312编码的格式发送出去。&lt;/p&gt;

&lt;p&gt;Firefox跟Chrome发送的请求头如下, 同样采用GB2312编码，但是在每个字节前加上了%;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;所以查询字符串的编码，用的是操作系统的默认编码。&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;3get方法生成的url包含汉字&quot;&gt;3.Get方法生成的URL包含汉字&lt;/h4&gt;
&lt;p&gt;上面的情况都是直接在浏览器中输入url的情况, 更常见的情况是，在已打开的网页上，直接用Get或Post方法发出HTTP请求。
根据&lt;a href=&quot;http://xml-nchu.blogspot.com/p/url.html&quot;&gt;台湾中兴大学吕瑞麟老师的试验&lt;/a&gt;, 这时的编码方法由网页的编码决定，也就是由HTML源码中字符集的设定决定.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=xxxx&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。&lt;/p&gt;

&lt;p&gt;举例来说，百度是GB2312编码，Google是UTF-8编码。因此，从它们的搜索框中搜索同一个词”春节”，生成的查询字符串是不一样的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;百度生成的是%B4%BA%BD%DA，这是GB2312编码。&lt;/li&gt;
  &lt;li&gt;Google生成的是%E6%98%A5%E8%8A%82，这是UTF-8编码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;GET和POST方法的编码，用的是网页的编码&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;4ajax调用url包含汉字&quot;&gt;4.Ajax调用URL包含汉字&lt;/h4&gt;
&lt;p&gt;前几种情况都是浏览器发送HTTP请求,Ajax是JavaScript来生成HTTP请求,也就是Ajax调用. 这种情况传送给服务器的参数,IE总是采用操作系统默认编码, Chrome则是Utf-8编码.&lt;/p&gt;

&lt;h3 id=&quot;编码解码的方法&quot;&gt;编码解码的方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;escape&lt;/code&gt;跟&lt;code&gt;unescape&lt;/code&gt;,已经不推荐使用. 它的具体规则是，除了ASCII字母、数字、标点符号”@ * _ + - . /”以外，对其他所有字符进行编码。在\u0000到\u00ff之间的符号被转成%xx的形式，其余符号被转成%uxxxx的形式。对应的解码函数是unescape()。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;escape(&quot;春节&quot;);
// %u6625%u8282

escape(&quot;Hello World&quot;);
// Hello%20World

unescape(&quot;%u6625%u8282&quot;)
// 春节

unescape(&quot;\u6625\u8282&quot;)
// 春节

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两个方法不推荐使用.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;encodeURI&lt;/code&gt;是Javascript中真正用来对URL编码的函数。但是对于以下网址中有特殊含义的符号不进行编码.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;; / ? : @ &amp;amp; = + $ , #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相反的&lt;code&gt;encodeURIComponent&lt;/code&gt;方法会将上面的符号也进行编码.
&lt;code&gt;decodeURI&lt;/code&gt;和&lt;code&gt;decodeURIComponent&lt;/code&gt;是相应的解码方法&lt;/p&gt;

&lt;h3 id=&quot;解决&quot;&gt;解决&lt;/h3&gt;
&lt;p&gt;再回到一开始的问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一步浏览器url拿到的查询参数是正确的&lt;code&gt;tq%2B3wB8PdfY%3D&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;第二步代码中获取到的参数变量也是正确的&lt;code&gt;tq+3wB8PdfY=&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;第三部利用该参数向url中拼接跳转下一步页面例如 /xxx/xxx?orderId=tq+3wB8PdfY 到这里其实是有问题的浏览器会自动将&lt;code&gt;+&lt;/code&gt;号转为空格&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;escape()不对”+”编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从这里开始再向后台传参数就不会拿到正确的地址了,其实要解决很简单使用&lt;code&gt;encodeURIComponent&lt;/code&gt;编码一下就可以,其实vue和react的框架其实自己可以转换,但是要正确使用跳转URL的方法.&lt;/p&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u014785687/article/details/74078512&quot;&gt;不同浏览器中URL的编码方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="JavaScript" /><summary type="html">起因 前几天的时候做了一个领奖的公众号,回调的时候url中会自动带过来一个使用des3加密的orderId, 本来在测试环境的时候是没有问题的,但是到了线上却出现了问题,经过排查发现加密串本来是tq+3wB8PdfY=, 传到后台的错误结果是tq%203wB8PdfY%3D,但是真实需要传给后台的却是tq%2B3wB8PdfY%3D. 因此在这里将该问题总结一下.转载自关于URL编码</summary></entry><entry><title type="html">在浏览器输入 URL 回车之后发生了什么</title><link href="/%E9%9D%A2%E8%AF%95/2019/09/16/browser-input-all/" rel="alternate" type="text/html" title="在浏览器输入 URL 回车之后发生了什么" /><published>2019-09-16T00:00:00+08:00</published><updated>2019-09-16T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2019/09/16/browser-input-all</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2019/09/16/browser-input-all/">&lt;p&gt;不久前看了一篇文章&lt;a href=&quot;https://4ark.me/post/b6c7c0a2.html&quot;&gt;在浏览器输入 URL 回车之后发生了什么&lt;/a&gt;, 感觉讲的实在很好所以在此我也想总结一下,当自己被问到这个问题的时候会如何回答呢?&lt;/p&gt;

&lt;p&gt;在浏览器输入 URL 回车之后发生了什么？
大致流程如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.URL解析&lt;/li&gt;
  &lt;li&gt;2.DNS查询；&lt;/li&gt;
  &lt;li&gt;3.建立TCP连接；&lt;/li&gt;
  &lt;li&gt;4.发送HTTP请求；&lt;/li&gt;
  &lt;li&gt;5.服务器处理请求；&lt;/li&gt;
  &lt;li&gt;6.返回响应结果；&lt;/li&gt;
  &lt;li&gt;7.关闭TCP连接；&lt;/li&gt;
  &lt;li&gt;8.浏览器解析HTML；&lt;/li&gt;
  &lt;li&gt;9.浏览器布局渲染；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们在浏览器输入网址回车后,一切从这里开始&lt;/p&gt;
&lt;h3 id=&quot;url解析&quot;&gt;URL解析&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;HSTS(HTTP Strict Transport Security), 强制客户端使用 HTTPS 访问页面&lt;/code&gt;,&lt;a href=&quot;https://www.barretlee.com/blog/2015/10/22/hsts-intro/&quot;&gt;你不知道的HSTS&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先判断你输入的是一个合法的URL还是一个带搜索的关键词&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果输入的是内容则将输入内容自动编码。&lt;/li&gt;
  &lt;li&gt;输入的是网址向服务器请求我们想要的页面内容则开始进行DNS域名查询&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浏览器需要首先确认的是域名所对应的服务器在哪里,将域名解析成对应的服务器IP地址这项工作,是由DNS服务器来完成的.
客户端收到你输入的域名地址后,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.首先会从浏览器缓存中查找是否有对应域名&lt;/li&gt;
  &lt;li&gt;2.操作系统缓存&lt;/li&gt;
  &lt;li&gt;3.路由器DNS缓存&lt;/li&gt;
  &lt;li&gt;4.查找本地的hosts文件&lt;/li&gt;
  &lt;li&gt;5.ISP的DNS服务器&lt;/li&gt;
  &lt;li&gt;6.根域名服务器 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8&quot;&gt;维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;ISP&lt;/code&gt;是&lt;code&gt;Internet Service Provider(因特网服务提供商)&lt;/code&gt;的简称,ISP有专门的DNS服务器应对DNS查询请求.每一个ISP（网络服务提供商），或一个大学，甚至是一个大学里的系都会有一个自己的本地域名服务器，他会在url第一次访问时缓存该域名的指向。下次再访问时，他会从缓存里把这个url曾经指向的IP调出来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，依次类推）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;根域名服务器查询&quot;&gt;根域名服务器查询&lt;/h4&gt;
&lt;p&gt;在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/browser-input/search.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）&lt;/li&gt;
  &lt;li&gt;迭代方式，就是本地DNS服务器到根域名服务器查询的方式。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bisend.cn/blog/dns-ji-chi-yu-wu-ran&quot;&gt;什么是 DNS 劫持&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50043595&quot;&gt;前端 dns-prefetch 优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;递归查询：
    主机向本地域名服务器的查询一般都是采用递归查询。
    如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是返回一个失败的响应，表示无法查询到所需的IP地址&lt;/p&gt;

&lt;p&gt;迭代查询：
    本地域名服务器向根域名服务器的查询通常是采用迭代查询。
    当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。&lt;/p&gt;

&lt;h3 id=&quot;tcp连接&quot;&gt;TCP连接&lt;/h3&gt;
&lt;p&gt;TCP/IP 分四层,在发送数据时,每层都要对数据进行封装&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/browser-input/tcp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;应用层发送http请求&quot;&gt;应用层:发送HTTP请求&lt;/h4&gt;

&lt;p&gt;在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;请求报头（Request Header）：请求方法、目标地址、遵循的协议等等&lt;/li&gt;
  &lt;li&gt;请求主体（其他参数）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中需要注意的点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;传输层-tcp传输报文&quot;&gt;传输层: TCP传输报文&lt;/h4&gt;
&lt;p&gt;传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。&lt;/p&gt;

&lt;p&gt;在建立连接前，会先进行 TCP 三次握手。&lt;a href=&quot;https://github.com/jawil/blog/issues/14&quot;&gt;通俗解释TCP协议三次握手&lt;/a&gt;、&lt;a href=&quot;https://hit-alibaba.github.io/interview/basic/network/HTTP.html&quot;&gt;计算机网络&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/cpcpcp123/article/details/52739407&quot;&gt;SYN 泛洪攻击&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;网络层-ip协议查询mac地址&quot;&gt;网络层: IP协议查询Mac地址&lt;/h4&gt;
&lt;p&gt;将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。
判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/28771785&quot;&gt;ARP 协议&lt;/a&gt;查询它的 Mac 地址。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;注意：在 OSI 参考模型中 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/28771785&quot;&gt;ARP&lt;/a&gt; 协议位于链路层，但在 TCP/IP 中，它位于网络层。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;链路层-以太网协议&quot;&gt;链路层: 以太网协议&lt;/h4&gt;

&lt;p&gt;根据以太网协议将数据分为以”帧”为单位的数据包, 每一帧分为两个部分:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;标头: 数据包的发送者、接受者、数据类型&lt;/li&gt;
  &lt;li&gt;数据: 数据包具体内容&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mac地址
以太网规定了连入网络的所有设备都必须具备“网卡”接口, 数据包都是从一块网卡传递到另一块网卡,网卡地址就是Mac地址.每一个Mac地址都是独一无二的,具备了一对一的能力.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;广播
发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。 但是接受方回应是单播.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;服务器接受请求&quot;&gt;服务器接受请求&lt;/h4&gt;

&lt;h3 id=&quot;服务器处理请求&quot;&gt;服务器处理请求&lt;/h3&gt;

&lt;h4 id=&quot;httpd&quot;&gt;HTTPD&lt;/h4&gt;
&lt;p&gt;最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。
它会监听得到的请求，然后开启一个子进程去处理这个请求。&lt;/p&gt;

&lt;h4 id=&quot;处理请求&quot;&gt;处理请求&lt;/h4&gt;
&lt;p&gt;接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;验证是否配置虚拟主机&lt;/li&gt;
  &lt;li&gt;验证虚拟主机是否接受此方法&lt;/li&gt;
  &lt;li&gt;验证该用户可以使用该方法（根据 IP 地址、身份信息等）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;url重写&quot;&gt;URL重写&lt;/h4&gt;
&lt;p&gt;然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。&lt;/p&gt;

&lt;p&gt;否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。&lt;/p&gt;

&lt;p&gt;然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。&lt;/p&gt;

&lt;p&gt;以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。&lt;/p&gt;

&lt;h3 id=&quot;浏览器接受响应&quot;&gt;浏览器接受响应&lt;/h3&gt;
&lt;p&gt;浏览器接收到来自服务器的响应资源后，会对资源进行分析。&lt;/p&gt;

&lt;p&gt;首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。&lt;/p&gt;

&lt;p&gt;如果响应资源进行了压缩（比如 gzip），还需要进行解压。&lt;/p&gt;

&lt;p&gt;然后，对响应资源做缓存。&lt;/p&gt;

&lt;p&gt;接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。&lt;/p&gt;

&lt;h3 id=&quot;渲染页面&quot;&gt;渲染页面&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/browser-input/core.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/browser-input/process.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://hellogithub2014.github.io/2017/09/24/how-do-network-connect/&quot;&gt;从浏览器输入url按回车后发生了什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50043595&quot;&gt;浏览器探究&amp;amp;前端优化指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28771785&quot;&gt;ARP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bisend.cn/blog/dns-ji-chi-yu-wu-ran&quot;&gt;什么是DNS劫持与DNS污染&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/59ba146c6fb9a00a4636d8b6&quot;&gt;深入理解Http请求、DNS劫持与解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/it_rod/article/details/79939651&quot;&gt;HTTP基础与DNS分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/gopark/p/8430916.html&quot;&gt;DNS原理及其解析过程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://4ark.me/post/b6c7c0a2.html&quot;&gt;在浏览器输入 URL 回车之后发生了什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xsilence/&quot;&gt;DNS查找域名的过程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://fex.baidu.com/blog/2014/05/what-happen/&quot;&gt;从输入 URL 到页面加载完成的过程中都发生了什么事情？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="基础" /><category term="面试" /><category term="HSTS" /><summary type="html">不久前看了一篇文章在浏览器输入 URL 回车之后发生了什么, 感觉讲的实在很好所以在此我也想总结一下,当自己被问到这个问题的时候会如何回答呢?</summary></entry><entry><title type="html">LeetCode刷题总结(简单版五)</title><link href="/leetcode/2019/09/08/leetcode-five/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版五)" /><published>2019-09-08T00:00:00+08:00</published><updated>2019-09-08T00:00:00+08:00</updated><id>/leetcode/2019/09/08/leetcode-five</id><content type="html" xml:base="/leetcode/2019/09/08/leetcode-five/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1两个数组的交集&quot;&gt;1.两个数组的交集&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays/&quot;&gt;两个数组的交集&lt;/a&gt;：
给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输出结果中的每个元素一定是唯一的。&lt;/li&gt;
  &lt;li&gt;我们可以不考虑输出结果的顺序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;自己的解法常规思路不推荐&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    
    let resultDup = [];
    nums1.forEach(val =&amp;gt; {
        nums2.forEach(v =&amp;gt; {
            if(val == v) {
                resultDup.push(val);
            }
        })
    });
    
    let result = [];
    while(resultDup.length &amp;gt; 0) {
        let val = resultDup.shift();
        if(resultDup.indexOf(val) &amp;lt; 0) {
            result.push(val);    
        }
    }

    return result;
    
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样js解法利用Set去重复&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var intersection = function(nums1, nums2) {
    let hash1 = new Set(nums1)
    let hash2 = new Set()

    for(let i = 0; i &amp;lt; nums.length; i++) {
        if(has1.has(nums2[i])) {
            hash2.add(nums2[i])
        }
    }
    return [...hash2]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用数组api解法,更简洁&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var intersection = function(nums1, nums2) {
    return [...new Set(nums1.filter(v =&amp;gt; nums2.includes(v)))];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; class Solution {
     public int[] intersection(int[] nums1, int[] nums2) {
         HashSet&amp;lt;Integer&amp;gt; set1 = new HashSet&amp;lt;Integer&amp;gt;();
         for(Integer n : nums1) set1.add(n);

         HashSet&amp;lt;Integer&amp;gt; set2 = new HashSet&amp;lt;Integer&amp;gt;();
         for(Integer n : nums2) set2.add(n);

         set1.retainAll(set2);

         int[] output = new int[set1.size()];
         int idx = 0;
         for(int s : set) output[idx++] = s;
         return output;

     }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2独一无二的出现次数&quot;&gt;2.独一无二的出现次数&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-number-of-occurrences/&quot;&gt;独一无二的出现次数&lt;/a&gt;: 
 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。&lt;/p&gt;

&lt;p&gt;如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= arr.length &amp;lt;= 1000&lt;/li&gt;
  &lt;li&gt;-1000 &amp;lt;= arr[i] &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：arr = [1,2,2,1,1,3]
输出：true
解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。
示例 2：

输入：arr = [1,2]
输出：false
示例 3：

输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]
输出：true

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-1&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var uniqueOccurrences = function(arr) {
    let objMap = {}
    
    arr.forEach(val =&amp;gt; {
        if(objMap.hasOwnProperty(val)) {
            objMap[val]++;
        } else {
            objMap[val] = 1;
        }
    })
    
    let arr1 = Object.values(objMap);
    let arr2 = [...new Set(arr1)];
    
    return arr1.length === arr2.length;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
        Set&amp;lt;Inetger&amp;gt; set = new HashSet&amp;lt;Integer&amp;gt;();

        for(int data: arr) {
            if(map.get(data) == null) map.put(data,1);
            else map.put(data, map.get(data) + 1);
        }

        for(Integer i : map.values()) {
            if(!set.add(i)) return false;
        }

        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3转置矩阵&quot;&gt;3.转置矩阵&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/transpose-matrix/submissions/&quot;&gt;转置矩阵&lt;/a&gt;: 
给定一个矩阵 A， 返回 A 的转置矩阵。&lt;/p&gt;

&lt;p&gt;矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 1000&lt;/li&gt;
  &lt;li&gt;1 &amp;lt;= A[0].length &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]
示例 2：

输入：[[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var transpose = function(A) {
    let len = A[0].length;
    let alen = A.length;
    let result = [];
    
    for(let i = 0; i &amp;lt; len; i++) {
        let tmpl = [];
        A.forEach((val, idex) =&amp;gt; {
            tmpl.push(val[i]);
        });
        result.push(tmpl);
    }
    
   return result;
    
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4重复-n-次的元素&quot;&gt;4.重复 N 次的元素&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/submissions/&quot;&gt;重复 N 次的元素&lt;/a&gt;:
在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。&lt;/p&gt;

&lt;p&gt;返回重复了 N 次的那个元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[1,2,3,3]
输出：3
示例 2：

输入：[2,1,2,5,3,2]
输出：2
示例 3：

输入：[5,1,5,2,5,3,5,4]
输出：5

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4 &amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= A[i] &amp;lt; 10000&lt;/li&gt;
  &lt;li&gt;A.length 为偶数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} A
 * @return {number}
 */
var repeatedNTimes = function(A) {
    A.sort((a, b) =&amp;gt; a-b);
    let len = A.length;
    let result = 0;
    for(let i = 0; i &amp;lt; len; i++) {
        if(i &amp;gt; 0) {
            let cur = A[i]
            let prev = A[i - 1];
            if(cur - prev === 0) {
                result = cur;
                break;
            }
        }
    }
    return result;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5按奇偶排序数组-ii&quot;&gt;5.按奇偶排序数组 II&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-array-by-parity-ii/&quot;&gt;按奇偶排序数组 II&lt;/a&gt;:
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。&lt;/p&gt;

&lt;p&gt;对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。&lt;/p&gt;

&lt;p&gt;你可以返回任何满足上述条件的数组作为答案。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2 &amp;lt;= A.length &amp;lt;= 20000&lt;/li&gt;
  &lt;li&gt;A.length % 2 == 0&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= A[i] &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParityII = function(A) {
    let len = A.length;
    let oArr = A.filter(val =&amp;gt; (val % 2 !== 0));
    let eArr = A.filter(val =&amp;gt; (val % 2 === 0));
    
    let result = [];
    for(let i = 0; i &amp;lt; len; i++) {
        if(i % 2 === 0) {
            result.push(eArr.shift());
        } else {
            result.push(oArr.shift());
        }
    }
    
    return result;
    
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;java容易理解的解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public static int[] sortArrayByParityII(int[] arr) {
        int len = arr.length;
        if(arr.length &amp;lt; 2) {
            return arr;
        }
        int odd = 1;
        int even = 0;

        while(odd &amp;lt; len &amp;amp;&amp;amp; even &amp;lt; len) {
            while(odd &amp;lt; len &amp;amp;&amp;amp; arr[odd] % 2 != 0){
                odd += 2;
            }

            while(even &amp;lt; len &amp;amp;&amp;amp; arr[even] % 2 == 0){
                even += 2;
            }

            if(odd &amp;lt; len &amp;amp;&amp;amp; even &amp;lt; len) {
                swap(arr, odd, even);
            }
        }
    }

    private static void swap(int[] arr, int odd, int even) {
        int tmp = arr[odd];
        arr[odd] = arr[even];
        arr[even] = tmp;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案三&quot;&gt;答案三&lt;/h4&gt;
&lt;p&gt;js双指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var sortArrayByParityII = function(A) { 
    let len = A.length,
        i = 0,
        j = 1;

    for(; i &amp;lt; len; i += 2) {
        if(A[i] % 2 === 0) continue;
        while(A[j] % 2 === 1);j += 2;

        [A[i], A[j]] = [A[j], A[i]];
    }
    return A;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6单值二叉树&quot;&gt;6.单值二叉树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/univalued-binary-tree/&quot;&gt;单值二叉树&lt;/a&gt;:
如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。&lt;/p&gt;

&lt;p&gt;只有给定的树是单值二叉树时，才返回 true；否则返回 false。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给定树的节点数范围是 [1, 100]。&lt;/li&gt;
  &lt;li&gt;每个节点的值都是整数，范围为 [0, 99] 。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[1,1,1,1,1,null,1]
输出：true
示例 2：

输入：[2,2,2,5,2]
输出：false

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;

&lt;p&gt;更优雅&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        if(root == null) return true;
        return helper(root, root.val);
    }

    private boolean helper(TreeNode root, int val) {
        if(root == null) return true;
        if(val != root.val) return false;
        return helper(root.left, val) &amp;amp;&amp;amp; helper(root.right, val);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    boolean flag = true;
    public boolean isUnivalTree(TreeNode root) {
        if(root == null) {
            return false;
        }
        IsUnivalTree(root, root.val);
        return flag;
    }

    public void IsUnivalTree(TreeNode root, int val) {
        if(root == null) return;
        if(root.val == val) {
            IsunivalTree(root.left, val);
            IsunivalTree(root.right, val);
        } else {
            flag = false;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isUnivalTree = function(root) {
    if(root == null) return true;
    return helper(root, root.val);
};

var helper = function(root, val) {
    if(root == null) return true;
    if(root.val !== val) return false;
    return helper(root.left, val) &amp;amp;&amp;amp; helper(root.right, val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7找出给定方程的正整数解&quot;&gt;7.找出给定方程的正整数解~~~&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/&quot;&gt;找出给定方程的正整数解&lt;/a&gt;:
给出一个函数  f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。&lt;/p&gt;

&lt;p&gt;给定函数是严格单调的，也就是说：&lt;/p&gt;

&lt;p&gt;f(x, y) &amp;lt; f(x + 1, y)&lt;/p&gt;

&lt;p&gt;f(x, y) &amp;lt; f(x, y + 1)
函数接口定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface CustomFunction {
public:
  // Returns positive integer f(x, y) for any given positive integer x and y.
  int f(int x, int y);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想自定义测试，你可以输入整数 function_id 和一个目标结果 z 作为输入，其中 function_id 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 2 个函数。  &lt;/p&gt;

&lt;p&gt;你可以将满足条件的 结果数对 按任意顺序返回。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= function_id &amp;lt;= 9&lt;/li&gt;
  &lt;li&gt;1 &amp;lt;= z &amp;lt;= 100&lt;/li&gt;
  &lt;li&gt;题目保证 f(x, y) == z 的解处于 1 &amp;lt;= x, y &amp;lt;= 1000 的范围内。&lt;/li&gt;
  &lt;li&gt;在 1 &amp;lt;= x, y &amp;lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
示例 1：

输入：function_id = 1, z = 5
输出：[[1,4],[2,3],[3,2],[4,1]]
解释：function_id = 1 表示 f(x, y) = x + y
示例 2：

输入：function_id = 2, z = 5
输出：[[1,5],[5,1]]
解释：function_id = 2 表示 f(x, y) = x * y

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析:题目没有看懂,但是可以读懂代码&lt;/p&gt;

&lt;p&gt;双层循环&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * // This is the CustomFunction's API interface.
 * // You should not implement it, or speculate about its implementation
 * function CustomFunction() {
 *
 *     @param {integer, integer} x, y
 *     @return {integer}
 *     this.f = function(x, y) {
 *         ...
 *     };
 *
 * };
 */
/**
 * @param {CustomFunction} customfunction
 * @param {integer} z
 * @return {integer[][]}
 */

var findSolution = function(customfunction, z) {
    let res = [];
    for(let x = 1; x &amp;lt;= 1000; x++) {
        for(let y = 1; y &amp;lt;= 1000; y++) {
            if(customfunction.f(x, y) &amp;gt; z) {
                break;
            }
            else if(customfunction.f(x, y) === z) {
                let ans = [x, y];
                res.push(ans);
            }
        }   
    }
    return res;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;双指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * // This is the CustomFunction's API interface.
 * // You should not implement it, or speculate about its implementation
 * function CustomFunction() {
 *
 *     @param {integer, integer} x, y
 *     @return {integer}
 *     this.f = function(x, y) {
 *         ...
 *     };
 *
 * };
 */
/**
 * @param {CustomFunction} customfunction
 * @param {integer} z
 * @return {integer[][]}
 */

var findSolution = function(customfunction, z) {
    let res = [];
    let x = 1;
    let y = 1000;
    while(x &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt;= 1000 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt;= 1000) {
        if(customfunction.f(x, y) === z) {
            let ans = [x ,y];
            res.push(ans);
            x++;
        } else if(customfunction.f(x, y) &amp;gt; z) {
            y--;
        } else {
            x++;
        }
    }
    return res;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8excel表列序号&quot;&gt;8.Excel表列序号&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/excel-sheet-column-number/submissions/&quot;&gt;Excel表列序号&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;给定一个Excel表格中的列名称，返回其相应的列序号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如，

    A -&amp;gt; 1
    B -&amp;gt; 2
    C -&amp;gt; 3
    ...
    Z -&amp;gt; 26
    AA -&amp;gt; 27
    AB -&amp;gt; 28 
    ...
示例 1:

输入: &quot;A&quot;
输出: 1
示例 2:

输入: &quot;AB&quot;
输出: 28
示例 3:

输入: &quot;ZY&quot;
输出: 701
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
    let arr = s.split(&quot;&quot;);
    let len = arr.length;
    let i = 1;
    let sum = 0;
    while(i &amp;lt;= len) {
        let num = arr.pop();
        let cur = num.charCodeAt() - 64;
        sum += cur * Math.pow(26, i - 1);
        i++;
    }
    return sum;

};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9反转链表&quot;&gt;9.反转链表&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;反转链表&lt;/a&gt;:
反转一个单链表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例:

输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NUL

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进阶:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;你可以迭代或递归地反转链表。你能否用两种方法解决这道题？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-8&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while(curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public ListNode reverstList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode p = reverstList(head.next);
        head.next.next = head;
        head.next = null;
        return p;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">LeetCode刷题总结(简单版四)</title><link href="/leetcode/2019/09/07/leetcode-four/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版四)" /><published>2019-09-07T00:00:00+08:00</published><updated>2019-09-07T00:00:00+08:00</updated><id>/leetcode/2019/09/07/leetcode-four</id><content type="html" xml:base="/leetcode/2019/09/07/leetcode-four/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1反转字符串中的单词-iii&quot;&gt;1.反转字符串中的单词 III&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/submissions/&quot;&gt;反转字符串中的单词 III&lt;/a&gt;：
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。&lt;/p&gt;

&lt;p&gt;注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1:

输入: &quot;Let's take LeetCode contest&quot;
输出: &quot;s'teL ekat edoCteeL tsetnoc&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    return (s.split(' ').map(val =&amp;gt; val.split('').reverse().join(''))).join(' ');
};

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案二&quot;&gt;答案二&lt;/h4&gt;

&lt;p&gt;稍微有点取巧的做法，reverse函数也可以用双指针实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution 
{
    public String reverseWords(String s) 
    {
        String[] sp=s.split(&quot; &quot;);
        StringBuilder sb=new StringBuilder();
        for(int i=0;i&amp;lt;=sp.length-1;i++)
        {
            StringBuilder t=new StringBuilder();
            t.append(sp[i]);
            sb.append(t.reverse().toString()).append(&quot; &quot;);
        }
        return sb.substring(0,sb.length()-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2反转字符串&quot;&gt;2.反转字符串&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-string/&quot;&gt;反转字符串&lt;/a&gt;:
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。&lt;/p&gt;

&lt;p&gt;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;

&lt;p&gt;你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
示例 2：

输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-1&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;reverse&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    return s.reverse();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;其实本题并不是想考reverse, 感觉应该是想考reverse的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    var len = s.length;
    for(var i = 0, center = Math.floor(len / 2); i &amp;lt; center; i++) {
        let edx = len - i - 1;
        let temp = s[edx];
        s[edx] = s[i];
        s[i] = temp;
    }
    return s;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3数组拆分-i&quot;&gt;3.数组拆分 I&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/array-partition-i/&quot;&gt;数组拆分 I&lt;/a&gt;:
给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。&lt;/p&gt;

&lt;p&gt;提示:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;n 是正整数,范围在 [1, 10000].&lt;/li&gt;
  &lt;li&gt;数组中的元素范围在 [-10000, 10000].&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
示例 1:

输入: [1,4,3,2]

输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;首先排序 ,然后将index为奇数的进行求和.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
    let sortNums = nums.sort((a, b) =&amp;gt; a - b);
    let sum = 0;
    sortNums.forEach(function(val, key) {
      if(key % 2 === 0)  {
          sum += val;
      }
    });
    
    return sum;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4键盘行&quot;&gt;4.键盘行&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/keyboard-row/&quot;&gt;键盘行&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/keyboard.png&quot; alt=&quot;&quot; /&gt;
注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你可以重复使用键盘上同一字符。&lt;/li&gt;
  &lt;li&gt;你可以假设输入的字符串将只包含字母。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]
输出: [&quot;Alaska&quot;, &quot;Dad&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析: 定好map对应关系 两层遍历就可以,可以先取到首字母的指然后判断是否跟首字母相等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(words) {
    let alObj = {
        q: 0,w: 0,e: 0,r: 0, t: 0,y: 0,u: 0,i: 0,q: 0,o: 0,p: 0,
        a: 1,s: 1,d: 1,f: 1,g: 1,h: 1,j: 1,k: 1,l: 1,
        z: 2,x: 2,c: 2,v: 2,b: 2,n: 2,m: 2
    };
    
    let lWords = words.map(val =&amp;gt; val.toLowerCase());
    let leng = lWords.length;
    
    let result = [];
    
    lWords.forEach((str, key) =&amp;gt; {
        let flag = true;    
        let first =  alObj[str.charAt(0)];
        for(let i = 0; i &amp;lt; str.length; i++) {
            let current = alObj[str.charAt(i)];
            if(first !== current) {
                flag = false;
                break;
            }
        }
        if(flag) {
            result.push(words[key]);
        }
    });
    
    return result;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;正则表达式匹配&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var findWords = function(words) {
    let reg1 = new RegExp(&quot;[qwertyuiop]&quot;, &quot;i&quot;);
    let reg2 = new RegExp(&quot;[asdfghjkl]&quot;, &quot;i&quot;);
    let reg3 = new RegExp(&quot;[zxcvbnm]&quot;, &quot;i&quot;);
    let result = [];
    words.forEach(word =&amp;gt; {
        let flag1 = reg1.test(word);
        let flag2 = reg2.test(word);
        let flag3 = reg3.test(word);
        
        if((flag1 &amp;amp;&amp;amp; !flag2 &amp;amp;&amp;amp; !flag3)||(!flag1 &amp;amp;&amp;amp; !flag2 &amp;amp;&amp;amp; flag3)||(!flag1 &amp;amp;&amp;amp; flag2 &amp;amp;&amp;amp; !flag3)){
            result.push(word);
        }
    })

    return result;
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案三&quot;&gt;答案三&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public String[] findWords(String[] workds) {
        if(words == null) {
            return null;
        }

        List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;();

        String[] lines = new String[] {
            &quot;qwertyuiop&quot;,
            &quot;asdfghjkl&quot;,
            &quot;zxcvbnm&quot;
        }

        for(String word: words) {
            if(judge(word.toLowerCase(), lines)) {
                ans.add(word);
            }
        }

        return ans.toArray(new String[ans.size()]);
    }


    private boolean judge(String word, String[] lines) {
        boolean ok = true;
        String find = null;

        for(String line: lines) {
            if(line.indexOf(word.charAt(0)) &amp;gt; -1) {
                find = line;
                break;
            }
        }

        if(find == null) {
            ok = false;
            return ok;
        }

        for(ini i = 1; i &amp;lt; word.length; i++) {
            if(find.indexOf(word.charAt(i)) &amp;lt; 0) {
                ok = false;
                break;
            }
        }
        return ok;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5猜数字&quot;&gt;5.猜数字&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/guess-numbers/&quot;&gt;猜数字&lt;/a&gt;:
小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？
输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。&lt;/p&gt;

&lt;p&gt;限制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;guess的长度 = 3&lt;/li&gt;
  &lt;li&gt;answer的长度 = 3&lt;/li&gt;
  &lt;li&gt;guess的元素取值为 {1, 2, 3} 之一。&lt;/li&gt;
  &lt;li&gt;answer的元素取值为 {1, 2, 3} 之一。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：guess = [1,2,3], answer = [1,2,3]
输出：3
解释：小A 每次都猜对了。
 

示例 2：

输入：guess = [2,2,3], answer = [3,2,1]
输出：1
解释：小A 只猜对了第二次。

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} guess
 * @param {number[]} answer
 * @return {number}
 */
var game = function(guess, answer) {
    return guess.filter((val, key) =&amp;gt; {
        return val === answer[key];
    }).length;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-3&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int game(int[] guess, int[] answer) {
        int count = 0;
        for(int i = 0; i &amp;lt; 3; i++) {
            if(guess[i] == answer[i]) {
                counter++;
            }
        }
        return count;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6删列造序&quot;&gt;6.删列造序&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/delete-columns-to-make-sorted/&quot;&gt;删列造序&lt;/a&gt;:
给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。&lt;/p&gt;

&lt;p&gt;删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。&lt;/p&gt;

&lt;p&gt;比如，有 A = [“abcdef”, “uvwxyz”]，
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/944_1.png&quot; alt=&quot;&quot; /&gt;
要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/944_2.png&quot; alt=&quot;&quot; /&gt;
你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 100&lt;/li&gt;
  &lt;li&gt;1 &amp;lt;= A[i].length &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[&quot;cba&quot;, &quot;daf&quot;, &quot;ghi&quot;]
输出：1
解释：
当选择 D = {1}，删除后 A 的列为：[&quot;c&quot;,&quot;d&quot;,&quot;g&quot;] 和 [&quot;a&quot;,&quot;f&quot;,&quot;i&quot;]，均为非降序排列。
若选择 D = {}，那么 A 的列 [&quot;b&quot;,&quot;a&quot;,&quot;h&quot;] 就不是非降序排列了。
示例 2：

输入：[&quot;a&quot;, &quot;b&quot;]
输出：0
解释：D = {}
示例 3：

输入：[&quot;zyx&quot;, &quot;wvu&quot;, &quot;tsr&quot;]
输出：3
解释：D = {0, 1, 2}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析: 按照题意来说只要满足每一列的字母 b &amp;gt; a 就需要将结果加一.这里使用&lt;code&gt;charCodeAt()&lt;/code&gt;比较&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string[]} A
 * @return {number}
 */
var minDeletionSize = function(A) {
    let len = A.length;
    let leng = A[0].length;
    let result = 0;
    
    for(let j = 0; j &amp;lt; leng; j++) {
        for(let i = 0; i &amp;lt; len - 1; i++) { 
            let prev = A[i].charCodeAt(j);
            let next = A[i+1].charCodeAt(j);
            if(prev &amp;gt; next) {
                result++;
                break;
            }
        }
    }
    return result;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-4&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;跟js解法是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int minDeletionSize(String[] A) {
        int ans = 0;
        for (int c = 0; c &amp;lt; A[0].length(); ++c)
            for (int r = 0; r &amp;lt; A.length - 1; ++r)
                if (A[r].charAt(c) &amp;gt; A[r+1].charAt(c)) {
                    ans++;
                    break;
                }

        return ans;
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7n叉树的最大深度&quot;&gt;7.N叉树的最大深度&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/&quot;&gt; N叉树的最大深度&lt;/a&gt;:
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。&lt;/p&gt;

&lt;p&gt;例如,给定一个&lt;code&gt;3叉树&lt;/code&gt; :
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/narytree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们应返回最大深度,3.&lt;/p&gt;

&lt;p&gt;说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;树的深度不会超过 1000。&lt;/li&gt;
  &lt;li&gt;树的节点总不会超过 5000。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;因为java和JavaScript的解法一样这里我就算做一种.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */
/**
 * @param {Node} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root) {
        return 0;
    }
    if(root.children &amp;amp;&amp;amp; root.children.length &amp;gt; 0) {
        let max = 0;
        for(let i = 0, len = root.children.length; i&amp;lt; len; i++) {
            max = Math.max(maxDepth(root.children[i]), max)
        }
        return max + 1;
    } else {
        return 1;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int maxDeepth(Node node) {
        if(root == null) return 0;
        int max = 0;
        for(int i = 0; i &amp;lt; root.children.size(); i++) {
            max = Math.max(maxDeepth(root.children.get(i)), max);
        }
        return max + 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8-超过经理收入的员工&quot;&gt;8. 超过经理收入的员工&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/&quot;&gt;超过经理收入的员工&lt;/a&gt;: 
Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。&lt;/p&gt;

&lt;p&gt;给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+


+----------+
| Employee |
+----------+
| Joe      |
+----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;
SELECT 
    a.Name AS Employee
FROM Employee AS a,
     Employee AS b
WHERE 
    a.ManagerId = b.Id
    AND a.Salary &amp;gt; b.Salary

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;SELECT 
    a.Name AS Employee
FROM 
    Employee AS a 
JOIN 
    Employee AS b
ON a.ManagerId = b.Id
    AND a.Salary &amp;gt; b.Salary
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9最小差值-i&quot;&gt;9.最小差值 I&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/smallest-range-i/&quot;&gt;最小差值 I&lt;/a&gt;
给定一个整数数组 A，对于每个整数 A[i]，我们可以选择任意 x 满足 -K &amp;lt;= x &amp;lt;= K，并将 x 加到 A[i] 中。&lt;/p&gt;

&lt;p&gt;在此过程之后，我们得到一些数组 B。&lt;/p&gt;

&lt;p&gt;返回 B 的最大值和 B 的最小值之间可能存在的最小差值。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= A[i] &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= K &amp;lt;= 10000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：A = [1], K = 0
输出：0
解释：B = [1]

示例 2：

输入：A = [0,10], K = 2
输出：6
解释：B = [2,8]

示例 3：

输入：A = [1,3,6], K = 3
输出：0
解释：B = [3,3,3] 或 B = [4,4,4]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-8&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析: 这道题目乍一看不容易理解, 其实是这样的我随机从-K到K之间取值保证数组A的最大和最小值的差值最小,也就是说取得最大的最小值和最小的最大值.
那么首先要进行排序从小到大进行排序,然后取出数组A的最小值和最大值,便利K进行求和,再找出其中差值的最小值.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var smallestRangeI = function(A, K) {    
    // 从小到大排序
    A = A.sort((a, b) =&amp;gt; (a - b));
    let len = A.length;
    
    let Af = A[0];
    let Al = A[len - 1];
    
    let M = [];
    for(let i = -K; i &amp;lt;= K; i++) {
        M.push([
            Af + i,
            Al + i
        ]);
        
    }
    let klen = K - (-K) + 1;
    let delNum = M[0][1] - M[klen-1][0];
    return delNum &amp;lt;= 0 ? 0 : delNum;

};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后来看了题解发现本题解的还是不够清晰,这里copy一下题解分析来得到答案二&lt;/p&gt;

&lt;h4 id=&quot;答案二-5&quot;&gt;答案二&lt;/h4&gt;

&lt;p&gt;假设 A 是原始数组，B 是修改后的数组，我们需要最小化 max(B) - min(B)，也就是分别最小化 max(B) 和最大化 min(B)。&lt;/p&gt;

&lt;p&gt;max(B) 最小可能为 max(A) - K，因为 max(A) 不可能再变得更小。同样，min(B) 最大可能为 min(A) + K。所以结果 max(B) - min(B) 至少为 ans = (max(A) - K) - (min(A) + K)。&lt;/p&gt;

&lt;p&gt;我们可以用一下修改方式获得结果（如果 ans &amp;gt;= 0）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 A[i]≤min(A)+K，那么 B[i]=min(A)+K&lt;/li&gt;
  &lt;li&gt;如果 A[i]≥max(A)−K，那么 B[i]=max(A)−K&lt;/li&gt;
  &lt;li&gt;否则 B[i]=A[i]。
如果 ans &amp;lt; 0，最终结果会有 ans = 0，同样利用上面的修改方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int smallestRangeI(int[] A, int K) {
        let min = A[0], max = A[0];
        for(int x : A) {
            min = Math.min(min, x);
            max = Math.max(max, x);
        }
        return Math.max(0, max - min - 2*K);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;10将有序数组转换为二叉搜索树未完成&quot;&gt;10.将有序数组转换为二叉搜索树&lt;code&gt;未完成&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/&quot;&gt;将有序数组转换为二叉搜索树&lt;/a&gt;:
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;

&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-9&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; class Solution {
     public TreeNode sortedArrayToBST(int[] nums) {
         return sortedArrayToBST(nums, 0, nums.length);
     }

     private TreeNode sortedArrayToBST(int[] nums, int start, int end) {
         if(start == end) {
             return null;
         }

         int mid = (start + end) &amp;gt;&amp;gt;&amp;gt; 1;
         TreeNode root = new TreeNode(nums[mid]);
         root.left = sortedArrayToBST(nums, start, mid);
         root.right = sortedArrayToBST(nums, mid + 1, end);

        return root;
     }
 }
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry></feed>