<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-09-14T18:21:17+08:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">Effective JavaScript (六)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/14/read-book-effective-six/" rel="alternate" type="text/html" title="Effective JavaScript (六)" /><published>2018-09-14T00:00:00+08:00</published><updated>2018-09-14T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/14/read-book-effective-six</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/14/read-book-effective-six/">&lt;h2 id=&quot;函数调用&quot;&gt;函数调用&lt;/h2&gt;
&lt;p&gt;理解函数调用， 方法调用，构造函数调用之间的不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
最简单的函数调用
function hello(username) {
	return &quot;hello, &quot; + username;
}

hello(&quot;Keyser soze&quot;);

方法调用
var obj = {
	hello: function() {
		return &quot;hello, &quot; + this.username;
	},
	username: &quot;Hans, Gruber&quot;;
}

obj.hello(); // hello, Hans, Gruber


// 在函数调用过程中由调用表达式自身来确定this变量的绑定。 
  
构造函数调用

function User(name, pass) {
	this.name = name;
	this.pass = pass;
}  

var u = new User(&quot;sketcon&quot;, &quot;123456&quot;);

与函数调用和方法调用不同的是，构造函数调用将一个全新的对象作为this变量的值，并隐式的返回这个对象作为调用结果。
构造函数的主要职责是初始化这个新对象。


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;熟练掌握高阶函数&quot;&gt;熟练掌握高阶函数&lt;/h2&gt;
&lt;p&gt;高阶函数无非就是将函数作为参数或返回值的函数。将函数作为参数通常称为回调函数。&lt;/p&gt;

&lt;h2 id=&quot;使用call方法自定义接收者来调用方法&quot;&gt;使用call方法自定义接收者来调用方法&lt;/h2&gt;
&lt;p&gt;通常情况下，函数或方法的接接收者（即绑定到特殊关键字this的值）是由调用者的语法决定的。但是有时我需要自定义一个接收者，幸运的是函数有一个内置的方法call来自定义接收者。可以通过函数对象的call方法来调用自身。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f.call(obj, arg1, arg2, arg3);

f(arg1, arg2, arg3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同的是第一个参数提供了一个显示的接收者对象。&lt;/p&gt;

&lt;h2 id=&quot;使用apply方法通过不同数量的参数调用函数&quot;&gt;使用apply方法通过不同数量的参数调用函数&lt;/h2&gt;

&lt;p&gt;这里理解有误区，接受一个数组的参数，但是方法调用时将参数依次传入方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;average 函数是一个称为可变参数或可变元的函数（函数的元市值其期望的参数个数）

average(1, 2, 3);

average(1);

average(1, 2, 3, 7, 9);

可变参数的版本更加简洁，优雅。


averageOfArray([1, 2, 3]);

averageOfArray([1]);

averageOfArray([1, 2, 3, 7, 9]);


// 本来average 只接受可变参数，假设我有这样一个数字数组， average函数中没有this引用，所以简单的传null就可以。
var scores = getAllScores();
average.call(null, scores)  
传入一个数组，调用时这样 average(scores[0], scores[1], scores[2])





使用apply方法指定一个可计算的参数数组来调用可变参数的函数。
使用apply方法的第一个参数给可变参数的方法提供一个接收者。

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用arguments创建可变参数的函数&quot;&gt;使用arguments创建可变参数的函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;参数可变函数的实现
function average() {
	for(var i = 0, sum = 0, n = argumants.length; i &amp;lt; n; i++) {
		sum += arguments[i];
	}

	return sum / n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变参数的函数提供了灵活的接口，不同的调用者可以使用不同数量的参数来调用它们，但是它们自身也失去了一点便利。如果使用者要使用数组的参数则只能使用 apply。 
apply方法会降低可读性而且经常导致性能损失&lt;/p&gt;

&lt;p&gt;好的经验是&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果提供了一个便利的可变参数的函数，最好也提供一个需要显示指定数组的固定元数的版本。这样可以编写一个轻量级的封装，并委托固定元数的版本来实现可变参数的函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比较拗口，代码比较直观如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
固定元数的版本实现 用来作为数组参数的调用
function averageOfArray(a) {
	for(var i = 0, sum = 0, n = a.length; i &amp;lt; n; i++) {
		sum += a[i];
	}

	return sum / n;
}

averageOfArray([1, 2, 3]);


参数可变函数的实现可以通过调用 固定元数版本来实现
function average() {
	// averageOfArray本来就支持数组 所以无论average传入数组还是啥
	return averageOfArray(arguments);
}





&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">函数调用 理解函数调用， 方法调用，构造函数调用之间的不同。</summary></entry><entry><title type="html">Effective JavaScript (五)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five/" rel="alternate" type="text/html" title="Effective JavaScript (五)" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five/">&lt;h2 id=&quot;理解变量提升&quot;&gt;理解变量提升&lt;/h2&gt;

&lt;p&gt;try…catch 语句将补货的异常绑定到一个变量，该变量的作用域只是catch语句块。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  function test() {
    var x = &quot;var&quot;, result = [];
    result.push(x);

    try {
      throw &quot;exception&quot;;
    } catch(x) {
      x = &quot;catch&quot;;
    }

    result.push(x);

    return result;
  }

  test(); // [&quot;var&quot;, &quot;var&quot;]
  

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用立即调用函数iife创建局部作用域&quot;&gt;使用立即调用函数IIFE创建局部作用域&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function wrapElements(a) {
  var result = [], i, n;
  for(i = 0, n = a.length; i &amp;lt; n; i++) {
    result[i] = function() { return a[i] }
  }

  return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];

f();  // ? 输出结果 undefined


// 更具有欺骗性的例子
function wrapElements(a) {
  var result = [];
  for(var i = 0, n = a.length; i &amp;lt; n; i++) {
    result[i] = function() { return a[i] }
  }

  return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];


f();  // ? 输出结果 undefined


// 为了避免这种问题需要用一个立即调用的函数创建一个局部作用域

(function() {
  var j = i;
  result[j] = function() { return a[j]; }
})();

// or

(function(j) {
  result[j] = function() { return a[j]; }
})(i);


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;当心命名函数表达式笨拙的作用域&quot;&gt;当心命名函数表达式笨拙的作用域&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function double(x) { return x * 2; }

这里既可以是一个函数声明，也可以是一个命名函数表达式

var f = function(x) { return x * 2; }

var f = function double(x) { return x * 2 }

根据ECMAScript规范， 此语句将该函数绑定到变量f，而不是变量double。

匿名和命名函数表但是的官方区别在于后者会绑定到其函数名相同的变量上，该变量将作为该函数内的一个局部变量。（只能在函数内部调用）可以用来写递归函数表达式

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;命名函数表达式是作用域和兼容性问题臭名昭著的来源，这归结于ECMAScript规范的历史中很不幸的错误以及流行的JavaScript引擎中的Bug. 规范的错误在ES3中就已经存在，JavaScript引擎被要求将命名函数表达式的作用域表示为一个对象，这有点像with，该作用域对象也继承了Object.prototype的属性，这意味着仅仅是给函数表达式命名也会将Object.prototype中的所有属性引入到作用域中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var constructor = function() { return null; }

var f = function f() {
  return constructor();
}

f();  // 结果 {} (in ES3 环境中)。这里错误的使用了Object.prototype.constructor (Object的构造函数)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;幸运的ES5修正了这个问题，但是有些JavaScript仍然使用过时的对象作用域，还有些更不符合标准的对于匿名函数的表达式也使用对象的作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var constructor = function() { return null; }

var f = function () {
  return constructor();
}

f();  // 结果 {} (在更不标准的环境中)。本来这里应该正确解析不使用对象的作用域但是不标准的环境导致匿名函数表达式仍然使用对象作用域

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;最好的做法就是避免任何时候在Object.prototype中添加属性，以及避免使用与标准Object.prototype属性同名的局部变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在流行的JavaScript的引擎中的另一个缺陷是函数命名表达式的声明进行提升。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = g() { returen 17; }
g(); // 17 (在非标准的环境中会返回17，标准环境会报错 g is not defined)

我们应该怎样做
var f = function g() { return 17; }
var g = null;

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于命名函数表达式会导致很多问题，所以不值得使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;当心局部块函数声明笨拙的作用域&quot;&gt;当心局部块函数声明笨拙的作用域&lt;/h2&gt;

&lt;p&gt;比较有迷惑性的一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function f() { return &quot;global&quot;; }

function test(x) {
  function f() { return &quot;local&quot;; }

  var result = [];
  if(x) {
    result.push(f());
  }

  result.push(f());
  return result;
}

// 返回结果
test(true); // [&quot;local&quot;, &quot;local&quot;]
test(false); // [&quot;local&quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当函数f放到局部块里将有什么不同呢，首先要记住一点
 &lt;code&gt;JavaScript没有块级作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function f() { return &quot;global&quot;; }

function test(x) {

  var result = [];
  if(x) {
    function f() { return &quot;local&quot;; }
    result.push(f());
  }
console.log(f);
  result.push(f());
  return result;
}

// 返回结果
test(true); // [&quot;local&quot;, &quot;local&quot;]
test(false); // 有些平台显示[&quot;local&quot;] 有些平台返回： f is not a function

你可能认为 第一个结果为[&quot;local&quot;, &quot;global&quot;], 第二个结果为 [&quot;global&quot;], 但是有一点需要记住 JavaScript没有块级作用域
这里根据平台的实现不同结果会不一样,代码很难理解，还会导致性能降低。 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; 对此官方指定函数声明只能出现在其他函数或者程序的最外层。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;编写可移植的函数最好方式是始终避免将函数声明置于局部块或者子语句中，如果想写嵌套函数声明应该将它置于父函数的最外层。如果要根据条件判断选择函数，最好的方法是使用var声明和函数表达式来实现。例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f() { return &quot;global&quot;; }

function test(x) {

  var g = f, result = [];
  if(x) {
    g = function() { return &quot;local&quot;; }
    result.push(g());
  }
  result.push(g());
  return result;
}

这样消除内部变量作用域的神秘性，结果很明确，函数可移植。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;避免使用eval创建局部变量&quot;&gt;避免使用eval创建局部变量&lt;/h2&gt;

&lt;p&gt;使用eval的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var y = &quot;global&quot;;
function test(x) {
  if(x) {
    eval(&quot;var y = 'local';&quot;);
  }
  return y;
}

test(true); // &quot;local&quot;;
test(false); // &quot;global&quot;

var y = &quot;global&quot;;
function test(src) {
  if(x) {
    eval(src);
  }
  return y;
}

test(&quot;var y = 'local';&quot;); // &quot;local&quot;;
test(&quot;var z = 'local';&quot;); // &quot;global&quot;
这段代码很脆弱，也很不安全，它赋予了外部调用者能改变test函数内部作用域的能力。ES5严格模式将eval函数运行在一个嵌套的作用域中防止这种污染

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;保证eval函数不影响外部作用域的一个简单的方法是一个明确的嵌套作用域中运行它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var y = &quot;global&quot;;
function test(src) {
  if(x) {
    (function() { eval(src); })();
  }
  return y;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;间接调用eval函数由于直接调用&quot;&gt;间接调用eval函数由于直接调用&lt;/h2&gt;
&lt;p&gt;大部分函数只能访问他们所在的作用域，而不能访问除此之外的作用域。然而 eval函数具有访问调用它那时的整个作用域的能力。这是很强大的能力，但是导致一个问题eval很难很高效的调用一个任何函数，因为一旦被调用的是eval函数，那么每个函数调用都需要确保在运行时整个作用域对eval函数是可访问的。&lt;/p&gt;

&lt;p&gt;总而言之我们使用过程中尽可能间接调用eval而不要直接调用。代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f = eval;
f(&quot;x&quot;);

编写间接调用的一种简洁方法是

(0, eval)(src);  // 逗号表达式求值返回eval函数，然后调用。  这种表达式被视为eval的一种间接调用。
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">理解变量提升</summary></entry><entry><title type="html">理解rem布局 (五)</title><link href="/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem/" rel="alternate" type="text/html" title="理解rem布局 (五)" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem</id><content type="html" xml:base="/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem/">&lt;h2 id=&quot;理解变量提升&quot;&gt;理解变量提升&lt;/h2&gt;

&lt;p&gt;JavaScript的一个便利是能够离开 语句结束分号 工作。 删除分号后，结果变得轻量而优雅，比如下面这个例子去掉所有分号，JavaScript会自动插入分号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  function Point(x, y) {
    this.x = x || 0
    this.y = y || 0
  }

  Point.prototype.isOrigin = function() {
    return this.x === 0 &amp;amp;&amp;amp; this.y === 0
  }

&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="页面布局" /><category term="css" /><summary type="html">理解变量提升</summary></entry><entry><title type="html">JAVASCRIPT面试题</title><link href="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js/" rel="alternate" type="text/html" title="JAVASCRIPT面试题" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js/">&lt;h2 id=&quot;使用立即调用函数iife创建局部作用域&quot;&gt;使用立即调用函数IIFE创建局部作用域&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function wrapElements(a) {
	var result = [], i, n;
	for(i = 0, n = a.length; i &amp;lt; n; i++) {
		result[i] = function() { return a[i] }
	}

	return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];

f();  // ? 输出结果 undefined


// 更具有欺骗性的例子
function wrapElements(a) {
	var result = [];
	for(var i = 0, n = a.length; i &amp;lt; n; i++) {
		result[i] = function() { return a[i] }
	}

	return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];


f();  // ? 输出结果 undefined


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在流行的JavaScript的引擎中的另一个缺陷是函数命名表达式的声明进行提升。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = g() { returen 17; }
g(); // 17 (在非标准的环境中，标准环境会报错 g is not defined)


我们应该怎样做
var f = function g() { return 17; }
var g = null;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var username=&quot;test&quot;;

function hello() {
	&quot;use strict&quot;;
	return &quot;hello, &quot; + this.username;
}

hello(); &quot;hello, undefined&quot;

&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="JAVASCRIPT" /><summary type="html">使用立即调用函数IIFE创建局部作用域 ```javascript</summary></entry><entry><title type="html">HTML面试题</title><link href="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html/" rel="alternate" type="text/html" title="HTML面试题" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html/">&lt;h2 id=&quot;html&quot;&gt;HTML&lt;/h2&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="HTML" /><summary type="html">HTML</summary></entry><entry><title type="html">CSS面试题</title><link href="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-css/" rel="alternate" type="text/html" title="CSS面试题" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-css</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-css/">&lt;h2 id=&quot;css&quot;&gt;CSS&lt;/h2&gt;

&lt;p&gt;说出下面s1,s2, s5,s6的答案&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;p1&quot;&amp;gt;
    &amp;lt;div class=&quot;s1&quot;&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;s2&quot;&amp;gt;1&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;p2&quot;&amp;gt;
    &amp;lt;div class=&quot;s5&quot;&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;s6&quot;&amp;gt;1&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

.p1 {font-size: 16px; line-height: 32px;}
.s1 {font-size: 2em;}
.s2 {font-size: 2em; line-height: 2em;}

.p2 {font-size: 16px; line-height: 2;}
.s5 {font-size: 2em;}
.s6 {font-size: 2em; line-height: 2em;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先来看第一组的答案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    p1：font-size: 16px; line-height: 32px
    s1：font-size: 32px; line-height: 32px
    s2：font-size: 32px; line-height: 64px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和你的答案一样吗？下面来解释下:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;p1 无需解释
s1 em作为字体单位，相对于父元素字体大小；line-height继承父元素计算值
s2 em作为行高单位时，相对于自身字体大小
再来看看第二组的答案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;p2：font-size: 16px; line-height: 32px
s5：font-size: 32px; line-height: 64px
s6：font-size: 32px; line-height: 64px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;意不意外？惊不惊喜？下面来解释下&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;p2 line-height: 2自身字体大小的两倍
s5 数字无单位行高，继承原始值，s5的line-height继承的2，自身字体大小的两倍
s6 无需解释&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;清除浮动&quot;&gt;清除浮动&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;.clearfix:after{
  clear: both;
  content: &quot;.&quot;;
  display: block;
  height: 0;
  visibility: hidden;
  font-size: 0;
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="CSS" /><summary type="html">CSS</summary></entry><entry><title type="html">Effective JavaScript (四)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four/" rel="alternate" type="text/html" title="Effective JavaScript (四)" /><published>2018-06-27T00:00:00+08:00</published><updated>2018-06-27T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four/">&lt;h2 id=&quot;了解分号插入的局限性&quot;&gt;了解分号插入的局限性&lt;/h2&gt;

&lt;p&gt;JavaScript的一个便利是能够离开 语句结束分号 工作。 删除分号后，结果变得轻量而优雅，比如下面这个例子去掉所有分号，JavaScript会自动插入分号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  function Point(x, y) {
    this.x = x || 0
    this.y = y || 0
  }

  Point.prototype.isOrigin = function() {
    return this.x === 0 &amp;amp;&amp;amp; this.y === 0
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段没有分号的代码能够工作依赖于JavaScript的&lt;code&gt;自动分号插入技术(automatic semicolon insertion)&lt;/code&gt;, 它是一种程序解析技术。它能够推断出上下文省略的分号，然后有效的将分号自动插入到程序中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;像隐式的强制转换一样，分号插入也有其陷阱，你根本不能避免学习其规则， 即使你从来不省略分号，受分号插入的影响，JavaScript语法也有一些额外的限制。一旦学会分号插入机制，你会从删除不必要的分号的痛苦中解脱出来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;规则一&quot;&gt;规则一&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;分号仅在 } 标记之前、一个或多个换行之后和程序输入的结尾被插入。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  //合法省略分号
  function square(x) {
    var n = +x
    return n * n
  }

  function area(r) { r = +r; return Math.PI * r * r }

  function add1(x) { return x + 1 }

  // 不合法
  function area(r) { r = +r return Math.PI * r * r }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;规则二&quot;&gt;规则二&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;分号进在随后的输入标记不能被解析时插入 , 换句话说分号插入是一种错误矫正机制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  a = b
  (f()); // 这个例子会被解析为 a = b(f()); 所以不会插入分号，因为能够正确解析

  a = b
  f();   // 这个例子会被解析为 a = b f(); 解析有误，所以会插入分号
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;有5个明确有问题的字符需要密切注意&quot;&gt;有5个明确有问题的字符需要密切注意&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(、[、+、-和/&lt;/strong&gt;， 每一个字符都能作为一个表达式运算符或一条语句的前缀， 这依赖于具体上下文。，如果下一行以这五个有问题的字符串之一来时，则不会自动插入分号。向上面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  [&quot;r&quot;, &quot;g&quot;, &quot;b&quot;].forEach(function(key) {
    background[key] = foreground[key] / 2;
  });
  // 这看起来像两条语句但是使用了&amp;lt;code&amp;gt;[&amp;lt;/code&amp;gt;，所以被解析为一条语句
  // 这里例子看起来有点奇怪，但是，JavaScript允许逗号分隔表达式。
  // 逗号分隔表达式从左至右依次执行，并返回最后一个表达式的值。
  a = b[&quot;r&quot;, &quot;g&quot;, &quot;b&quot;].forEach(function(key) {
    background[key] = foreground[key] / 2;
  });

  // /通常作为正则表达式的开始
  /Error/i.test(str) &amp;amp;&amp;amp; fail();

  //这种情况会被解析到一行不会插入分号
  a = b
  /Error/i.test(str) &amp;amp;&amp;amp; fail();

  a = b/Error/i.test(str) &amp;amp;&amp;amp; fail();  //  / 解析为除法运算符


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又一个例子,这是一个完全正确的例子，因为会自动插入分号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  var x
  (f())

  // 但是如果重构时被意外的修改过如下，第二个分号不会插入, 会被错误的解析为 a = b(f())
  var x
  a = b
  (f())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个不幸的结果就是，你总是需要注意省略的分号， 并且检查接下来的一行开始的标记是否会禁用自动插入分号。所以你可以采用在&lt;strong&gt;(、[、+、-和/&lt;/strong&gt;，字符的开始前置一个额外的分号语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  var x
  ;(f())


  var x
  a = b
  ;(f())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个常用的情况就是脚本连接的情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // file1.js
  (function() {

  })()

  // file2.js
  (function() {

  })()

  // 当文件连接到一起时
  (function() {

  })()
  (function() {

  })()

  // 被视为一条单一的语句，等价于：

  (function() {

  })()(function() {

  })();

  // 所以如果文件最开始的语句以这5个字符开始，你应该防御性的给每个前缀一个额外的分号

  // file1.js
  ;(function() {

  })()

  // file2.js
  ;(function() {

  })()

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;最安全的选择就是防御性的增加分号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可能认为 “我从来不省略分号，我会没事的。” 事实并不是这样。也有一些情况，尽管不会出现解析错误，但是也会强制性的插入分号，
这是所谓的JavaScript的语法限制式（restricted production），它不允许两个字符之间存在换行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  return {};    // 返回一个对象

  return  // 这段代码被解析为
  {};

  return;
  {}
  ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的JavaScript的语法限制产生式包括： return, throw, break, continue, 后置自增或自减运算符。
在&lt;code&gt;return, throw, break, continue, ++, --&lt;/code&gt;,参数之前决不能出现换行&lt;/p&gt;

&lt;p&gt;关于自增和自减运算符 是为了避免以下代码出现的歧义，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a
  ++
  b
  // ++既可以作为前置也可以作为后置，但是后置根据语法限制式,不允许a++之间存在换行 所以上面代码解析为

  a; ++b;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;第三条也是最后一条规则&quot;&gt;第三条也是最后一条规则&lt;/h2&gt;
&lt;p&gt;分号不会作为分隔符在for循环空语句头部被自动插入，换言之，for头部里面的&lt;code&gt;;&lt;/code&gt;不能省略，必须显示的包含分号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 下面代码会解析错误
  for(var i = 0, total = 1 // parse error
      i &amp;lt; n
      i++) {
    total *= i
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的 &lt;code&gt;while&lt;/code&gt;，也是需要显示分号的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  function infiniteLoop() { while(true) }  // parse error

  function infiniteLoop() { while(true); }
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">了解分号插入的局限性</summary></entry><entry><title type="html">Effective JavaScript (三)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three/" rel="alternate" type="text/html" title="Effective JavaScript (三)" /><published>2018-06-22T00:00:00+08:00</published><updated>2018-06-22T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three/">&lt;h2 id=&quot;当心隐式的强制转换&quot;&gt;当心隐式的强制转换&lt;/h2&gt;

&lt;p&gt;JavaScript对类型的错误出奇宽容,算数运算符 - 、*、%、/都会把参数转为数字。然而 + 会根据参数来决定
位运算符不仅会将操作数转换为数字，而且还会将操作数转换为32位整数(表示数字的子集)。这些运算符包括算术运算符(~ 、&amp;amp; 、^ 、| 、«、»、»&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  3 + true; // 4
  2 + 3;    // 5
  &quot;2&quot; + 3;  // 23
  &quot;17&quot; * 3; // 51
  &quot;8&quot; | &quot;1&quot; // 9
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;注意nan&quot;&gt;注意NaN&lt;/h2&gt;
&lt;p&gt;NaN不等于其自身，所以测试一个值是否是NaN是行不通的 ，标准库里面的isNaN也是不可靠的，因为它也带有隐式的强制转换，尝试将参数转为数字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var x = NaN;
  x === NaN;  // false

  isNaN(NaN); // true

  // 由于隐式的类型转换所以以下 都会返回true
  isNaN(&quot;foo&quot;);
  isNaN(undefined);
  isNaN({});
  isNaN({ valueOf: &quot;foo&quot; });

  // 由于NaN是不等于其自身的，所以真正正确判断一个参数是否是NaN的方法是判断是否等于自身
  function isReallyNaN(x) {
    return x !== x;
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;对象的隐式转换&quot;&gt;对象的隐式转换&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // 对象转换成字符串
  &quot;the Math object: &quot; + Math; // &quot;the Math object: [object Math]&quot;
  &quot;the JSON object: &quot; + JSON; // &quot;the JSON object: [object JSON]&quot;

  // 对象转换成数字， 对象可以通过valueOf 方法转为数字,你可以控制对象的类型转换

  // 这里讲调用对象的toString 进行拼接
  &quot;J&quot; + { toString: function() { return &quot;S&quot;; } };  // &quot;JS&quot;

  // 通过valueOf将对象转为数字
  2 * { valueOf: function() { return 3; } };       // 6

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个对象同时有toString 和valueOf方法 ，运算符 + 应该调用哪个方法呢，JavaScript通过盲目的选择valueOf方法而不是toString方法来解决这种含糊的情况，这就意味着如果有人打算对一个对象执行字符串连接操作，那么产生的行为会出乎意料&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var obj = {
    toString: function() {
      return &quot;[object MyObject]&quot;;
    },
    valueOf: function() {
      return 17;
    }
  }

  &quot;object: &quot; + obj; // &quot;object: 17&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;这里例子说明，valueOf方法才真正是为那些代表数值的对象(如 Number对象)而设计的。对于这些对象toString 和valueOf方法应返回一致的结果。一般情况下，字符串的强制转换远比数字转换更常见、更有用。 最好避免使用valueOf方法，除非对象的确是一个数字的抽象，并且obj.toString()能产生一个obj.valueOf() 的字符串表示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;真值运算&quot;&gt;真值运算&lt;/h2&gt;
&lt;p&gt;if、||、&amp;amp;&amp;amp;等运算符逻辑上需要布尔值作为操作参数，但实际上可以接受任何值。JavaScript会按照简单的隐式强制转换规则将值解释为布尔值。&lt;/p&gt;

&lt;p&gt;false, 0, -0,””, NaN,null, undefined 外的所有值会转换为false， 其他所有值都为真值。&lt;/p&gt;

&lt;p&gt;因为数字0和字符串”“会转换为false,因此通过隐式转换来判断一个值是否已经定义是不准确的需要通过判断，应该通过以下方式来进行判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  if(typeof x === 'undefined') {}
  if(x === undefined) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;原始类型优于封装对象&quot;&gt;原始类型优于封装对象&lt;/h2&gt;
&lt;p&gt;除了对象之外，JavaScript有5个原始值类型： 布尔值，数字，字符串，null, undefined;
以String为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var s = new String('hello');

  s + &quot;world&quot;;  // &quot;hello world&quot;

  s[4]          // &quot;o&quot;

  typeof &quot;hello&quot; // &quot;string&quot;

  typeof s        // &quot;Object&quot;

  // 每个string都是一个单独的对象其总等于自身，对于非严格相等运算符，结果相同
  var s1 = new String(&quot;hello&quot;);

  var s2 = new String(&quot;hello&quot;);

  s1 === s2; // false

  s1 == s2 // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些封装的行为并不十分正确所以&lt;code&gt;用处不大&lt;/code&gt; ， 其存在的理由是他们的使用方法。例如
隐式封装后会有一个奇怪的结果，你可以对原始类型的值设置属性，但是对其没有丝毫影响.
每次隐式的封装都会产生一个新的String对象 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 每次写这个相当于声明了一个新的对象，更新第一个对象的someProperty不会对第二个对象产生影响&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &quot;hello&quot;.toUpperCase();  // HELLO

  &quot;hello&quot;.someProperty = 17;

  &quot;hello&quot;.someProperty; // undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;避免对混合类型使用运算符&quot;&gt;避免对混合类型使用==运算符&lt;/h2&gt;

&lt;p&gt;下面的表达式的值其实是true， 对于看似无关的值使用==实际是相等的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &quot;1.0e0&quot; == { valueOf: function() { return true } }    // true

  // 理由如下
  Number(&quot;1.0e0&quot;)   // 转换为数字 1

  // 对象调用 valueOf方法返回true， 再转换为数字，得到1

  // 所以结果相等

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用隐式的强制转换做一些事情，但是仍然推荐使用严格模式进行比较。&lt;/p&gt;

&lt;p&gt;例子一, 这个例子使用了隐式的类型转换，跟数字进行比较会将字符串转为数字，从而得到正确的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(form.month.value == (today.getMonth() + 1) &amp;amp;&amp;amp;
    form.day.value == today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子二， 这个例子使用了显示的 Number，或者一元运算符 + 将字符串转为数字, 从而清晰的向大家表达了代码到底在做什么样的转换， 不要求读者记住这些转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(+form.month.value == (today.getMonth() + 1) &amp;amp;&amp;amp;
   +form.day.value == today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子三， 一个更好的例子 使用严格相等运算， 这个过程没有涉及任何转换，读者读起来更加清晰，否则读者需要记住这些强制转换来解读代码的行为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(+form.month.value === (today.getMonth() + 1) &amp;amp;&amp;amp;
    +form.day.value === today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-运算符强制转换规则&quot;&gt;== 运算符强制转换规则&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数类型1&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;参数类型2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;参数类型3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;null&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不转换，总是返回true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;null或undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;其他任何非null或undefined的类型&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不转换，总是返回false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Date对象&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字，将Date对象转换为原始类型（优先尝试toString方法，再尝试valueOf方法）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;非Date对象&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字，将非Date对象转换为原始类型（优先尝试valueOf方法，再尝试toString方法）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;由一张图片引发的思考&quot;&gt;由一张图片引发的思考&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://darknights.b0.upaiyun.com/assets/images/in-post/read-book-effective/js-convert.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;这几个例子很好的验证了上面的隐式类型转换&quot;&gt;这几个例子很好的验证了上面的隐式类型转换&lt;/h2&gt;
&lt;p&gt;首先我们要知道一些前提&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;加法运算符会触发三种类型转换， 将值转为原始类型值， 转换为数字， 转换为字符串， 正好对应引擎内部的三种抽象操作， ToPrimitive(), ToNumber(),ToString()， 一旦得到原始类型的值直接开始进行运算&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;javascript 中的Object, 如果调用valueOf方法默认返回对象本身， 所以无论是{}，还是 []使用valueOf方法都会返回对象本身，得不到原始类型的值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toprimitive&quot;&gt;ToPrimitive&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如果输入的值已经是个原始值,则直接返回它.&lt;/li&gt;
  &lt;li&gt;否则,如果输入的值是一个对象.则调用该对象的valueOf()方法.如果valueOf()方法的返回值是一个原始值,则返回这个原始值.&lt;/li&gt;
  &lt;li&gt;否则,调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.&lt;/li&gt;
  &lt;li&gt;否则,抛出TypeError异常.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tonumber&quot;&gt;ToNumber&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;null&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;+0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;布尔值&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;true被转换为1,false转换为+0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数字&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;无需转换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字符串&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;由字符串解析为数字.例如,”324”被转换为324&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;tostring&quot;&gt;ToString&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;“undefined”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;null&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;“null”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;布尔值&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;true被转换为”true”,false转换为”false”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数字&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;数字作为字符串,比如. “1.765”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字符串&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;无需转换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;举个栗子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var obj = {
    valueOf: function() {
      return {}
    },
    toString: function() {
      return {}
    }
  }

  Number(obj);
  obj + obj;  // TypeError: Cannot convert object to primitive value


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;value1--value2&quot;&gt;value1 + value2&lt;/h2&gt;
&lt;p&gt;这个表达式的计算过程是这样的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一步 将两个操作数转为原始类型的值  Date先调用toString()方法， 非Date先调用 valueOf()&lt;/li&gt;
  &lt;li&gt;第二步 如果其中任意一个是字符串，则将另一个也转为字符串，让后返回两个字符串相加后的结果&lt;/li&gt;
  &lt;li&gt;第三步， 否则将值都转为数字类型然后相加&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  '5' + 1 // '51'
  '5' + true // &quot;5true&quot;
  '5' + false // &quot;5false&quot;
  '5' + {} // &quot;5[object Object]&quot;
  '5' + [] // &quot;5&quot;
  '5' + function (){} // &quot;5function (){}&quot;
  '5' + undefined // &quot;5undefined&quot;
  '5' + null // &quot;5null&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  '5' - '2' // 3
  '5' * '2' // 10
  true - 1  // 0
  false - 1 // -1
  '1' - 1   // 0
  '5' * []    // 0
  false / '5' // 0
  'abc' - 1   // NaN
  null + 1 // 1
  undefined + 1 // NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;图片例子分析&quot;&gt;图片例子分析&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  [] + [] // &quot;&quot;

  首先转原始类型值先调用valueOf方法在调用toString方法，js对象的valueOf()返回对象本身，
  所以调用 toString() 返回的空字符串&quot;&quot;


  [] + {} // &quot;[object Object]&quot;

  首先转原始类型的值，[] 直接转成字符串，按照+运算符规则，其中任意一个字符串，
  则另一个也转为字符串 String({}) =&amp;gt; '[object Object]' 得到最终结果




  {} + {} // &quot;[object Object][object Object]&quot;  or &quot;NaN&quot;

  这个比较特殊JavaScript引擎将第一个{}解释成了一个空的代码块并且忽略了它，
   NaN其实是后面的表达式 +{}的计算结果
   这里的+ 是一元运算符作用是将操作数转为数字 和Number()函数完全一样。 如 +“36.5” =&amp;gt; 36.5

  转换过程如下
  +{}
  Number({}.toString()） // 因为{}.valueOf() 返回对象本身不是原始值
  Number(&quot;[object Object]&quot;)
  最终结果 NaN

  Firefox和Chrome(和Node.js一样使用V8引擎)的解析结果不同.下面的输入会被解析成一个表达式,结果更符合我们的预料

  {} + {} // &quot;[object Object][object Object]&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;为什么第一个{}会被解析成代码块呢?原因是,整个输入被解析成了一个语句,如果一个语句是以左大括号开始的,则这对大括号会被解析成一个代码块.所以,你也可以通过强制把输入解析成一个表达式来修复这样的计算结果:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  ({} + {})
  '[object Object][object Object]'

  同理
  console.log({} + {})
  '[object Object][object Object]'

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过上面的分析过程再来看&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  {} + []  //第一个{}被当成空代码块被忽略
  +[]      // 转数字
  Number(&quot;&quot;)      //  空字符串转为0
  最终结果
  0

  ({} + [])  // &quot;[object Object]&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考文章&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/ziyunfei/archive/2012/09/15/2685885.html&quot;&gt;JavaScript中,{}+{}等于多少?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://github.com/dwqs/blog/issues/17&quot;&gt;你有必要知道的 25 个 JavaScript 面试题&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://javascript.ruanyifeng.com/grammar/conversion.html#toc4&quot;&gt;数据类型转换&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/divd567/article/details/77247773&quot;&gt;JS数据类型转换 - 数字转换&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">当心隐式的强制转换</summary></entry><entry><title type="html">Effective JavaScript (二)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/21/read-book-effective-two/" rel="alternate" type="text/html" title="Effective JavaScript (二)" /><published>2018-06-21T00:00:00+08:00</published><updated>2018-06-21T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/21/read-book-effective-two</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/21/read-book-effective-two/">&lt;h2 id=&quot;理解javascript的浮点数&quot;&gt;理解JavaScript的浮点数&lt;/h2&gt;

&lt;p&gt;大多数编程语言都有多种数据类型，但是Javascript 却只有一种。使用 &lt;code&gt;typeof&lt;/code&gt; 运算符查看无论是 ，整数还是浮点数JavaScript都简单的返回一个结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; typeof 17; // number
 typeof 98.6; // number
 typeof -2.1; // number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上JavaScript中所有的数字都是双精度浮点数。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这是由IEEE 745标准定制的64位编码数字 —即 “doubles”； JavaScript使用双精度浮点数来完美的表达高到53位精度的整数，-2^53次方到2^53次方的所有整数都是有效的双精度浮点数。因此尽管JavaScript中缺少明显的整数类型，但是完全可以进行整数运算。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;位运算比较特殊JavaScript不会直接将操作数作为浮点数进行运算，而是会将其隐式的转换为32位整数后进行运算。以按位或为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;  8 | 1

  00000000000000000000000000001000

  00000000000000000000000000000001

  00000000000000000000000000001001

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将8 和1分别转为32位的二进制序列然后进行运算， 所有的位运算符的工作方式是相同的。他们先将操作数转换为整数，然后使用整数位模式进行运算，最后将结果转换为标准的JavaScript浮点数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;浮点数的运算需要时刻保持警惕，因为它们出了名的不精确，甚至一些看起来最简单的算术运算都会产生不正确的结果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; 0.1 + 0.2;  // 0.30000000000000004
 // 实数满足结合律 即实数 x, y, z 总是满足 (x + y) + z = x + (y + z); 但是对于浮点数来说却不总是这样

  (0.1 + 0.2) + 0.3  // 0.6000000000000001

  0.1 + (0.2 + 0.3) // 0.6

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;浮点数权衡了精度和性能。当我们关心精度时，要小心浮点数的局限性。一个有效的解决方法是尽可能采用整数值运算，因为整数在表示时不需要舍入。只需要担心范围符合 -2^53 到 2^53的整数&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">理解JavaScript的浮点数</summary></entry><entry><title type="html">Effective JavaScript(一)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/19/read-book-effective-one/" rel="alternate" type="text/html" title="Effective JavaScript(一)" /><published>2018-06-19T00:00:00+08:00</published><updated>2018-06-19T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/19/read-book-effective-one</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/19/read-book-effective-one/">&lt;h2 id=&quot;了解你使用的javascript版本&quot;&gt;了解你使用的JavaScript版本&lt;/h2&gt;

&lt;p&gt;由于不同的浏览器，对于JS的实现不同，我们必须精心编写代码保证他们在所有浏览器下工作如一。否则你可能面临这样的困境–应用程序在你自己的计算机上运行良好，但是部署到不同的环境时却无法运行。
例如，const关键字在支持非标准特性的JavaScript引擎上测试时运行良好，但是当将它部署到不识别const关键字的web浏览器上就会出现语法错误。
为此，ES5引入了一种版本控制的考量&lt;code&gt;严格模式&lt;/code&gt;。此特性允许你选择在受限制的JavaScript版本中禁止使用一些JavaScript语言中问题较多或者易于出错的特性。
由于其语法设计向后兼容，因此即使在那些没有实现严格模式检查的环境中仍然可以执行严格代码（strict code）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&quot;use strict&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该指令只有定义到脚本或函数的顶部才能生效。需要注意的是脚本连接时可能会将非严格模式脚本运行到严格模式下如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&quot;use strict&quot;;
function f() {}

// no strict-mode
function g() {
  var arguments = [];
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种情况会报错，为了解决这个问题，我们通常会使用 立即调用的函数表达式(IIFE Immediately Invoked Function Expression) 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function(){
  &quot;use strict&quot;;
  function f() {}
})();

(function(){
  function g() {
    var arguments = [];
  }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;编写文件使其在两种模式下行为一致&quot;&gt;编写文件使其在两种模式下行为一致&lt;/h2&gt;
&lt;p&gt;想要编写一个库来获得最大的兼容性最简单的方法就是在严格模式下编写代码，并显示的将代码内容包裹在本地启用了严格模式的函数中，这种类似前面所说的 将库文件包裹到一个立即调用的函数表达式中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; (function(){
  &quot;use strict&quot;
  function g() {
    var arguments = [];
  }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;为了达到更普遍的兼容性建议在严格模式下编写代码。&lt;/code&gt;&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">了解你使用的JavaScript版本</summary></entry></feed>