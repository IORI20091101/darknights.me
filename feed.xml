<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-09-21T18:11:45+08:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">Effective JavaScript (七)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/19/read-book-effective-seven/" rel="alternate" type="text/html" title="Effective JavaScript (七)" /><published>2018-09-19T00:00:00+08:00</published><updated>2018-09-19T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/19/read-book-effective-seven</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/19/read-book-effective-seven/">&lt;h2 id=&quot;理解prototypegetprototypeof-和__proto__之间的不同&quot;&gt;理解prototype,getPrototypeOf 和__proto__之间的不同&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function User(name, passwordHash) {
	this.name = name;
	this.passwordHash = passwordHash;
}

User.prototype.toString = function() {
	return &quot;[User &quot; + this.name + &quot; ]&quot;;
};

User.prototype.checkPassword = function(password) {
	return hash(password) === this.passwordHash;
};

var u = new User(&quot;sfalken&quot;, &quot;objjowewe&quot;);

// ES5 提供了Obejct.getPrototypeOf() 来获得对象的原型
Object.getPrototypeOf(u) === User.prototype // true

非标准的环境提供一个特殊的__proto__属性，在这些环境下可以这样检测
u.__proto__ === User.prototype // true


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用objectgetprototypeof的函数而不要使用__proto__属性&quot;&gt;使用Object.getPrototypeOf的函数而不要使用__proto__属性&lt;/h2&gt;
&lt;p&gt;并不是所有的JavaScript环境都支持通过__proto__属性来获取对象的原型，因此该属性并不是完全兼容的。由于__proto__会污染所有的对象，因此它会导致大量的Bug。&lt;/p&gt;

&lt;p&gt;但是无论在什么情况下 &lt;code&gt;Object.getPrototypeOf&lt;/code&gt;函数都是有效的。&lt;/p&gt;

&lt;p&gt;对于没有提供ES5 API的JavaScript环境，我们可以利用__proto__属性来实现Object.getPrototypeOf的函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(typeof Object.getPrototypeOf === 'undefined') {
	Object.getPrototypeOf = function(obj) {
		var t = typeof obj;
		if(!obj || (t !== 'object' &amp;amp;&amp;amp; t !== 'function')) {
			throw new TypeError(&quot;not an object&quot;);
		}

		return obj.__proto__;
	};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;始终不要修改__ptoto__属性&quot;&gt;始终不要修改__ptoto__属性&lt;/h2&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;避免修改__proto__属性的最明显原因是可移植问题。毕竟不是所有平台都支持&lt;/li&gt;
  &lt;li&gt;避免修改__proto__属性的另一个原因是性能问题&lt;/li&gt;
  &lt;li&gt;避免修改__proto__属性的最大原因是为了保持行为的可预测性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用ES5中的Object.create函数创建一个具有自定义原型链的新对象。对于不支持的ES5环境下下面有一种不依赖于__proto__可移植的实现。&lt;/p&gt;

&lt;h2 id=&quot;使用构造函数与new操作符无关&quot;&gt;使用构造函数与new操作符无关&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function User(name, passwordHash) {
	this.name = name;
	this.passwordHash = passwordHash;
}
如果使用new操作符调用构造函数会是实例化一个对象，不使用new函数的接收者将是全局对象。


var u = User(&quot;hello&quot;, &quot;pass&quot;);

u; // undefined
this.name // &quot;hello&quot;
this.passwordHash // &quot;pass&quot;

如果User定为ES5的严格代码，那么它的接收者默认为undefined

function User(name, passwordHash) {
	'use strict';
	this.name = name;
	this.passwordHash = passwordHash;
}
var u = User(&quot;hello&quot;, &quot;pass&quot;);

// error this is undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以无论是否用new都可以使用构造函数，为了保证代码的健壮性最好是提供一个不管怎样都会工作的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function User(name, pass) {
	if(!(this instanceof User)) {
		return new User(name, pass);
	}

	this.name = name;
	this.pass = pass;
}

var x = User(&quot;hello&quot;, &quot;pas1&quot;);

var y = new User(&quot;hel&quot;, &quot;pas2&quot;);

x instanceof User // true

y instanceof User // true



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式不管怎样调用构造函数都会返回一个继承了User.prototype的实例对象。	
这种模式的缺点是有一次额外的函数调用，ES5有一种更奇异的调用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function User(name, pass) {
	var self = this instanceof User
		? this
		: Obejct.create(User.prototype);

	self.name = name;
	self.pass = pass;
	return self;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式只有在ES5中才可以使用，对于不支持的环境，我们可以制造一个兼容性的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这里只实现了单参数版本的Object.create
if(typeof Object.creat === 'undefined') {
	Object.create = function(prototype) {
		function C() {}
		C.prototype = prototype;
		return new C();
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;在原型中存储方法&quot;&gt;在原型中存储方法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;将方法存储到实例对象中将创建该函数的多个副本，因为每个实例对象都有一份副本&lt;/li&gt;
  &lt;li&gt;将方法存储于原型中优于存储在实例对象中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用闭包存储私有变量&quot;&gt;使用闭包存储私有变量&lt;/h2&gt;
&lt;p&gt;闭包将数据存储到封闭的变量中而不提供对这些变量的直接访问，获取闭包内容结构的唯一方式是该函数显示的提供获取它的途径。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;对象和闭包剧哟相反的策略，对象的属性会被自动暴露出去，然而闭包中的变量会被自动隐藏起来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以利用这一特性在对象中存储真正的私有数据。不是将数据作为对象属性来存储而是在构造函数中以变量的方式来存储它，并将对象的方法转为引用这些变量的闭包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function User(name, passwordHash) {
	this.toString = function() {
		return &quot;[User &quot; + name +&quot;]&quot;;
	}
	this.checkPassword = function(password) {
		return hash(password) === passwordHash;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里name和passwordHash并不是以this的属性存储的，读取不到this.name 和this.passwordHash， User不包含任何实例属性。
该模式有一个缺点为了让构造函数的变量 在使用它们的方法的作用域中，这些方法必须置于实例对象中。 因此违背了上一条&lt;code&gt;在原型中存储方法&lt;/code&gt;
但是为了那些看中保障信息隐藏的情形来说，这点额外代价是值得的&lt;/p&gt;

&lt;h2 id=&quot;在子类的构造函数中调用父类的构造函数&quot;&gt;在子类的构造函数中调用父类的构造函数&lt;/h2&gt;
&lt;p&gt;如果正确构建父子级关系的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Actor(scene, x, y) {
	this.scene = scene;
	this.x = x;
	this.y = y;
	scene.register(this);
}

Actor.prototype.moveTo = function(x, y) {
	this.x = x;
	this.y = y;
	this.scene.draw();
}

Actor.prototype.exit = function() {
	this.scene.unregister(this);
	this.scene.draw();
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们要创建一个Actor的一个子类， 名字为SpaceShip怎么办&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function SpaceShip(scene, x, y) {
	Actor.call(this, scene, x, y);  
	// 这里SpaceShip的实例对象作为方法的接收者，会将Actor的实例属性加到SpaceShip的实例上，从而继承了Actor的实例属性

	this.points = {};
}

Actor.prototype.moveTo = function(x, y) {
	this.x = x;
	this.y = y;
	this.scene.draw();
}

Actor.prototype.exit = function() {
	this.scene.unregister(this);
	this.scene.draw();
}

如何继承Actor的prototype中的方法呢，我们可以使用之前提到过的ES5下的 
Object.create(非ES5需要自己实现Object.create)

SpaceShip.prototype = Object.create(Actor.prototype);

这样就很好的实现了继承


&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">理解prototype,getPrototypeOf 和__proto__之间的不同</summary></entry><entry><title type="html">函数柯里化</title><link href="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2018/09/17/js-base-currying/" rel="alternate" type="text/html" title="函数柯里化" /><published>2018-09-17T00:00:00+08:00</published><updated>2018-09-17T00:00:00+08:00</updated><id>/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2018/09/17/js-base-currying</id><content type="html" xml:base="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2018/09/17/js-base-currying/">&lt;h2 id=&quot;js-函数柯里化&quot;&gt;JS 函数柯里化&lt;/h2&gt;
&lt;p&gt;什么是函数柯里化？ 柯里化通常也称部分求值，其含义是给函数分步传递参数。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个简单的函数柯里化例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var add = function(x, y) {
	return x + y;
}

add(1, 2);

var addCurry = function(x) {
	return function(y) {
		return x + y;
	}
}

addCurry(1)(2);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子是一个最简单的柯里化例子， 现在又有新的需要我需要能传多个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var add = function(items) {
	return items.reduce(function(a, b) {
		return a + b;
	});
}

add([1, 2, 3, 4]);

但如果要求把每个数乘以10之后再相加，那么：

var add = function(items, multi) {

	return items.map(function(item) {
		return item * multi
	}).reduce(function(a, b) {
		return a + b;
	})

}

console.log(add([1, 2, 3, 4], 10));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是柯里化实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var adder = function() {
	var _args = [];
	return function() {
		if(arguments.length === 0) {
			return _args.reduce(function(a, b) {
				return a + b;
			});
		}

		[].push.apply(args, [].slice.call(arguments))

		return arguments.callee;
	}
}


var sum = adder();

console.log(sum);

sum(100, 200)(300);   // 调用形式灵活， 一次调用可输入一个或多个参数， 并且支持链式调用

sum(400);

console.log(sum());  // 没有参数进行加总计算

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;adder是柯里化了的函数，它返回一个新的函数，新的函数接收可分批次接受新的参数，延迟到最后一次计算。&lt;/p&gt;

&lt;p&gt;通用的柯里化函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var currying = function(fn) {
	var _args = [];
	return function() {
		if(arguments.length === 0) {
			return fn.apply(this, _args);
		}

		Array.prototype.push.apply(_args, [].slice.call(arguments));
		return arguments.callee;
	}
}

var multi = function() {
	var total = 0;
	for(var i = 0, c = arguments.length; i &amp;lt; c; i++) {
		total += c;
	}

	// for一个特别骚的写法
	for(var i = 0, c; c = arguments[i++];) {
		total += c;
	}

	return total;
}

var sum = currying(multi);

sum(100, 200)(300);
sum(400);

console.log(sum());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码其实是一个高阶函数。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;高阶函数是指操作函数的函数，它接受一个或者多个函数作为参数，并返回一个新函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此外还依赖闭包的特性，来保存中间过程中输入的参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;函数可以作为参数传递&lt;/li&gt;
  &lt;li&gt;函数能够作为函数的返回值&lt;/li&gt;
  &lt;li&gt;闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;柯里化的作用&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;延迟计算&lt;/li&gt;
  &lt;li&gt;参数复用， 当在多次调用同一个函数，并且传递的参数绝大多数相同，那么该函数可能是一个很好的柯里化候选&lt;/li&gt;
  &lt;li&gt;动态创建函数， 这可以是在部分计算出结果后，在此基础上动态生成新的函数处理后面的业务，这样省略了计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如一个绑定事件的辅助方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var addEvent = function(el, type, fn, capture) {
	if(window.addEventListener) {
		el.addEventListener(type, function(e) {
			fn.call(el, e);
		}, capture);
	} else if(window.attachEvent) {
		el.attachEvent(&quot;on&quot;+type, function(e) {
			fn.call(el, e);
		})
	}
}

每次添加事件处理都要执行一遍 if...else...，其实在一个浏览器中只要一次判定就可以了，把根据一次判定之后的结果动态生成新的函数，以后就不必重新计算。

var addEvent = (function(){
    if (window.addEventListener) {
        return function(el, sType, fn, capture) {
            el.addEventListener(sType, function(e) {
                fn.call(el, e);
            }, (capture));
        };
    } else if (window.attachEvent) {
        return function(el, sType, fn, capture) {
            el.attachEvent(&quot;on&quot; + sType, function(e) {
                fn.call(el, e);
            });
        };
    }
})();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Function.prototype.bind 方法也是柯里化应用&lt;/p&gt;

&lt;p&gt;与 call/apply 方法直接执行不同，bind 方法 将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = {x: 888};
var bar = function () {
    console.log(this.x);
}.bind(foo);               // 绑定
bar();                     // 888

// 猜测bind的实现

Function.prototype.testBind = function (scope) {
    var fn = this;                    //// this 指向的是调用 testBind 方法的一个函数， 
    return function () {
        return fn.apply(scope);
    }
};
var testBindBar = bar.testBind(foo);  // 绑定 foo，延迟执行
console.log(testBindBar);             // Function (可见，bind之后返回的是一个延迟执行的新函数)
testBindBar();                        // 888

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来看这道面试题
编程题目的要求如下，完成plus函数，通过全部的测试用例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;'use strict';
function plus(n){
  
}
module.exports = plus



'use strict';
var assert = require('assert')

var plus = require('../lib/assign-4')

describe('闭包应用',function(){
  it('plus(0) === 0',function(){
    assert.equal(0,plus(0).toString())
  })
  it('plus(1)(1)(2)(3)(5) === 12',function(){
    assert.equal(12,plus(1)(1)(2)(3)(5).toString())
  })
  it('plus(1)(4)(2)(3) === 10',function(){
    assert.equal(10,plus(1)(4)(2)(3).toString())
  })
  it('方法引用',function(){
    var plus2 = plus(1)(1)
    assert.equal(12,plus2(1)(4)(2)(3).toString())
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
'use strict';
function plus(num){
	var adder = function() {
		var _args = [];

		var _adder = function () {
			[].push.apply(_args, [].slice.call(arguments));
			return _adder;
		}

		_adder.toString = function() {
			return _args.reduce(function(a, b) {
				return a + b;
			});
		}	

		return _adder;
	}

	
	return adder()(num);
  
}


module.exports = plus;

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zztt/p/4142891.html#3078374&quot;&gt;函数 currying 柯里化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="计算机基础" /><category term="javascript" /><summary type="html">JS 函数柯里化 什么是函数柯里化？ 柯里化通常也称部分求值，其含义是给函数分步传递参数。 curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</summary></entry><entry><title type="html">Effective JavaScript (六)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/14/read-book-effective-six/" rel="alternate" type="text/html" title="Effective JavaScript (六)" /><published>2018-09-14T00:00:00+08:00</published><updated>2018-09-14T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/14/read-book-effective-six</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/14/read-book-effective-six/">&lt;h2 id=&quot;函数调用&quot;&gt;函数调用&lt;/h2&gt;
&lt;p&gt;理解函数调用， 方法调用，构造函数调用之间的不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
最简单的函数调用
function hello(username) {
	return &quot;hello, &quot; + username;
}

hello(&quot;Keyser soze&quot;);

方法调用
var obj = {
	hello: function() {
		return &quot;hello, &quot; + this.username;
	},
	username: &quot;Hans, Gruber&quot;;
}

obj.hello(); // hello, Hans, Gruber


// 在函数调用过程中由调用表达式自身来确定this变量的绑定。 
  
构造函数调用

function User(name, pass) {
	this.name = name;
	this.pass = pass;
}  

var u = new User(&quot;sketcon&quot;, &quot;123456&quot;);

与函数调用和方法调用不同的是，构造函数调用将一个全新的对象作为this变量的值，并隐式的返回这个对象作为调用结果。
构造函数的主要职责是初始化这个新对象。


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;熟练掌握高阶函数&quot;&gt;熟练掌握高阶函数&lt;/h2&gt;
&lt;p&gt;高阶函数无非就是将函数作为参数或返回值的函数。将函数作为参数通常称为回调函数。&lt;/p&gt;

&lt;h2 id=&quot;使用call方法自定义接收者来调用方法&quot;&gt;使用call方法自定义接收者来调用方法&lt;/h2&gt;
&lt;p&gt;通常情况下，函数或方法的接接收者（即绑定到特殊关键字this的值）是由调用者的语法决定的。但是有时我需要自定义一个接收者，幸运的是函数有一个内置的方法call来自定义接收者。可以通过函数对象的call方法来调用自身。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f.call(obj, arg1, arg2, arg3);

f(arg1, arg2, arg3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同的是第一个参数提供了一个显示的接收者对象。&lt;/p&gt;

&lt;h2 id=&quot;使用apply方法通过不同数量的参数调用函数&quot;&gt;使用apply方法通过不同数量的参数调用函数&lt;/h2&gt;

&lt;p&gt;这里理解有误区，接受一个数组的参数，但是方法调用时将参数依次传入方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;average 函数是一个称为可变参数或可变元的函数（函数的元市值其期望的参数个数）

average(1, 2, 3);

average(1);

average(1, 2, 3, 7, 9);

可变参数的版本更加简洁，优雅。


averageOfArray([1, 2, 3]);

averageOfArray([1]);

averageOfArray([1, 2, 3, 7, 9]);


// 本来average 只接受可变参数，假设我有这样一个数字数组， average函数中没有this引用，所以简单的传null就可以。
var scores = getAllScores();
average.apply(null, scores)  
传入一个数组，调用时这样 average(scores[0], scores[1], scores[2])





使用apply方法指定一个可计算的参数数组来调用可变参数的函数。
使用apply方法的第一个参数给可变参数的方法提供一个接收者。

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用arguments创建可变参数的函数&quot;&gt;使用arguments创建可变参数的函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;参数可变函数的实现
function average() {
	for(var i = 0, sum = 0, n = argumants.length; i &amp;lt; n; i++) {
		sum += arguments[i];
	}

	return sum / n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变参数的函数提供了灵活的接口，不同的调用者可以使用不同数量的参数来调用它们，但是它们自身也失去了一点便利。如果使用者要使用数组的参数则只能使用 apply。 
apply方法会降低可读性而且经常导致性能损失&lt;/p&gt;

&lt;p&gt;好的经验是&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果提供了一个便利的可变参数的函数，最好也提供一个需要显示指定数组的固定元数的版本。这样可以编写一个轻量级的封装，并委托固定元数的版本来实现可变参数的函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比较拗口，代码比较直观如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
固定元数的版本实现 用来作为数组参数的调用
function averageOfArray(a) {
	for(var i = 0, sum = 0, n = a.length; i &amp;lt; n; i++) {
		sum += a[i];
	}

	return sum / n;
}

averageOfArray([1, 2, 3]);


参数可变函数的实现可以通过调用 固定元数版本来实现
function average() {
	// averageOfArray本来就支持数组 所以无论average传入数组还是啥
	return averageOfArray(arguments);
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;永远不要修改arguments对象&quot;&gt;永远不要修改arguments对象&lt;/h2&gt;
&lt;p&gt;不要修改arguments对象，并且将arguments对象复制到一个真正的数组中再进行调整。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
	add: function(x, y) { return x + y; }
}

function callMethod(obj, method) {
	var shift = [].shift;
	shift.call(arguments);
	shift.call(arguments);

	return obj[method].apply(obj, arguments);
}

callMethod(obj, &quot;add&quot;, 17, 25);  // cannot read property &quot;apply&quot; of undefined   17[25]

这里的arguments 对象并不是函数参数的副本，所有命名参数都是arguments对象中对应索引的别名。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;永远不要修改arguments对象是更为安全的，通过一开始复制参数中的元素到一个真正的数组的方式，很容易避免修改arguments对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var args = [].slice.call(argumants);

slice会复制整个数组，其结果是一个真正的标准Array类型实例。

function callMethod(obj, method) {
	var args = [].slice.call(arguments, 2);
	return obj[method].apply(obj, args);
}

callMethod(obj, &quot;add&quot;, 17, 25);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用变量保存arguments的引用&quot;&gt;使用变量保存arguments的引用&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// 实现一个迭代器


function values() {
	var i = 0, n = arguments.length;
	return {
		hasNext: function() {
			return i &amp;lt; n;
		},
		next: function() {
			if(i &amp;gt;= n) {
				throw new Error(&quot;end of iteration&quot;);
			}
			return arguments[i++]; // wrong arguments;
		}
	}
}

var it = values(1, 2, 3, 5, 78);

it.next(); //undefined

it.next(); //undefined

it.next(); //undefined

每次调用next的时候，next方法内部会存在一个arguments这里可能我们关心的只是values的arguments, 所以正确的方法是将values的arguments保存下来

function values() {
	var i = 0, n = arguments.length, arg = arguments;
	return {
		hasNext: function() {
			return i &amp;lt; n;
		},
		next: function() {
			if(i &amp;gt;= n) {
				throw new Error(&quot;end of iteration&quot;);
			}
			return arg[i++];
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用bind方法提取具有确定接收者的方法&quot;&gt;使用bind方法提取具有确定接收者的方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var buffer = {
	entries: [],
	add: function(s) {
		this.entries.push(s);
	},
	concat: function() {
		return this.entries.join(&quot;&quot;);
	}
}

var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];

source.forEach(buffer.add);  // error: entries is undefined


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;buffer.add 方法的接收者并不是buffer对象，函数的接收者取决于它是如何被调用，
不过我们并没有调用它，而是把它传给了forEach方法
而我们并不知道forEach在哪里调用了它，事实上forEach方法的实现使用全局对象作为默认的接收者。由于全局对象没有entries属性所以这段代码抛出了一个错误。
幸运的是forEach允许调用者提供一个可选的参数作为回调函数的接收者，所以我们可以很轻松的修复该例子。&lt;/p&gt;

&lt;p&gt;方法一&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];

source.forEach(buffer.add, buffer); 


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并非所有的高阶函数都会为使用者提供其毁掉函数的接收者。如果forEach不接受额外的接收者参数怎么办&lt;/p&gt;

&lt;p&gt;方法二&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source.forEach(function(s) {
	buffer.add(s);
});

bujjer.join();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个函数用来实现绑定其接收者到一个指定的对象是非常常见的，因此ES5标准库直接支持这种模式，函数对象的bind方法需要一个接收者对象，并产生一个以该接收者对象的方法调用的方式调用原来的函数的封装函数。&lt;/p&gt;

&lt;p&gt;方法三&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];

source.forEach(buffer.add.bind(buffer)); 


buffer.add.bind(buffer) 创建了一个新函数而不是修改了bufffer.add函数 该函数将接收者绑定到了buffer对象，而原有函数的接收者保持不变

buffer.add === buffer.add.bind(buffer);  // false;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用bind实现函数柯里化&quot;&gt;使用bind实现函数柯里化&lt;/h2&gt;
&lt;p&gt;函数对象的bind方法除了具有降方法绑定到接收者的用途外，它还有更多功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function simpleURL(protocol, domain, path) {
	return protocol + &quot;://&quot; + domain + &quot;/&quot; + path;
}

var urls = paths.map(function(path) {
	return simpleURL(&quot;http&quot;, siteDomain, path);
});


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传给simpleURL的前两个参数是固定的， 只有第三个参数在变化，我们可以通过调用simpleURL函数的bind方法来自动构造该匿名函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var urls = path.map(simpleURL.bind(null, &quot;http&quot;, siteDomain));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对simpleURL.bind的调用产生了一个委托到simpleURL的新函数，bind的第一个参数提供了接收者的值， 由于simpleURL.bind不需要引用this，所以可以使用任何值。使用null和undefined是习惯用法。 simpleURL.bind的其余参数和提供给你新函数的所有参数共同组成了传递给simpleURL的参数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将函数与其参数的一个子集绑定的技术称为函数柯里化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;不要信赖函数对象的tostring方法&quot;&gt;不要信赖函数对象的toString方法&lt;/h2&gt;

&lt;p&gt;JavaScript有一个非凡的特性， 即将其源代码重现为字符串的能力&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function(x) { 
	return x + 1 
}).toString();

// &quot;function (x) {\n return x + 1; \n}&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECMAScript标准对于函数对象的toString方法的返回结果并没有任何要求。这意味着不同的JavaScript引擎将产生不同的结果，甚至产生的字符串跟函数并不相关。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(x) { 
	return x + 1 
}).bind(16).toString();

// &quot;function (x) {\n [native code] \n}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于bind函数通常是由其他语言实现的通常c++，宿主提供一个编译后的函数，在此环境下通常没有源代码可展示。&lt;/p&gt;

&lt;p&gt;还有一点就是 toString方法生成的源代码并不展示闭包中保存的和内部变量引用相关的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function(x) {
	return function(y) {
		return x + y;
	}	
})(42).toString();

// &quot;function(y) {\n return x + y; \n }&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;总而言之，应该避免使用函数对象的toString方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;避免使用非标准的栈检查属性&quot;&gt;避免使用非标准的栈检查属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;arguments.callee 指向使用该arguments对象被调用的函数&lt;/li&gt;
  &lt;li&gt;arguments.caller 指向调用该arugments对象的函数（该arguments对象调用函数的函数）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;出于安全考虑大多环境移除了arguments.caller,因此它是不可靠的&lt;/p&gt;

&lt;p&gt;许多JavaScript环境提供了一个相似的函数对象属性—非标准但是普遍适用的caller属性。 它指向函数最近的调用者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function revealCaller() {
	return revealCaller.caller;
}

function start() {
	return revealCaller();
}

start() === start;  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;ES5的严格模式禁止使用arguments.caller 和arguments.callee ，因为它们不具备良好的可移植性， 非标准的函数对象caller属性应该避免使用，因为在包含全部栈信息方面，它是不可靠的。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">函数调用 理解函数调用， 方法调用，构造函数调用之间的不同。</summary></entry><entry><title type="html">Effective JavaScript (五)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five/" rel="alternate" type="text/html" title="Effective JavaScript (五)" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five/">&lt;h2 id=&quot;理解变量提升&quot;&gt;理解变量提升&lt;/h2&gt;

&lt;p&gt;try…catch 语句将补货的异常绑定到一个变量，该变量的作用域只是catch语句块。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  function test() {
    var x = &quot;var&quot;, result = [];
    result.push(x);

    try {
      throw &quot;exception&quot;;
    } catch(x) {
      x = &quot;catch&quot;;
    }

    result.push(x);

    return result;
  }

  test(); // [&quot;var&quot;, &quot;var&quot;]
  

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用立即调用函数iife创建局部作用域&quot;&gt;使用立即调用函数IIFE创建局部作用域&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function wrapElements(a) {
  var result = [], i, n;
  for(i = 0, n = a.length; i &amp;lt; n; i++) {
    result[i] = function() { return a[i] }
  }

  return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];

f();  // ? 输出结果 undefined


// 更具有欺骗性的例子
function wrapElements(a) {
  var result = [];
  for(var i = 0, n = a.length; i &amp;lt; n; i++) {
    result[i] = function() { return a[i] }
  }

  return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];


f();  // ? 输出结果 undefined


// 为了避免这种问题需要用一个立即调用的函数创建一个局部作用域

(function() {
  var j = i;
  result[j] = function() { return a[j]; }
})();

// or

(function(j) {
  result[j] = function() { return a[j]; }
})(i);


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;当心命名函数表达式笨拙的作用域&quot;&gt;当心命名函数表达式笨拙的作用域&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function double(x) { return x * 2; }

这里既可以是一个函数声明，也可以是一个命名函数表达式

var f = function(x) { return x * 2; }

var f = function double(x) { return x * 2 }

根据ECMAScript规范， 此语句将该函数绑定到变量f，而不是变量double。

匿名和命名函数表但是的官方区别在于后者会绑定到其函数名相同的变量上，该变量将作为该函数内的一个局部变量。（只能在函数内部调用）可以用来写递归函数表达式

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;命名函数表达式是作用域和兼容性问题臭名昭著的来源，这归结于ECMAScript规范的历史中很不幸的错误以及流行的JavaScript引擎中的Bug. 规范的错误在ES3中就已经存在，JavaScript引擎被要求将命名函数表达式的作用域表示为一个对象，这有点像with，该作用域对象也继承了Object.prototype的属性，这意味着仅仅是给函数表达式命名也会将Object.prototype中的所有属性引入到作用域中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var constructor = function() { return null; }

var f = function f() {
  return constructor();
}

f();  // 结果 {} (in ES3 环境中)。这里错误的使用了Object.prototype.constructor (Object的构造函数)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;幸运的ES5修正了这个问题，但是有些JavaScript仍然使用过时的对象作用域，还有些更不符合标准的对于匿名函数的表达式也使用对象的作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var constructor = function() { return null; }

var f = function () {
  return constructor();
}

f();  // 结果 {} (在更不标准的环境中)。本来这里应该正确解析不使用对象的作用域但是不标准的环境导致匿名函数表达式仍然使用对象作用域

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;最好的做法就是避免任何时候在Object.prototype中添加属性，以及避免使用与标准Object.prototype属性同名的局部变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在流行的JavaScript的引擎中的另一个缺陷是函数命名表达式的声明进行提升。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = g() { returen 17; }
g(); // 17 (在非标准的环境中会返回17，标准环境会报错 g is not defined)

我们应该怎样做
var f = function g() { return 17; }
var g = null;

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于命名函数表达式会导致很多问题，所以不值得使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;当心局部块函数声明笨拙的作用域&quot;&gt;当心局部块函数声明笨拙的作用域&lt;/h2&gt;

&lt;p&gt;比较有迷惑性的一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function f() { return &quot;global&quot;; }

function test(x) {
  function f() { return &quot;local&quot;; }

  var result = [];
  if(x) {
    result.push(f());
  }

  result.push(f());
  return result;
}

// 返回结果
test(true); // [&quot;local&quot;, &quot;local&quot;]
test(false); // [&quot;local&quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当函数f放到局部块里将有什么不同呢，首先要记住一点
 &lt;code&gt;JavaScript没有块级作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function f() { return &quot;global&quot;; }

function test(x) {

  var result = [];
  if(x) {
    function f() { return &quot;local&quot;; }
    result.push(f());
  }
console.log(f);
  result.push(f());
  return result;
}

// 返回结果
test(true); // [&quot;local&quot;, &quot;local&quot;]
test(false); // 有些平台显示[&quot;local&quot;] 有些平台返回： f is not a function

你可能认为 第一个结果为[&quot;local&quot;, &quot;global&quot;], 第二个结果为 [&quot;global&quot;], 但是有一点需要记住 JavaScript没有块级作用域
这里根据平台的实现不同结果会不一样,代码很难理解，还会导致性能降低。 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; 对此官方指定函数声明只能出现在其他函数或者程序的最外层。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;编写可移植的函数最好方式是始终避免将函数声明置于局部块或者子语句中，如果想写嵌套函数声明应该将它置于父函数的最外层。如果要根据条件判断选择函数，最好的方法是使用var声明和函数表达式来实现。例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f() { return &quot;global&quot;; }

function test(x) {

  var g = f, result = [];
  if(x) {
    g = function() { return &quot;local&quot;; }
    result.push(g());
  }
  result.push(g());
  return result;
}

这样消除内部变量作用域的神秘性，结果很明确，函数可移植。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;避免使用eval创建局部变量&quot;&gt;避免使用eval创建局部变量&lt;/h2&gt;

&lt;p&gt;使用eval的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var y = &quot;global&quot;;
function test(x) {
  if(x) {
    eval(&quot;var y = 'local';&quot;);
  }
  return y;
}

test(true); // &quot;local&quot;;
test(false); // &quot;global&quot;

var y = &quot;global&quot;;
function test(src) {
  if(x) {
    eval(src);
  }
  return y;
}

test(&quot;var y = 'local';&quot;); // &quot;local&quot;;
test(&quot;var z = 'local';&quot;); // &quot;global&quot;
这段代码很脆弱，也很不安全，它赋予了外部调用者能改变test函数内部作用域的能力。ES5严格模式将eval函数运行在一个嵌套的作用域中防止这种污染

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;保证eval函数不影响外部作用域的一个简单的方法是一个明确的嵌套作用域中运行它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var y = &quot;global&quot;;
function test(src) {
  if(x) {
    (function() { eval(src); })();
  }
  return y;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;间接调用eval函数由于直接调用&quot;&gt;间接调用eval函数由于直接调用&lt;/h2&gt;
&lt;p&gt;大部分函数只能访问他们所在的作用域，而不能访问除此之外的作用域。然而 eval函数具有访问调用它那时的整个作用域的能力。这是很强大的能力，但是导致一个问题eval很难很高效的调用一个任何函数，因为一旦被调用的是eval函数，那么每个函数调用都需要确保在运行时整个作用域对eval函数是可访问的。&lt;/p&gt;

&lt;p&gt;总而言之我们使用过程中尽可能间接调用eval而不要直接调用。代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f = eval;
f(&quot;x&quot;);

编写间接调用的一种简洁方法是

(0, eval)(src);  // 逗号表达式求值返回eval函数，然后调用。  这种表达式被视为eval的一种间接调用。
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">理解变量提升</summary></entry><entry><title type="html">理解rem布局</title><link href="/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem/" rel="alternate" type="text/html" title="理解rem布局" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem</id><content type="html" xml:base="/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem/">&lt;h2 id=&quot;理解变量提升&quot;&gt;理解变量提升&lt;/h2&gt;

&lt;p&gt;JavaScript的一个便利是能够离开 语句结束分号 工作。 删除分号后，结果变得轻量而优雅，比如下面这个例子去掉所有分号，JavaScript会自动插入分号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  function Point(x, y) {
    this.x = x || 0
    this.y = y || 0
  }

  Point.prototype.isOrigin = function() {
    return this.x === 0 &amp;amp;&amp;amp; this.y === 0
  }

&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="页面布局" /><category term="css" /><summary type="html">理解变量提升</summary></entry><entry><title type="html">JAVASCRIPT面试题</title><link href="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js/" rel="alternate" type="text/html" title="JAVASCRIPT面试题" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js/">&lt;h2 id=&quot;使用立即调用函数iife创建局部作用域&quot;&gt;使用立即调用函数IIFE创建局部作用域&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function wrapElements(a) {
	var result = [], i, n;
	for(i = 0, n = a.length; i &amp;lt; n; i++) {
		result[i] = function() { return a[i] }
	}

	return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];

f();  // ? 输出结果 undefined


// 更具有欺骗性的例子
function wrapElements(a) {
	var result = [];
	for(var i = 0, n = a.length; i &amp;lt; n; i++) {
		result[i] = function() { return a[i] }
	}

	return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];


f();  // ? 输出结果 undefined


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在流行的JavaScript的引擎中的另一个缺陷是函数命名表达式的声明进行提升。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = g() { returen 17; }
g(); // 17 (在非标准的环境中，标准环境会报错 g is not defined)


我们应该怎样做
var f = function g() { return 17; }
var g = null;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var username=&quot;test&quot;;

function hello() {
	&quot;use strict&quot;;
	return &quot;hello, &quot; + this.username;
}

hello(); &quot;hello, undefined&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bind绑定方法接收者，下面例子返回什么结果， 用尽可能多的方法修复该例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var buffer = {
	entries: [],
	add: function(s) {
		this.entries.push(s);
	},
	concat: function() {
		return this.entries.join(&quot;&quot;);
	}
}

var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];

source.forEach(buffer.add);  // error: entries is undefined


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;什么时候函数柯里化？柯里化的作用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;延迟计算&lt;/li&gt;
  &lt;li&gt;参数复用， 当在多次调用同一个函数，并且传递的参数绝大多数相同，那么该函数可能是一个很好的柯里化候选&lt;/li&gt;
  &lt;li&gt;动态创建函数， 这可以是在部分计算出结果后，在此基础上动态生成新的函数处理后面的业务，这样省略了计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数柯里化 一道有难度的面试题,完成plus函数 满足通过所有的测试条件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
'use strict';
function plus(n){
  
}
module.exports = plus


'use strict';
var assert = require('assert')

var plus = require('../lib/assign-4')

describe('闭包应用',function(){
  it('plus(0) === 0',function(){
    assert.equal(0,plus(0).toString())
  })
  it('plus(1)(1)(2)(3)(5) === 12',function(){
    assert.equal(12,plus(1)(1)(2)(3)(5).toString())
  })
  it('plus(1)(4)(2)(3) === 10',function(){
    assert.equal(10,plus(1)(4)(2)(3).toString())
  })
  it('方法引用',function(){
    var plus2 = plus(1)(1)
    assert.equal(12,plus2(1)(4)(2)(3).toString())
  })
})
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="JAVASCRIPT" /><summary type="html">使用立即调用函数IIFE创建局部作用域 ```javascript</summary></entry><entry><title type="html">HTML面试题</title><link href="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html/" rel="alternate" type="text/html" title="HTML面试题" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html/">&lt;h2 id=&quot;html&quot;&gt;HTML&lt;/h2&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="HTML" /><summary type="html">HTML</summary></entry><entry><title type="html">CSS面试题</title><link href="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-css/" rel="alternate" type="text/html" title="CSS面试题" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-css</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-css/">&lt;h2 id=&quot;css&quot;&gt;CSS&lt;/h2&gt;

&lt;p&gt;说出下面s1,s2, s5,s6的答案&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;p1&quot;&amp;gt;
    &amp;lt;div class=&quot;s1&quot;&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;s2&quot;&amp;gt;1&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;p2&quot;&amp;gt;
    &amp;lt;div class=&quot;s5&quot;&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;s6&quot;&amp;gt;1&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

.p1 {font-size: 16px; line-height: 32px;}
.s1 {font-size: 2em;}
.s2 {font-size: 2em; line-height: 2em;}

.p2 {font-size: 16px; line-height: 2;}
.s5 {font-size: 2em;}
.s6 {font-size: 2em; line-height: 2em;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先来看第一组的答案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    p1：font-size: 16px; line-height: 32px
    s1：font-size: 32px; line-height: 32px
    s2：font-size: 32px; line-height: 64px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和你的答案一样吗？下面来解释下:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;p1 无需解释
s1 em作为字体单位，相对于父元素字体大小；line-height继承父元素计算值
s2 em作为行高单位时，相对于自身字体大小
再来看看第二组的答案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;p2：font-size: 16px; line-height: 32px
s5：font-size: 32px; line-height: 64px
s6：font-size: 32px; line-height: 64px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;意不意外？惊不惊喜？下面来解释下&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;p2 line-height: 2自身字体大小的两倍
s5 数字无单位行高，继承原始值，s5的line-height继承的2，自身字体大小的两倍
s6 无需解释&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;清除浮动&quot;&gt;清除浮动&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;.clearfix:after{
  clear: both;
  content: &quot;.&quot;;
  display: block;
  height: 0;
  visibility: hidden;
  font-size: 0;
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="CSS" /><summary type="html">CSS</summary></entry><entry><title type="html">Effective JavaScript (四)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four/" rel="alternate" type="text/html" title="Effective JavaScript (四)" /><published>2018-06-27T00:00:00+08:00</published><updated>2018-06-27T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/27/read-book-effective-four/">&lt;h2 id=&quot;了解分号插入的局限性&quot;&gt;了解分号插入的局限性&lt;/h2&gt;

&lt;p&gt;JavaScript的一个便利是能够离开 语句结束分号 工作。 删除分号后，结果变得轻量而优雅，比如下面这个例子去掉所有分号，JavaScript会自动插入分号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  function Point(x, y) {
    this.x = x || 0
    this.y = y || 0
  }

  Point.prototype.isOrigin = function() {
    return this.x === 0 &amp;amp;&amp;amp; this.y === 0
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段没有分号的代码能够工作依赖于JavaScript的&lt;code&gt;自动分号插入技术(automatic semicolon insertion)&lt;/code&gt;, 它是一种程序解析技术。它能够推断出上下文省略的分号，然后有效的将分号自动插入到程序中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;像隐式的强制转换一样，分号插入也有其陷阱，你根本不能避免学习其规则， 即使你从来不省略分号，受分号插入的影响，JavaScript语法也有一些额外的限制。一旦学会分号插入机制，你会从删除不必要的分号的痛苦中解脱出来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;规则一&quot;&gt;规则一&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;分号仅在 } 标记之前、一个或多个换行之后和程序输入的结尾被插入。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  //合法省略分号
  function square(x) {
    var n = +x
    return n * n
  }

  function area(r) { r = +r; return Math.PI * r * r }

  function add1(x) { return x + 1 }

  // 不合法
  function area(r) { r = +r return Math.PI * r * r }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;规则二&quot;&gt;规则二&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;分号进在随后的输入标记不能被解析时插入 , 换句话说分号插入是一种错误矫正机制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  a = b
  (f()); // 这个例子会被解析为 a = b(f()); 所以不会插入分号，因为能够正确解析

  a = b
  f();   // 这个例子会被解析为 a = b f(); 解析有误，所以会插入分号
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;有5个明确有问题的字符需要密切注意&quot;&gt;有5个明确有问题的字符需要密切注意&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(、[、+、-和/&lt;/strong&gt;， 每一个字符都能作为一个表达式运算符或一条语句的前缀， 这依赖于具体上下文。，如果下一行以这五个有问题的字符串之一来时，则不会自动插入分号。向上面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  [&quot;r&quot;, &quot;g&quot;, &quot;b&quot;].forEach(function(key) {
    background[key] = foreground[key] / 2;
  });
  // 这看起来像两条语句但是使用了&amp;lt;code&amp;gt;[&amp;lt;/code&amp;gt;，所以被解析为一条语句
  // 这里例子看起来有点奇怪，但是，JavaScript允许逗号分隔表达式。
  // 逗号分隔表达式从左至右依次执行，并返回最后一个表达式的值。
  a = b[&quot;r&quot;, &quot;g&quot;, &quot;b&quot;].forEach(function(key) {
    background[key] = foreground[key] / 2;
  });

  // /通常作为正则表达式的开始
  /Error/i.test(str) &amp;amp;&amp;amp; fail();

  //这种情况会被解析到一行不会插入分号
  a = b
  /Error/i.test(str) &amp;amp;&amp;amp; fail();

  a = b/Error/i.test(str) &amp;amp;&amp;amp; fail();  //  / 解析为除法运算符


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又一个例子,这是一个完全正确的例子，因为会自动插入分号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  var x
  (f())

  // 但是如果重构时被意外的修改过如下，第二个分号不会插入, 会被错误的解析为 a = b(f())
  var x
  a = b
  (f())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个不幸的结果就是，你总是需要注意省略的分号， 并且检查接下来的一行开始的标记是否会禁用自动插入分号。所以你可以采用在&lt;strong&gt;(、[、+、-和/&lt;/strong&gt;，字符的开始前置一个额外的分号语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a = b
  var x
  ;(f())


  var x
  a = b
  ;(f())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个常用的情况就是脚本连接的情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // file1.js
  (function() {

  })()

  // file2.js
  (function() {

  })()

  // 当文件连接到一起时
  (function() {

  })()
  (function() {

  })()

  // 被视为一条单一的语句，等价于：

  (function() {

  })()(function() {

  })();

  // 所以如果文件最开始的语句以这5个字符开始，你应该防御性的给每个前缀一个额外的分号

  // file1.js
  ;(function() {

  })()

  // file2.js
  ;(function() {

  })()

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;最安全的选择就是防御性的增加分号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可能认为 “我从来不省略分号，我会没事的。” 事实并不是这样。也有一些情况，尽管不会出现解析错误，但是也会强制性的插入分号，
这是所谓的JavaScript的语法限制式（restricted production），它不允许两个字符之间存在换行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  return {};    // 返回一个对象

  return  // 这段代码被解析为
  {};

  return;
  {}
  ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的JavaScript的语法限制产生式包括： return, throw, break, continue, 后置自增或自减运算符。
在&lt;code&gt;return, throw, break, continue, ++, --&lt;/code&gt;,参数之前决不能出现换行&lt;/p&gt;

&lt;p&gt;关于自增和自减运算符 是为了避免以下代码出现的歧义，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  a
  ++
  b
  // ++既可以作为前置也可以作为后置，但是后置根据语法限制式,不允许a++之间存在换行 所以上面代码解析为

  a; ++b;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;第三条也是最后一条规则&quot;&gt;第三条也是最后一条规则&lt;/h2&gt;
&lt;p&gt;分号不会作为分隔符在for循环空语句头部被自动插入，换言之，for头部里面的&lt;code&gt;;&lt;/code&gt;不能省略，必须显示的包含分号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 下面代码会解析错误
  for(var i = 0, total = 1 // parse error
      i &amp;lt; n
      i++) {
    total *= i
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的 &lt;code&gt;while&lt;/code&gt;，也是需要显示分号的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  function infiniteLoop() { while(true) }  // parse error

  function infiniteLoop() { while(true); }
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">了解分号插入的局限性</summary></entry><entry><title type="html">Effective JavaScript (三)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three/" rel="alternate" type="text/html" title="Effective JavaScript (三)" /><published>2018-06-22T00:00:00+08:00</published><updated>2018-06-22T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/06/22/read-book-effective-three/">&lt;h2 id=&quot;当心隐式的强制转换&quot;&gt;当心隐式的强制转换&lt;/h2&gt;

&lt;p&gt;JavaScript对类型的错误出奇宽容,算数运算符 - 、*、%、/都会把参数转为数字。然而 + 会根据参数来决定
位运算符不仅会将操作数转换为数字，而且还会将操作数转换为32位整数(表示数字的子集)。这些运算符包括算术运算符(~ 、&amp;amp; 、^ 、| 、«、»、»&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  3 + true; // 4
  2 + 3;    // 5
  &quot;2&quot; + 3;  // 23
  &quot;17&quot; * 3; // 51
  &quot;8&quot; | &quot;1&quot; // 9
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;注意nan&quot;&gt;注意NaN&lt;/h2&gt;
&lt;p&gt;NaN不等于其自身，所以测试一个值是否是NaN是行不通的 ，标准库里面的isNaN也是不可靠的，因为它也带有隐式的强制转换，尝试将参数转为数字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var x = NaN;
  x === NaN;  // false

  isNaN(NaN); // true

  // 由于隐式的类型转换所以以下 都会返回true
  isNaN(&quot;foo&quot;);
  isNaN(undefined);
  isNaN({});
  isNaN({ valueOf: &quot;foo&quot; });

  // 由于NaN是不等于其自身的，所以真正正确判断一个参数是否是NaN的方法是判断是否等于自身
  function isReallyNaN(x) {
    return x !== x;
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;对象的隐式转换&quot;&gt;对象的隐式转换&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // 对象转换成字符串
  &quot;the Math object: &quot; + Math; // &quot;the Math object: [object Math]&quot;
  &quot;the JSON object: &quot; + JSON; // &quot;the JSON object: [object JSON]&quot;

  // 对象转换成数字， 对象可以通过valueOf 方法转为数字,你可以控制对象的类型转换

  // 这里讲调用对象的toString 进行拼接
  &quot;J&quot; + { toString: function() { return &quot;S&quot;; } };  // &quot;JS&quot;

  // 通过valueOf将对象转为数字
  2 * { valueOf: function() { return 3; } };       // 6

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个对象同时有toString 和valueOf方法 ，运算符 + 应该调用哪个方法呢，JavaScript通过盲目的选择valueOf方法而不是toString方法来解决这种含糊的情况，这就意味着如果有人打算对一个对象执行字符串连接操作，那么产生的行为会出乎意料&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var obj = {
    toString: function() {
      return &quot;[object MyObject]&quot;;
    },
    valueOf: function() {
      return 17;
    }
  }

  &quot;object: &quot; + obj; // &quot;object: 17&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;这里例子说明，valueOf方法才真正是为那些代表数值的对象(如 Number对象)而设计的。对于这些对象toString 和valueOf方法应返回一致的结果。一般情况下，字符串的强制转换远比数字转换更常见、更有用。 最好避免使用valueOf方法，除非对象的确是一个数字的抽象，并且obj.toString()能产生一个obj.valueOf() 的字符串表示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;真值运算&quot;&gt;真值运算&lt;/h2&gt;
&lt;p&gt;if、||、&amp;amp;&amp;amp;等运算符逻辑上需要布尔值作为操作参数，但实际上可以接受任何值。JavaScript会按照简单的隐式强制转换规则将值解释为布尔值。&lt;/p&gt;

&lt;p&gt;false, 0, -0,””, NaN,null, undefined 外的所有值会转换为false， 其他所有值都为真值。&lt;/p&gt;

&lt;p&gt;因为数字0和字符串”“会转换为false,因此通过隐式转换来判断一个值是否已经定义是不准确的需要通过判断，应该通过以下方式来进行判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  if(typeof x === 'undefined') {}
  if(x === undefined) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;原始类型优于封装对象&quot;&gt;原始类型优于封装对象&lt;/h2&gt;
&lt;p&gt;除了对象之外，JavaScript有5个原始值类型： 布尔值，数字，字符串，null, undefined;
以String为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var s = new String('hello');

  s + &quot;world&quot;;  // &quot;hello world&quot;

  s[4]          // &quot;o&quot;

  typeof &quot;hello&quot; // &quot;string&quot;

  typeof s        // &quot;Object&quot;

  // 每个string都是一个单独的对象其总等于自身，对于非严格相等运算符，结果相同
  var s1 = new String(&quot;hello&quot;);

  var s2 = new String(&quot;hello&quot;);

  s1 === s2; // false

  s1 == s2 // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些封装的行为并不十分正确所以&lt;code&gt;用处不大&lt;/code&gt; ， 其存在的理由是他们的使用方法。例如
隐式封装后会有一个奇怪的结果，你可以对原始类型的值设置属性，但是对其没有丝毫影响.
每次隐式的封装都会产生一个新的String对象 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 每次写这个相当于声明了一个新的对象，更新第一个对象的someProperty不会对第二个对象产生影响&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &quot;hello&quot;.toUpperCase();  // HELLO

  &quot;hello&quot;.someProperty = 17;

  &quot;hello&quot;.someProperty; // undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;避免对混合类型使用运算符&quot;&gt;避免对混合类型使用==运算符&lt;/h2&gt;

&lt;p&gt;下面的表达式的值其实是true， 对于看似无关的值使用==实际是相等的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &quot;1.0e0&quot; == { valueOf: function() { return true } }    // true

  // 理由如下
  Number(&quot;1.0e0&quot;)   // 转换为数字 1

  // 对象调用 valueOf方法返回true， 再转换为数字，得到1

  // 所以结果相等

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用隐式的强制转换做一些事情，但是仍然推荐使用严格模式进行比较。&lt;/p&gt;

&lt;p&gt;例子一, 这个例子使用了隐式的类型转换，跟数字进行比较会将字符串转为数字，从而得到正确的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(form.month.value == (today.getMonth() + 1) &amp;amp;&amp;amp;
    form.day.value == today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子二， 这个例子使用了显示的 Number，或者一元运算符 + 将字符串转为数字, 从而清晰的向大家表达了代码到底在做什么样的转换， 不要求读者记住这些转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(+form.month.value == (today.getMonth() + 1) &amp;amp;&amp;amp;
   +form.day.value == today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子三， 一个更好的例子 使用严格相等运算， 这个过程没有涉及任何转换，读者读起来更加清晰，否则读者需要记住这些强制转换来解读代码的行为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var today = new Date();

  if(+form.month.value === (today.getMonth() + 1) &amp;amp;&amp;amp;
    +form.day.value === today.getDate()) {
    // happy birthday
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-运算符强制转换规则&quot;&gt;== 运算符强制转换规则&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数类型1&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;参数类型2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;参数类型3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;null&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不转换，总是返回true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;null或undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;其他任何非null或undefined的类型&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不转换，总是返回false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Date对象&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字，将Date对象转换为原始类型（优先尝试toString方法，再尝试valueOf方法）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;非Date对象&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字，将非Date对象转换为原始类型（优先尝试valueOf方法，再尝试toString方法）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;原始类型的值：string, number,boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;将原始类型转换为数字&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;由一张图片引发的思考&quot;&gt;由一张图片引发的思考&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://darknights.b0.upaiyun.com/assets/images/in-post/read-book-effective/js-convert.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;这几个例子很好的验证了上面的隐式类型转换&quot;&gt;这几个例子很好的验证了上面的隐式类型转换&lt;/h2&gt;
&lt;p&gt;首先我们要知道一些前提&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;加法运算符会触发三种类型转换， 将值转为原始类型值， 转换为数字， 转换为字符串， 正好对应引擎内部的三种抽象操作， ToPrimitive(), ToNumber(),ToString()， 一旦得到原始类型的值直接开始进行运算&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;javascript 中的Object, 如果调用valueOf方法默认返回对象本身， 所以无论是{}，还是 []使用valueOf方法都会返回对象本身，得不到原始类型的值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toprimitive&quot;&gt;ToPrimitive&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如果输入的值已经是个原始值,则直接返回它.&lt;/li&gt;
  &lt;li&gt;否则,如果输入的值是一个对象.则调用该对象的valueOf()方法.如果valueOf()方法的返回值是一个原始值,则返回这个原始值.&lt;/li&gt;
  &lt;li&gt;否则,调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.&lt;/li&gt;
  &lt;li&gt;否则,抛出TypeError异常.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tonumber&quot;&gt;ToNumber&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;null&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;+0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;布尔值&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;true被转换为1,false转换为+0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数字&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;无需转换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字符串&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;由字符串解析为数字.例如,”324”被转换为324&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;tostring&quot;&gt;ToString&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;“undefined”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;null&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;“null”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;布尔值&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;true被转换为”true”,false转换为”false”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数字&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;数字作为字符串,比如. “1.765”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;字符串&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;无需转换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;举个栗子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var obj = {
    valueOf: function() {
      return {}
    },
    toString: function() {
      return {}
    }
  }

  Number(obj);
  obj + obj;  // TypeError: Cannot convert object to primitive value


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;value1--value2&quot;&gt;value1 + value2&lt;/h2&gt;
&lt;p&gt;这个表达式的计算过程是这样的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一步 将两个操作数转为原始类型的值  Date先调用toString()方法， 非Date先调用 valueOf()&lt;/li&gt;
  &lt;li&gt;第二步 如果其中任意一个是字符串，则将另一个也转为字符串，让后返回两个字符串相加后的结果&lt;/li&gt;
  &lt;li&gt;第三步， 否则将值都转为数字类型然后相加&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  '5' + 1 // '51'
  '5' + true // &quot;5true&quot;
  '5' + false // &quot;5false&quot;
  '5' + {} // &quot;5[object Object]&quot;
  '5' + [] // &quot;5&quot;
  '5' + function (){} // &quot;5function (){}&quot;
  '5' + undefined // &quot;5undefined&quot;
  '5' + null // &quot;5null&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  '5' - '2' // 3
  '5' * '2' // 10
  true - 1  // 0
  false - 1 // -1
  '1' - 1   // 0
  '5' * []    // 0
  false / '5' // 0
  'abc' - 1   // NaN
  null + 1 // 1
  undefined + 1 // NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;图片例子分析&quot;&gt;图片例子分析&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  [] + [] // &quot;&quot;

  首先转原始类型值先调用valueOf方法在调用toString方法，js对象的valueOf()返回对象本身，
  所以调用 toString() 返回的空字符串&quot;&quot;


  [] + {} // &quot;[object Object]&quot;

  首先转原始类型的值，[] 直接转成字符串，按照+运算符规则，其中任意一个字符串，
  则另一个也转为字符串 String({}) =&amp;gt; '[object Object]' 得到最终结果




  {} + {} // &quot;[object Object][object Object]&quot;  or &quot;NaN&quot;

  这个比较特殊JavaScript引擎将第一个{}解释成了一个空的代码块并且忽略了它，
   NaN其实是后面的表达式 +{}的计算结果
   这里的+ 是一元运算符作用是将操作数转为数字 和Number()函数完全一样。 如 +“36.5” =&amp;gt; 36.5

  转换过程如下
  +{}
  Number({}.toString()） // 因为{}.valueOf() 返回对象本身不是原始值
  Number(&quot;[object Object]&quot;)
  最终结果 NaN

  Firefox和Chrome(和Node.js一样使用V8引擎)的解析结果不同.下面的输入会被解析成一个表达式,结果更符合我们的预料

  {} + {} // &quot;[object Object][object Object]&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;为什么第一个{}会被解析成代码块呢?原因是,整个输入被解析成了一个语句,如果一个语句是以左大括号开始的,则这对大括号会被解析成一个代码块.所以,你也可以通过强制把输入解析成一个表达式来修复这样的计算结果:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  ({} + {})
  '[object Object][object Object]'

  同理
  console.log({} + {})
  '[object Object][object Object]'

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过上面的分析过程再来看&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  {} + []  //第一个{}被当成空代码块被忽略
  +[]      // 转数字
  Number(&quot;&quot;)      //  空字符串转为0
  最终结果
  0

  ({} + [])  // &quot;[object Object]&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考文章&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/ziyunfei/archive/2012/09/15/2685885.html&quot;&gt;JavaScript中,{}+{}等于多少?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://github.com/dwqs/blog/issues/17&quot;&gt;你有必要知道的 25 个 JavaScript 面试题&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://javascript.ruanyifeng.com/grammar/conversion.html#toc4&quot;&gt;数据类型转换&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/divd567/article/details/77247773&quot;&gt;JS数据类型转换 - 数字转换&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">当心隐式的强制转换</summary></entry></feed>