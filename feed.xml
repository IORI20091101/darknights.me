<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-09-29T18:05:26+08:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">Effective JavaScript (十)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-ten/" rel="alternate" type="text/html" title="Effective JavaScript (十)" /><published>2018-09-28T00:00:00+08:00</published><updated>2018-09-28T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-ten</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-ten/">&lt;h2 id=&quot;并发&quot;&gt;并发&lt;/h2&gt;

&lt;p&gt;JavaScript被设计成一种嵌入式的脚本语言。它不是以单独的应用程序运行，而是作为大型应用程序环境下的脚本运行。典型的例子当然是Web浏览器。
JavaScript中编写响应多个并发事件的程序的方法非常人性化，而且强大，因为它使用了一个简单的执行模型(有时称为事件队列和事件循环并发)和被称为异步的API.
奇怪的是，到目前为止，ECMAScript标准从来没有关于并发的说明。我们讨论的都是“约定成俗”的JavaScript特性，并不是官方标准。然而，绝大多数JavaScript的环境都使用相同的并发策略，未来标准的版本很有可能会基于广泛实现的执行模型来标准化。不管标准如何定义，使用事件和异步API是JavaScript编程的基础部分。&lt;/p&gt;

&lt;h2 id=&quot;不要阻塞io事件队列&quot;&gt;不要阻塞I/O事件队列&lt;/h2&gt;

&lt;p&gt;JavaScript程序是建立在事件之上的。输入可能来自各种各样的外部源，用户的交互操作，输入的网络数据或定时警报，我们通常会写这样的代码来等待某个特定的输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var text = downloadSync(&quot;http://example.com/file.txt&quot;);

console.log(text);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的函数通常被称为同步函数或阻塞函数， 程序会停止工作，等待它的输入。这个例子是等的网络下载文件的结果。&lt;/p&gt;

&lt;p&gt;在JavaScript中，大多数的I/O操作都提供了异步的或非阻塞的API, 程序提供一个回到函数，一旦输入完成就可以被系统调用， 而不是将程序阻塞在等待结果的线程上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dowanloadAsync(&quot;http://example.com/file.txt&quot;, function(text) {
	console.log(text);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript并发的一个重要规则是绝不要在应用程序事件队列中使用阻塞I/O的API。对于Web应用程序的交互性，同步的I/O会导致灾难性的结果，在操作完成之前一直会阻塞用户于页面的交互。&lt;/p&gt;

&lt;p&gt;Web平台提供了Workder的API，使得产生大量的并行计算称为可能。不同于传统的线程执行Workders在一个完全隔离的状态下进行，没有获取全局作用域或应用程序主线程Web页面内容的能力。因此它不回妨碍主事件队列中运行的代码的执行。在一个Worker中使用XMLHttpRequest同步的变种很少出问题。下载操作的确会阻塞Worker继续运行，但这并不会组织要么的渲染或事件队列中的事件响应。&lt;/p&gt;

&lt;h2 id=&quot;在异步序列中使用嵌套或命名的回调函数&quot;&gt;在异步序列中使用嵌套或命名的回调函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, function(url) {
	//	
});

downloadAsync(url, function(text) {
	console.log(&quot;contents of &quot; + url + &quot; : &quot; + text);
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个异步函数第二个的url读取不到，我们可以使用嵌套&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, function(url) {
	downloadAsync(url, function(text) {
		console.log(&quot;contents of &quot; + url + &quot; : &quot; + text);
	});
});


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是回调函数越来越多会变得很笨拙。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, function(url) {
	downloadAsync(url, function(text) {
		downloadAsync(&quot;a.txt&quot;, function(a) {
			downloadAsync(&quot;b.txt&quot;, function(b) {
				// ...
			})	
		})
	});
});


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;减少嵌套的方法之一就是将嵌套的回调函数作为命名的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, downloadURL);


// 仍然有嵌套
function downloadURL(url) {
	downloadAsync(url, function(text) {
		showContents(url, text);
	});
}

function showContents(url, text) {
	console.log(&quot;contents of &quot; + url + &quot; : &quot; + text);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中仍然有嵌套，我们可以使用bind方法消除最深层的嵌套回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, downloadURL);


// 仍然有嵌套
function downloadURL(url) {
	downloadAsync(url, showContents.bind(null, url));
}

function showContents(url, text) {
	console.log(&quot;contents of &quot; + url + &quot; : &quot; + text);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果层级过多仍然会有问题， 比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db.lookupAsync(&quot;url&quot;, downloadURL);


function downloadURL(url) {
	downloadAsync(url, downloadABC.bind(null, url));
}

function downloadABC(url, file) {
	downloasAsync(&quot;a.txt&quot;, downloadFileBC.bind(null, url, file))
}

function downloadBC(url, file, a) {
	downloasAsync(&quot;b.txt&quot;, downloadFileFinish.bind(null, url, file, a))
}

function downloadFileFinish(url, file, a, b) {
	// ...
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如尴尬的函数命名，和参数传递。最好的方式还是将两种方式结合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
db.lookupAsync(&quot;url&quot;, function(url) {
	downloadURLAndFiles(url);
});


function downloadURLAndFiles(url) {
	downloadAsync(url, downloadFiles.bind(null, url));
}

function downloadFiles(url, file) {
	downloadAsync(&quot;a.txt&quot;, function(a) {
		downloadAsync(&quot;b.txt&quot;, function(b) {
			// ...
		})	
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更好的方法是抽象出一个可以下载多个文件的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function downloadFiles(url, file) {
	downloadAllAsync([&quot;a.txt&quot;, &quot;b.txt&quot;, &quot;c.txt&quot;], function(all) {
		var a = all[0], b = all[1], c = all[2];
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;当心丢弃错误&quot;&gt;当心丢弃错误&lt;/h2&gt;

&lt;p&gt;同步代码我们可以通过&lt;code&gt;try...catch&lt;/code&gt;来捕获所有错误，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
	f();
	g();
	h();
} catch(e) {
	// handle any error that occured
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是异步代码根本不可能抛出异常， 通常异步API会有一个额外的回调函数来处理网络错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
downloadAsync(&quot;url&quot;, function(text) {
		
}, function(err) {
	console.log(&quot;Error &quot; + err)	;
});

多个回调时可以提取公共部分

function onErr(err) {
	console.log(&quot;Error &quot; + err)	;
}

downloadAsync(&quot;url&quot;, function(text) {
		
}, onErr);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js 异步处理API的错误处理，我们通过if判断来控制每个回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function onErr(err) {
	console.log(&quot;Error &quot; + err)	;
}

downloadAsync(&quot;url&quot;, function(error, text) {
	if(error) {
		onError(error);
		return false;
	}

	//success
});


更简洁写法

downloadAsync(&quot;url&quot;, function(error, text) {
	if(error) return onError(error);

	//success
});


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;对异步循环使用递归&quot;&gt;对异步循环使用递归&lt;/h2&gt;

&lt;p&gt;如果一个函数接受一个URL的数组并尝试下载买每个文件，如果API是同步的很容易实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function downloadOneSync(urls) {
	for(var i = 0, n = urls.length; i &amp;lt; n; i++) {
		try {
			return downloadSync(urls[i]);
		} catch(e) {

		}
	}

	throw new Error(&quot;all downloads failed&quot;);
}
如果调用downloadAsync的话会所有文件一起下载没有顺序，所以我们需要这样做在每个回调结束调用自身

function downloadOneAsync(urls, onsuccess, onfailur) {
	var n = urls.length;

	function tryNextURL(i) {
		if(i &amp;gt;= n) {
			onfailur(&quot;all downloads failed&quot;);
			return;
		}

		downloadAsync(urls[i], onsuccess, function() {
			tryNextURL(i + 1);
		})
	}

	tryNextURL(0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;局部函数tryNextURL是一个递归函数。它的实现调用了自身。 目前典型的JavaScript环境中一个递归函数调用自身多次会导致失败。
因为当一个程序执行有太多的函数调用，它会耗尽栈空间，最终抛出异常。这种情况被称为栈溢出。&lt;/p&gt;

&lt;p&gt;该例子调用100000次会产生一个运行时错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function countdown(n) {
	if(n === 0) {
		return &quot;done&quot;;
	} else {
		return countdown(n -1);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;异步操作不需要等待递归回调返回后才返回，调用栈不回有十万个函数在等待。每次有进有出只调用一个。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;循环不能是异步的&lt;/li&gt;
  &lt;li&gt;使用递归函数在事件循环的单独轮次中执行迭代&lt;/li&gt;
  &lt;li&gt;在事件循环的单独轮次中执行递归，并不会导致栈溢出&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;不要在计算时阻塞事件队列&quot;&gt;不要在计算时阻塞事件队列&lt;/h2&gt;

&lt;p&gt;如果你的程序需要执行代价高昂的计算你该怎么办，最简单的方法就是使用想Web客户端平台的Worker API这样的并发机制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var ai = new Worker('ai.js');

var userMove = /* *** */;

ai.postMessage(JSON.stringify({
	userMOve: userMove
}));


ai.onmessage = function(event) {
	executeMove(JSON.parse(event.data).computerMove);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样会产生一个新的线程独立的事件队列的并发执行线程。该worker是一个完全隔离的状态–没有任何应用程序对象的直接访问。但是，应用程序于worker之间可以功过发送形式为字符串的message来交互。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;避免在主事件队列中执行代价高昂的计算&lt;/li&gt;
  &lt;li&gt;在支持Worker APId的平台，该API可以用来在一个独立的事件队列中运行长计算程序。&lt;/li&gt;
  &lt;li&gt;在Worker API不可用活代价高昂的环境中，考虑将计算程序分解到事件循环的多个轮次中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用计数器来执行并行操作&quot;&gt;使用计数器来执行并行操作&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function downloadAllAsync(urls, onsuccess, onerror) {

	var result = [], length = urls.length;

	if(length === 0) {
		setTimeout(onsuccess.bind(null, result), 0);
		return;
	}

	urls.forEach(function(url) {
		downloadAsync(url, function(rext) {
			if(result) {
				result.push(text);
				if(result.length === urls.length) {
					onsuccess(result);
				}
			}
		}, function(error) {
			if(result) {
				result = null;
				onerror(error);
			}
		});
	})
}

这段代码有个错误

var filenames = [
	&quot;huge.txt&quot;,
	&quot;tiny.txt&quot;,
	&quot;medium.txt&quot;,
];

downloadAllAsync(filenames, function(files) {
	console.log(&quot;Huge file: &quot; + files[0].length); // tiny
	console.log(&quot;Tiny file: &quot; + files[0].length); // medium
	console.log(&quot;Medium file: &quot; + files[0].length); // huge
}, function(error) {
	console.log(&quot;Error : &quot; + error);
});


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里下载文件的顺序并不可控，因为文件是并行下载的。 调用者无法找出那个结果对应哪个文件， 上面的例子假设结果合输入有相同的顺序其实是错误的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function downloadAllAsync(urls, onsuccess, onerror) {

	var result = [], length = urls.length;

	if(length === 0) {
		setTimeout(onsuccess.bind(null, result), 0);
		return;
	}

	urls.forEach(function(url, i) {
		downloadAsync(url, function(text) {
			if(result) {
				
				result[i] = text;
				if(result.length === urls.length) {
					onsuccess(result);
				}
			}
		}, function(error) {
			if(result) {
				result = null;
				onerror(error);
			}
		});
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个版本也有问题如果先下载完成的是第三个文件则 result[2] = text; 那么result的长度也是3， 则直接在if条件中返回，用户的success回调函数将被过早调用，其参数为一个不完整的结果数组。&lt;/p&gt;

&lt;p&gt;所以正确的方式应该是这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function downloadAllAsync(urls, onsuccess, onerror) {

	var result = [], pending = urls.length;

	if(pending === 0) {
		setTimeout(onsuccess.bind(null, result), 0);
		return;
	}

	urls.forEach(function(url, i) {
		downloadAsync(url, function(text) {
			if(result) {
			
				result[i] = text;
				pending--;
				if(pending === 0) {
					onsuccess(result);
				}
			}
		}, function(error) {
			if(result) {
				result = null;
				onerror(error);
			}
		});
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;绝不要同步的调用异步的回调函数&quot;&gt;绝不要同步的调用异步的回调函数&lt;/h2&gt;

&lt;p&gt;加入下载文件的例子有一个缓存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cache = new Dict();

function downloadCachingAsync(url, onsuccess, onerrur) {
	if(cache.has(url)) {
		onsuccess(cache.get(url));  // 同步调用
	}

	return downloadAsync(url, function(file) {
		cache.set(url, file);
		onsuccess(file);
	}, onerror);
}

通常情况如果可以回立即提供数据，但这改变了用户预期

downloadAsync(&quot;file.txt&quot;, function(file) {
	console.log(&quot;finished&quot;);
});

console.log(&quot;starting&quot;);

这里按照我们预想 可能先返回 &quot;starting&quot; 然后 &quot;finished&quot;, 但是由于同步调用了函数，
这里如果文件有缓存的话 先返回了&quot;finished&quot; 然后才是 &quot;starting&quot;; 这与我们的预想不符。
所以我们应该这样来使用

if(cache.has(url)) {
	var cached = cache.get(url);
	setTimeout(onsuccess.bind(null, cached), 0);
	return;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用promise模式清洁异步逻辑&quot;&gt;使用promise模式清洁异步逻辑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
downloadAsync(&quot;file.txt&quot;, function(file) {
	console.log(&quot;file : &quot; + file);
});


相比之下，基于promise的API不接受回调函数作为参数

var p = downloadP(&quot;file.txt&quot;);

p.then(function(file) {
	console.log(&quot;file: &quot; + file);
});

promise的返回值是一个新的promise

var fileP = downloadP(&quot;file.txt&quot;);

var lengthP = fileP.then(function(file) {
	return file.length;
});

lengthP.then(function(length) {
	console.log(&quot;length: &quot; + length);
});


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;promise通常提供给一个叫做when的工具函数，或者join&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var filesP = join(downloadP(&quot;file1.txt&quot;),
				downloadP(&quot;file2.txt&quot;),
				downloadP(&quot;file3.txt&quot;));

filesP.then(function(files) {
	// files[0]
});


var fileP1 = downloadP(&quot;file1.txt&quot;);
var fileP2 = downloadP(&quot;file2.txt&quot;);
var fileP3 = downloadP(&quot;file3.txt&quot;);

when([fileP1, fileP2, fileP3], function(files) {
	console.log(&quot;file1: &quot; + files[0]);

})

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用select或choose工具函数可以使几个promise彼此竞争。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var filesP = select(downloadP(&quot;file1.txt&quot;),
				downloadP(&quot;file2.txt&quot;),
				downloadP(&quot;file3.txt&quot;));

filesP.then(function(file) {
	//file
	// 返回值最先完成下载的文件的promise
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;select函数的另一个用途是提供超时来终止长时间的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fileP = select(downloadP(&quot;file.txt&quot;), timeoutErrorP(2000));

filep.then(function(file) {
	console.log(&quot;file: &quot; + file);
}, function(error) {
	console.log(&quot;I/O error or timeout: &quot; + error);
})

&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">并发</summary></entry><entry><title type="html">Effective JavaScript (九)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-nine/" rel="alternate" type="text/html" title="Effective JavaScript (九)" /><published>2018-09-28T00:00:00+08:00</published><updated>2018-09-28T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-nine</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/28/read-book-effective-nine/">&lt;h2 id=&quot;保持一致的约定&quot;&gt;保持一致的约定&lt;/h2&gt;

&lt;h2 id=&quot;将undefined当作没有值&quot;&gt;将undefined当作没有值&lt;/h2&gt;
&lt;p&gt;undefined很特殊，每当JavaScritp无法提供具体的值时，就产生undefined。为赋值的初始值即为undefiend&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x;
x // undefined;

var obj = {};
obj.x; //undefined


function f() {
	return ;
}

function g() {}


f();  //undefined
f();  //undefined

function f(x) {
	return x;
}
f(); // undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如一个Web服务器可以接受一个可选的饿主机名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s1 = new Server(80, &quot;example.com&quot;);

var s2 = new Server(80); //defaults to &quot;localhost&quot;

我们可以通过判断arguments.length来实现Server构造函数

function Server(port, hostname) {
	if(arguments.length &amp;lt; 2) {
		hostname = &quot;localhost&quot;;
	}

	hostname = String(hostname);
}

这种情况如果第二个值是undefined的话可能会使用undefined，这并不是我们想要的所以我们最好判断undefined

function Server(port, hostname) {
	if(hostname === undefined) {
		hostname = &quot;localhost&quot;;
	}

	host = String(hostname);
}


另一种合理的方式是测试hostname是否为真

function Server(port, hostname) {
	hostname = String(hostname || &quot;localhost&quot;);
	// ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是最后一种的真值检测并不总是安全的，如果一个函数允许接受0(或NaN，虽然不常见)为可接受的参数,则不应该使用真值测试&lt;/p&gt;

&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;

function Element(width, height) {
	this.width = width || 320;
	this.height = height || 240;
	// ...
}
var c1 = new Element(0, 0); 
c1.width; // 320
c1.height; // 240


这种情况我们需要更详细的测试来测试undefined
function Element(width, height) {
	this.width = width === undefined ? 320 : width;
	this.height = height === undefined ? 240 : height;

	// ...
}

var c1 = new Element(0, 0);
c1.width; // 0
c1.height; // 0

var c2 = new Element();
c2.width; // 320
c2.height; // 240

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;接受关键字参数的选项对象&quot;&gt;接受关键字参数的选项对象&lt;/h2&gt;
&lt;p&gt;保持参数顺序的一致约定对于帮助程序员记住每个参数在函数调用中的意义是很重要的，参数较少时它是适用的。但是参数过多后根本不可扩展&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var alert = new Alert(100, 75, 300, 200,
		&quot;Error&quot;, message,
		&quot;blue&quot;, &quot;white&quot;, &quot;black&quot;,
		&quot;error&quot;, true
	);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个函数起初很简单，但是过一段时间，随着库功能的扩展，该函数的签名便会获得越来越多的参数。&lt;/p&gt;

&lt;p&gt;幸运的是，JavaScrtip提供了一个简单、轻量的惯用法： 选项对象(options object).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var alert = new Alert({
	x: 100, y: 75,
	width: 300, height: 200,
	title: &quot;Error&quot;, message: message,
	titleColor: &quot;blue&quot;, bgColor: &quot;white&quot;, textColor: &quot;black&quot;,
	icon: &quot;error&quot;, modal: true	
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个虽然烦琐，但明显更易于阅读，每个参数都是自我描述(self-documenting)的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Alert(parent, message, opts) {
	opts = opts || {};

	this.width = opts.width === undefined ? 320 : opts.width;
	this.height = opts.width === undefined ? 240 : opts.height;
	this.title = otps.title || &quot;Alert&quot;;

}

基于 extend 的另一种实现

function extend(target, source) {
	if(source) {
		for(var key in source) {
			var val = source[key];

			if(typeof val !== &quot;undefined&quot;) {
				target[key] = val;
			}
		}
	}

	return target;
}



function Alert(parent, message, opts) {
	opts = extend({
		width: 320,
		height: 240
	});

	opts = extend({
		title: &quot;Alert&quot;	
	}, opts);

	this.width = opts.width;
	this.height = opts.height;
	this.title = opts.title;

}


进一步简化


unction Alert(parent, message, opts) {
	opts = extend({
		width: 320,
		height: 240
	});

	opts = extend({
		title: &quot;Alert&quot;	
	}, opts);

	extend(this, opts);
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;区分数组对象和类数组对象&quot;&gt;区分数组对象和类数组对象&lt;/h2&gt;

&lt;p&gt;使用instanceof的不完美选择&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringSet.prototype.add = function(x) {
	if(typeof x === 'String') {
		// xxx
	} else if(x instanceof Array) { //有局限性
		// xxx
	} else {
		// xxx
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instanceof 操作符测试一个对象是否继承自Array.prototype。 在一些允许多个全局对象的环境中可能会有标准的Array构造函数和原型对象的多份副本。在浏览器中有这种情况，每个frame会有标准库的一份单独副本，当跨frame通信时，一个frame中的数组不会继承自另一个frame的Array.prototype.出于这个原因，ES5中引入了&lt;code&gt;Array.isArray&lt;/code&gt;函数， 其用于测试一个值是否是数组，而不管原型继承。ESMAScript标准中， 该函数测试对象内部[[Class]]属性值是否是Array。它比&lt;code&gt;instanceof&lt;/code&gt;更加可靠。
所以有这个更健壮的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringSet.prototype.add = function(x) {
	if(typeof x  === 'String') {

	} else if(Array.isArray(x)) {

	} else {

	}
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于不支持ES5的环境中我们可以自己实现一个测试方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var toString = Object.prototype.toString;

function isArray(x) {
	return toString(x) === '[object Array]';
}


// 转为真实数组
你不能传入arguments对象并期待它被视为数组，
最好还是自己转化一下
[].slice.call(arguments);



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Object.prototype.toString&lt;/code&gt;函数使用对象内部&lt;code&gt;[[Class]]&lt;/code&gt;属性创建结果字符串，所以比&lt;code&gt;instance of&lt;/code&gt;操作符更可靠。&lt;/p&gt;

&lt;h2 id=&quot;避免过度的强制转换&quot;&gt;避免过度的强制转换&lt;/h2&gt;

&lt;p&gt;我们创建一个BitVector的构造函数guard, 这里有一个思路可以用来做检测用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function BitVector(x) {
	// 链式调用
	uint32.or(arrayLike).guard(x);
}


var guard = {
	guard: function(x) {
		if(!this.test(x)) {
			throw new TypeError(&quot;expected &quot; + this);
		}
	}
}

var uint32 = Object.create(guard);

uint32.toString = function() {
	return &quot;uint32&quot;;
}


var arrayLike = Object.create(guard);

arrayLike.test = function(x) {
	return typeof x === &quot;object&quot; &amp;amp;&amp;amp; x &amp;amp;&amp;amp; uint32.test(x.length);
}

arrayLike.toString = function() {
	return &quot;array-like object&quot;;
}


guard.or = function(other) {
	var result = Object.create(guard);

	var self = this;
	result.test = function(x) {
		return self.test(x) || other.text(x);
	};

	var description = this + &quot; or &quot; + other;

	result.toString = function() {
		return description;
	};

	return result;

}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;支持方法链&quot;&gt;支持方法链&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function escapeBasicHTML(str) {
	return str.replace(/&amp;amp;/g, &quot;&amp;amp;amp;&quot;)
			  .replace(/&amp;lt;/g, &quot;&amp;amp;lt;&quot;)
			  .replace(/&amp;gt;/g, &quot;&amp;amp;gt;&quot;)
			  .replace(/&quot;/g, &quot;&amp;amp;quot;&quot;)
			  .replace(/'/g, &quot;&amp;amp;apos;&quot;);
}

这种比下面的方法更加简洁

function escapeBasicHTML(str) {
	var str2 = str.replace(/&amp;amp;/g, &quot;&amp;amp;amp;&quot;);
	var str3 = str2.replace(/&amp;lt;/g, &quot;&amp;amp;lt;&quot;);
	var str4 = str3.replace(/&amp;gt;/g, &quot;&amp;amp;gt;&quot;);
	var str5 = str4.replace(/&quot;/g, &quot;&amp;amp;quot;&quot;);
	var str6 = str5..replace(/'/g, &quot;&amp;amp;apos;&quot;);

	return str6;
}


var users = records.map(function(record) {
		return record.username;
	})
	.filter(function(username) {
		return !!username;
	})
	.map(function(username) {
		return username.toLowerCase();
	});

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用方法链来连接无状态的操作&lt;/li&gt;
  &lt;li&gt;通过无状态的方法中返回新对象来支持方法链&lt;/li&gt;
  &lt;li&gt;通过在有状态的方法中返回this来支持方法链&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">保持一致的约定</summary></entry><entry><title type="html">Effective JavaScript (八)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/25/read-book-effective-eight/" rel="alternate" type="text/html" title="Effective JavaScript (八)" /><published>2018-09-25T00:00:00+08:00</published><updated>2018-09-25T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/25/read-book-effective-eight</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/25/read-book-effective-eight/">&lt;h2 id=&quot;使用object的直接实例构造轻量级的字典&quot;&gt;使用Object的直接实例构造轻量级的字典&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var dict = { alice: 34, bob: 24, chris: 62 };

var people = [];

for(var name in dict) {
	people.push(name + &quot;: &quot; + dict[name]);
}

people; // [&quot;alice: 34&quot;, &quot;bob: 24&quot;, &quot;chris: 62&quot;];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们创建一个自定义的字典类会怎样呢&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function NaiveDict() {}

NaiveDict.prototype.count = function() {
	var i = 0;
	for(var name in this) {
		i++;
	}

	return i;
};

NaiveDict.prototype.toString = function() {
	return &quot;[object NaiveDict]&quot;;
};

var dict = new NaiveDict();

dict.alice = 34;
dict.bob = 24;
dict.chris = 62;

dict.count(); // 5

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样有一个问题，count会枚举出所有的属性包括了toString 和count,而不仅仅是我们需要的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dict = new Array();

dict.alice = 34;
dict.bob = 24;
dict.chris = 62;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样也会有问题，代码对原型污染很脆弱，应用程序的其他库有可能会打猴子补丁，比如&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;原型污染是指当枚举字典的条目时，原型对象中的一些属性可能会导致出现一些不期望的属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Array.prototype.first = function() {
	return this[0];
}

Array.prototype.last = function() {
	return this[1];
}

var names = [];
for(var name in dict) {
	names.push(name);
}

names; [&quot;alice&quot;, &quot;bob&quot;, &quot;chris&quot;, &quot;first&quot;, &quot;last&quot;]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用使用 &lt;code&gt;new Object() &lt;/code&gt;可能会面临同样的问题，但是使用 &lt;code&gt;{}&lt;/code&gt;的方式会更好, 虽然不能保证对于原型污染时安全的，任何人仍然能增加属性到Object.prototype，但是风险可以降低到仅仅局限于Object.prototype&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;坚持使用Object的直接实例原则可以使for…in循环摆脱原型污染的影响&lt;/li&gt;
  &lt;li&gt;使用对象字面量构建轻量级字典&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用null原型以防止原型污染&quot;&gt;使用null原型以防止原型污染&lt;/h2&gt;

&lt;p&gt;防止原型污染的最简单的方式之一就是一开始就不使用原型。但是ES5发布之前并没有一个标准的方式创建一个空原型的新对象。你可能会这样做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function C() { }

C.prototype = null;

var o = new C();

Object.getPrototypeOf(o) === null; // false
Object.getPrototypeOf(o) === Object.prototype // true


// ES5之后应该这样做
var x = Object.create(null);

Object.getPrototypeOf(o) === null; // true

在不支持Object.create的JavaScript环境中特殊对象__proto__提供了对对象内部原型链的读写访问

var x = { __proto__: null };

x instanceof Object;  // false;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种貌似更方便，但是有了Object.create函数后，Object.create是更值得推荐的方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在ES5中要使用Object.create(null)创建自由原型的空对象是不太容易被污染的。&lt;/li&gt;
  &lt;li&gt;在一些老环境中考虑使用{ &lt;strong&gt;proto&lt;/strong&gt;: null }， 但是它既不是标准的也不是可移植的还有可能在未来被删除&lt;/li&gt;
  &lt;li&gt;绝对不要使用__proto__作为字典中的key&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用hasownproperty方法避免原型污染&quot;&gt;使用hasOwnProperty方法避免原型污染&lt;/h2&gt;
&lt;p&gt;JavaScript的对象操作总是以继承的方式工作，即使一个空的对象字面量也继承了Object.prototype的大量属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dict = {}
&quot;alice&quot; in dict; //false;
&quot;bob&quot; in dict; //false;
&quot;chris&quot; in dict; //false;

// toString 和valueOf方法继承自Object.prototype
&quot;toString&quot; in dict; //false;  
&quot;valueOf&quot; in dict; //false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;幸运的是Object.hasOwnProperty方法可以用来判断属性是否继承自原型对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dict.hasOwnProperty(&quot;alice&quot;);     // false
dict.hasOwnProperty(&quot;toString&quot;);  // false
dict.hasOwnProperty(&quot;valueOf&quot;);   // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不幸的是我们没有完全解决问题，当调用dict.hasOwnProperty时，我们请求调查对象的hasOwnProperty方法，通常情况下，该方法会简单的继承自Object.property对象，然而如果字典中存储一个同名的条目时，那么原型中的hasOwnProperty方法不能再被捕获到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dict.hasOwnProperty = 10;

dict.hasOwnProperty(&quot;alice&quot;);
// error dict.hasOwnProperty is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是有可能的,最安全的方式就是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var hasOwn = Object.prototype.hasOwnProperty;
或者
var hasOwn = {}.hasOwnProperty;

hasOwn.call(dict, &quot;alice&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不管起接收者的hasOwnProperty方法是否被覆盖，该方法都能工作。&lt;/p&gt;

&lt;p&gt;我们开始创建一个字典类 版本一&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Dict(elements) {
	this.elements = elements || {};
}

Dict.prototype.has = function(key) {
	return {}.hasOwnProperty.call(this.elements, key);
}

Dict.prototype.get = function(key) {
	return this.has(key) ? this.elements[key] : undefined;
}

Dict.prototype.set = function(key, val) {
	this.elements[key] = val;
}

Dict.prototype.remove = function(key) {
	delete this.elements[key];
}

var dict = new Dict({
	alice: 34,
	bob: 24,
	chris: 62
});

dict.has(&quot;alice&quot;);    // true
dict.get(&quot;bob&quot;);      // 24
dict.has(&quot;valueOf&quot;)   //false

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在一些JavaScript的环境中，特殊的属性名__proto__可能导致自身的污染问题__proto__属性只是简单的继承Object.prototype,所以我们的例子会有一个问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dict = new Dict();
dict.has(&quot;__proto__&quot;); // ?

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码在不同的环境下可能会有不同的结果，所以为了达到最大的可移植性和安全性，便有了下面更复杂但是更安全的实现
这里检测到__proto__的可以 重新设置一个新属性作为实例对象的一个属性，随对象而在但是不会去设置对象的__proto__&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Dict(elements) {
	this.elements = elements || {};
	this.hasSpecialProto = false;
	this.specialProto = undefined;
}

Dict.prototype.has = function(key) {
	if(key === &quot;__proto__&quot;) { 
		return this.hasSpecialProto;
	}
	return {}.hasOwnProperty.call(this.elements, key);
}

Dict.prototype.get = function(key) {
	if(key === &quot;__proto__&quot;) { 
		return this.specialProto;
	}
	return this.has(key) ? this.elements[key] : undefined;
}

Dict.prototype.set = function(key, val) {
	if(key === &quot;__proto__&quot;) {
		this.hasSpecialProto = true;

		this.specialProto = val;
	} else {
		this.elements[key] = val;	
	}
	
}

Dict.prototype.remove = function(key) {
	if(key === &quot;__proto__&quot;) {
		this.hasSpecialProto = false;
		this.sepcialProto = undefined;
	} else {
		delete this.elements[key];	
	}
	
}

var dict = new Dict({
	alice: 34,
	bob: 24,
	chris: 62
});

dict.has(&quot;alice&quot;);    // true
dict.get(&quot;bob&quot;);      // 24
dict.has(&quot;valueOf&quot;)   //false

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用数组而不要使用字典来存储有序集合&quot;&gt;使用数组而不要使用字典来存储有序集合&lt;/h2&gt;
&lt;p&gt;JavaScript对象是一个无序集合,ECMAScript标准并未规定属性存储的任何特定顺序，甚至对于枚举对象也未涉及。这将会导致一个问题，&lt;code&gt;for...in&lt;/code&gt;循环会挑选一个特定顺序来枚举对象属性.比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function report(highScores) {
	var result = &quot;&quot;;
	var i = 1;
	for(var name in highScores) {
		result += i + &quot; . &quot; + name + &quot; : &quot; + highScores[name] + '\n';

		i++;
	}

	return result;
}

report([{
		name: &quot;Hank&quot;,
		points: 1110100
	},{
		name: &quot;Steve&quot;,
		points: 1064500
	},{
		name: &quot;Billy&quot;,
		points: 1052000
	}]);

由于不同的环境选择不同的顺序来存储和枚举对象属性，所以这个函数得到顺序混乱的“最高分”报表
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请记住你的程序是否以来对象枚举的顺序并不总是显而易见的，如果没有在多个JavaScript环境中测试过你的程序，你甚至可能不回注意到程序的行为因为一个for…in循环的确切顺序而被改变，对于上面的例子需要使用数组,那么它完全可以工作在任何JavaScript环境中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function report(highScores) {
	var result = &quot;&quot;;
	var i = 1;
	for(var i = 0, n = highScores.length; i &amp;lt; n; i++) {
		var score = hightScores[i];
		result += (i + 1) + &quot; . &quot; + score.name + &quot; : &quot; + score.points + '\n';

		i++;
	}

	return result;
}

report([{
		name: &quot;Hank&quot;,
		points: 1110100
	},{
		name: &quot;Steve&quot;,
		points: 1064500
	},{
		name: &quot;Billy&quot;,
		points: 1052000
	}]);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个微妙的顺序以来的典型例子是浮点运算， 假设一个对象使用&lt;code&gt;for...in&lt;/code&gt; 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ratings = {
	&quot;Good will Hunting&quot;: 0.8,
	&quot;Mystic River&quot;: 0.7,
	&quot;21&quot;: 0.6,
	&quot;Doubt&quot;: 0.9
};

var total = 0, count = 0;
for(var key in. ratings) {
	total += ratings[key];
	count++;
}

total /= count;

total; //?

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实证明，流行的JavaScrtip环境实际上使用不同的顺序执行这个循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一些环境这样计算

(0.8 + 0.7 + 0.6 + 0.9) / 4  // 0.75

还有一些环境先枚举潜在的数组索引，21恰好是一个可行的数组索引，它首先被枚举，导致如下结果

(0.6 + 0.8 + 0.7 + 0.9) / 4  // 0.7499999999999999


更好的表示方法是使用整数值

(8 + 7 + 6 + 9) / 4/ 10.  //0.75

(6 + 8 + 7  + 9) / 4/ 10.  //0.75

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常当执行&lt;code&gt;for...in&lt;/code&gt; 循环时应当时刻小心，确保操作行为与顺序无关。&lt;/p&gt;

&lt;h2 id=&quot;绝不要在objectprototype中增加可枚举属性&quot;&gt;绝不要在Object.prototype中增加可枚举属性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;for...in&lt;/code&gt;非常便利，然而它很容易受到原型污染的影响。目前为止&lt;code&gt;for...in&lt;/code&gt;最常见的用法是枚举字典中的元素。这暗示着如果想允许对字典对象使用&lt;code&gt;for...in&lt;/code&gt;循环，那么不要在共享的Object.prototype中增加可枚举的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.prototype.allKeys = function() {
	var result = [];
	for(var key in this) {
		result.push(key);
	}

	return result;
}

({a: 1, b: 2, c: 3}).allKeys(); // [&quot;allkeys&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]  该方法污染了自身

更友好的做法是将allkeys定义为一个函数而不是方法，虽然着稍微有点不方便

function allKeys(obj) {
	var result = [];
	for(var key in obj) {
		result.push(key);
	}

	return result;
}



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你确实想在Object.prototype中增加属性， ES5提供了一个更加友好的机制Object.defineProperty&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;方法可以定义一个对象的属性并制定该属性的元数据。例如，我们可以用与之前完全一样的方法定义上面的属性而通过设置其可枚举属性为false使其在&lt;code&gt;for...in&lt;/code&gt;循环中不可见。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Object.defineProperty(Object.prototype, &quot;allKeys&quot;, {
	value: function() {
		var result = [];
		for(var key in this) {
			result.push(key);
		}
		return result;
	},
	writable: true,
	enumerable: false,
	configurable: true
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它不会污染其他所有&lt;code&gt;Object&lt;/code&gt;实例的所有&lt;code&gt;for...in&lt;/code&gt;循环。每当你需要增加一个不应该出现在&lt;code&gt;for...in&lt;/code&gt;循环中出现的属性时，Object.defineProperty便是你的选择&lt;/p&gt;

&lt;h2 id=&quot;避免在枚举期间修改对象&quot;&gt;避免在枚举期间修改对象&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function Member(name) {
	this.name = name;
	this.friends = [];
}

var a = new Member(&quot;Alice&quot;),
	b = new Member(&quot;Bob&quot;),
	c = new Member(&quot;Carol&quot;),
	d = new Member(&quot;Dieter&quot;),
	e = new Member(&quot;Eli&quot;),
	f = new Member(&quot;Fatima&quot;);

a.friends.push(b);
b.friends.push(c);
c.friends.push(e);
d.friends.push(b);
e.friends.push(d,f);

如果我们写了一个方法 在for...in的时候操作对象比如，删除或添加， 在许多JavaScript环境中这段代码根本不能工作。

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;ECMAScript规定了，如果被枚举的对象在枚举期间添加了新的属性，那么在枚举期间并不能保证新添加的属性能够被访问。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个隐式的规范的实际后果是： 如果我们修改了被枚举的对象则不能保证&lt;code&gt;for...in&lt;/code&gt;循环行为的可预见性。&lt;/p&gt;

&lt;p&gt;我们可以新建一个WorkSet类来追踪当前集合中元素的数量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function WorkSet() {
	this.entries = new Dict();
	this.count = 0;
}

WorkSet.prototype.isEmpty = function() {
	return this.count === 0;
}

WorkSet.prototype.add = function(key, val) {
	if(this.entries.has(key)) {
		return;
	}

	this.entries.set(key, val);
	this.count++;
}

WorkSet.prototype.get = function(key) {
	return this.entries.get(key);
}

WorkSet.prototype.remove = function(key) {
	if(!this.entries.had(key)) {
		return;
	}

	this.entries.remove(key);
	this.count--;
}

WorkSet.prototype.pick = function() {
	return this.entries.pick();
}

//这里同时需要给Dict类增加一个pick方法

Dick.prototype.pick = function() {
	for(var key in this.elements) {
		if(this.has(key)) {
			return key;
		}
	}

	throw new Error(&quot;empty dictionary&quot;);
}

// 现在我们可以实现一个inNetwork的方法
到最后发现这段代码没什么卵用
Member.prototype.inNetwork = function(other) {
	var visited = {};
	var workset = new WorkSet();
	workset.add(this.name, this);

	while(!workset.isEmpty()) {
		var name = = workset.pick();
		var member = workset.get(name);
		workset.remove(name);
		if(name in visited) {
			continue;
		}

		visited[name] = member;

		if(member === other) {
			return true;
		}

		member.friends.forEach(function(friend) {
			workset.add(friend.name, friend);
		})
	}

	return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上pick方法是一个不确定性的例子， 不确定性指的是一个操作不能保证使用语言的语意产生一个单一的可预见的结果。这个不确定性来源于这样一个事实，for…in循环可能在不同的JavaScript环境中选择不同的枚举顺序。
基于这些原因，考虑使用一个确定的工作集算法替代方案是值得的。集工作列表算法Work-list.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用for…in循环枚举一个对象属性时，确保不要修改该对象&lt;/li&gt;
  &lt;li&gt;当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环代替for…in循环&lt;/li&gt;
  &lt;li&gt;为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数组迭代优先使用for循环而不是forin&quot;&gt;数组迭代优先使用&lt;code&gt;for&lt;/code&gt;循环而不是&lt;code&gt;for...in&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;看下面代码mean的输出值时多少？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var scores = [98, 74, 85, 77, 93, 100, 89];

var total = 0;

for(score in scores) {
	total += score;
}

var mean = total / socres.length;

 mean; // ?  17636.571428571428


 请记住即使是数组的索引属性，对象属性的key始终是字符串

 total = 0 + &quot;0&quot; + &quot;1&quot; + &quot;2&quot; + &quot;3&quot; + &quot;4&quot; + &quot;5&quot; + &quot;6&quot;;

 total = &quot;00123456&quot;;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;迭代数组内容的正确方式是使用传统的for循环, 建议存储数组长度到一个局部变量中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var scores = [98, 74, 85, 77, 93, 100, 89];
var total = 0;

for(var i = 0, n = scores.length; i &amp;lt; n; i++) {
	total += socres[i];
}

var mean = toal / scores.length;

mean; // 88

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;迭代方法由于循环&quot;&gt;迭代方法由于循环&lt;/h2&gt;
&lt;p&gt;一些常见的for循环错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(var i = 0; i &amp;lt;= n; i++) {...}. // 获取最后一项错误

for(var i = 1; i &amp;lt; n; i++) {...}. // 丢失第一项

for(var i = n; i &amp;gt;= 0 ; i--) {...}. // 获取起始值错误

for(var i = n - 1; i &amp;gt; 0 ; i--) {...}. // 丢失最后一项

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们面对这样一个事实，搞清楚终止条件是一个累赘。
幸运的是ES5提供了一些便利的方法。Array.prototype.forEach是其中最简单的一个。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(var i = 0, n = players.length; i &amp;lt; n; i++) {
	players[i].score++;
}
可以用下面代码替换
players.forEach(function(p) {
	p.socre++;
})	

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码不仅更简单可读而且消除了终止条件和任何数组索引。&lt;/p&gt;

&lt;p&gt;另一个例子是对数组进行操作后建立一个新的数组我们可以这样实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var trimmed = [];
for(var i = 0, n = input.lenght; i &amp;lt; n; i++) {
	trimmed.push(input[i].trim());
}

我们同样可以使用forEach来实现

var trimmed = [];
input.forEach(function(s) {
	trimmed.push(s.trim());
});


因为这是一个十分普遍的操作，所以ES5提供了一个更简单优雅的实现Array.prototype.map

var trimmed = input.map(function(s) {
	return s.trim();	
})


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一种常见的模式是计算一个新的数组，该数组只包含现有数组的一部分元素.&lt;code&gt;Array.prototype.filter&lt;/code&gt;使其变得简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
listings.filter(function(listing) {
	return listing.price &amp;gt;= min &amp;amp;&amp;amp; listing.price &amp;lt;= max;
});

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些都是ES5的默认方法，我们当然可以实现自己的方法，比如我们需要这样一个模式，提取满足谓词的数组的前几个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function takeWhile(a, pred) {
	var result = [];
	for(var i = 0, n = a.length; i &amp;lt; n; i++) {
		if(!pred(a[i], i)) {
			break;
		}
		result[i] = a[i];
	}

	return result;
}

var prefix = taleWhile([1, 2, 4, 8, 16, 32], function(n) {
	return n &amp;lt; 10;
});

// [1, 2, 4, 8]


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意我们将索引i赋值给了pred, 我们可以选择使用或忽略该索引。事实上标准库中的所有迭代方法包括(forEach, map, filter)都将数组索引传递给了用户自定义函数。&lt;/p&gt;

&lt;p&gt;我们也可以将takeWhile加入到Array.prototype中参考猴子补丁的影响&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Array.prototype.takeWhile = function(pred) {
	var result = [];
	for(var i = 0, n = this.length; i &amp;lt; n; i++) {
		if(!pred(this[i], i)) {
			break;
		}

		result[i] = this[i];
	}

	return result;
}

var prefix = [1, 2, 4, 8, 16, 32].takeWhile(function(n) {
	return n &amp;lt; 10;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;循环只有一点优于迭代函数，那就是前者有控制流操作，如break 和continue。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举例来说&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function takeWhile(a, pred) {
	var result = [];
	a.forEach(function(x, i) {
		if(!pred(x)) {
			// ?
		}
		result[i] = x;
	});

	return result;
}

我们可以使用一个内部异常来提前终止该循环，但是这既尴尬又效率低下

function takeWhile(a, pred) {
	var result = [];
	var earlyExit = [];
	try {
		a.forEach(function(x, i) {
			if(!pred(x)) {
				throw earlyExit;
			}

			result[i] = x;
		});
	} catch(e) {
		if(e !== earlyExit) {
			throw e;
		}
	}

	return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES5的数组方法some和every可以用于提前终止循环。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 10, 100].some(function(x) {.return x &amp;gt; 5; });  // true
[1, 10, 100].some(function(x) {.return x &amp;lt; 0; });  // false

[1, 10, 100].every(function(x) {.return x &amp;gt; 0; });  // true
[1, 10, 100].every(function(x) {.return x &amp;lt; 3; });  // true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用这一点我们可以重新实现takeWhile方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
function takeWhile(a, pred) {
	var result = [];

	a.every(function(x, i) {
		if(!pred(x)) {
			return false; // break
		}

		result[i] = x;
		return true;  // continue
	});

	return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用迭代方法 forEach 和map替换for循环使得代码更可读，并且避免了重复循环控制逻辑&lt;/li&gt;
  &lt;li&gt;使用自定义的迭代函数来抽象未被标准库支持的常见循环模式&lt;/li&gt;
  &lt;li&gt;在需要提前终止循环的情况下， 仍然推荐使用传统的循环。另外，some和every方法也可用于提前退出&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;在类数组对象上复用通用的数组方法&quot;&gt;在类数组对象上复用通用的数组方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Array.prototype&lt;/code&gt;中的标准方法被设计成其他对象可复用的方法，即使这些对象并没有继承Array,一个很好的例子 函数的arguments对象，它并没有继承Array.prototype，因此我们不能简单的调用arguments.forEach方法来遍历每一个参数。取而代之我们提取forEach方法对象的引用并使用其call方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 同样也可先转化为一个数组 var args = [].slice.call(arguments);

function highlight() {
	[].forEach.call(arguments, function(widget) {
		widget.setBackground(&quot;yellow&quot;);
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何使一个对象“看起来像数组”，数组对象的基本契约总共有两个简单规则&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;具有一个范围在0-2^32-1的整型length属性。&lt;/li&gt;
  &lt;li&gt;length属性大于该对象的最大索引。索引的范围是0-2^32-2的整数，它的字符串表示就是该对象的一个key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arrayLike = {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3}
var result = Array.prototype.map.call(arrayLike, function(s) {
	return s.toUpperCase();
});

// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串也表现为不可变的数组，因为它们是可索引的， 并且其长度也可以通过length属性获取。因此，Array.prototype中的方法操作字符串不回修改原始数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var result = Array.prototype.map.call(&quot;abc&quot;, function(s) {
	return s.toUpperCase();	
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于使用Array.prototype中的方法，在增加或删除索引属性的时候它们都会强制的更新length属性。所有的Array.prototype方法在类数组中可以通用。&lt;/p&gt;

&lt;p&gt;只有一个Array方法不是通用的那就是数组连接方法concat。该方法可以由任意的类数组调用但是它会检查其参数的[[Class]]属性，如果是一个真实的数组才会连接，如果不是例子如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function nameColum() {
	return [&quot;Names&quot;].concat(arguments);
}

namesColumn(&quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;);


// [&quot;Names&quot;, {.0: &quot;Alice&quot;, 1: &quot;Bob&quot;, 2: &quot;Chris&quot; }]

这种时候我们可以使用数组转换的方法
function nameColum() {
	return [&quot;Names&quot;].concat([].slice.call(arguments));
}

namesColumn(&quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;);

// [&quot;Names&quot;, &quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;数组字面量优于数组构造函数&quot;&gt;数组字面量优于数组构造函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var a = [1, 2, 3, 4, 5];

也可以使用数组构造函数来替代

var a = new Array(1, 2, 3, 4, 5);


有这样几个问题
首先要保证没有人重新包装过Array变量
function f(Array) {
	return new Array(1, 2, 3, 4, 5);
}

f(String);  //  new String(1)

其次要确保没人修改过全局Array变量

Array = String;
new Array(1, 2, 3, 4, 5); // new String(1)



还有一个问题 

[&quot;hello&quot;] 和 new Array(&quot;hello&quot;) 行为虽然一致

但是

[17] 和 new Array(17) 行为完全不同了

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用数组字面量替代数组构造函数&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">使用Object的直接实例构造轻量级的字典</summary></entry><entry><title type="html">Effective JavaScript (七)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/19/read-book-effective-seven/" rel="alternate" type="text/html" title="Effective JavaScript (七)" /><published>2018-09-19T00:00:00+08:00</published><updated>2018-09-19T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/19/read-book-effective-seven</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/19/read-book-effective-seven/">&lt;h2 id=&quot;理解prototypegetprototypeof-和__proto__之间的不同&quot;&gt;理解prototype,getPrototypeOf 和__proto__之间的不同&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function User(name, passwordHash) {
	this.name = name;
	this.passwordHash = passwordHash;
}

User.prototype.toString = function() {
	return &quot;[User &quot; + this.name + &quot; ]&quot;;
};

User.prototype.checkPassword = function(password) {
	return hash(password) === this.passwordHash;
};

var u = new User(&quot;sfalken&quot;, &quot;objjowewe&quot;);

// ES5 提供了Obejct.getPrototypeOf() 来获得对象的原型
Object.getPrototypeOf(u) === User.prototype // true

非标准的环境提供一个特殊的__proto__属性，在这些环境下可以这样检测
u.__proto__ === User.prototype // true


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用objectgetprototypeof的函数而不要使用__proto__属性&quot;&gt;使用Object.getPrototypeOf的函数而不要使用__proto__属性&lt;/h2&gt;
&lt;p&gt;并不是所有的JavaScript环境都支持通过__proto__属性来获取对象的原型，因此该属性并不是完全兼容的。由于__proto__会污染所有的对象，因此它会导致大量的Bug。&lt;/p&gt;

&lt;p&gt;但是无论在什么情况下 &lt;code&gt;Object.getPrototypeOf&lt;/code&gt;函数都是有效的。&lt;/p&gt;

&lt;p&gt;对于没有提供ES5 API的JavaScript环境，我们可以利用__proto__属性来实现Object.getPrototypeOf的函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(typeof Object.getPrototypeOf === 'undefined') {
	Object.getPrototypeOf = function(obj) {
		var t = typeof obj;
		if(!obj || (t !== 'object' &amp;amp;&amp;amp; t !== 'function')) {
			throw new TypeError(&quot;not an object&quot;);
		}

		return obj.__proto__;
	};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;始终不要修改__ptoto__属性&quot;&gt;始终不要修改__ptoto__属性&lt;/h2&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;避免修改__proto__属性的最明显原因是可移植问题。毕竟不是所有平台都支持&lt;/li&gt;
  &lt;li&gt;避免修改__proto__属性的另一个原因是性能问题&lt;/li&gt;
  &lt;li&gt;避免修改__proto__属性的最大原因是为了保持行为的可预测性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用ES5中的Object.create函数创建一个具有自定义原型链的新对象。对于不支持的ES5环境下下面有一种不依赖于__proto__可移植的实现。&lt;/p&gt;

&lt;h2 id=&quot;使用构造函数与new操作符无关&quot;&gt;使用构造函数与new操作符无关&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function User(name, passwordHash) {
	this.name = name;
	this.passwordHash = passwordHash;
}
如果使用new操作符调用构造函数会是实例化一个对象，不使用new函数的接收者将是全局对象。


var u = User(&quot;hello&quot;, &quot;pass&quot;);

u; // undefined
this.name // &quot;hello&quot;
this.passwordHash // &quot;pass&quot;

如果User定为ES5的严格代码，那么它的接收者默认为undefined

function User(name, passwordHash) {
	'use strict';
	this.name = name;
	this.passwordHash = passwordHash;
}
var u = User(&quot;hello&quot;, &quot;pass&quot;);

// error this is undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以无论是否用new都可以使用构造函数，为了保证代码的健壮性最好是提供一个不管怎样都会工作的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function User(name, pass) {
	if(!(this instanceof User)) {
		return new User(name, pass);
	}

	this.name = name;
	this.pass = pass;
}

var x = User(&quot;hello&quot;, &quot;pas1&quot;);

var y = new User(&quot;hel&quot;, &quot;pas2&quot;);

x instanceof User // true

y instanceof User // true



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式不管怎样调用构造函数都会返回一个继承了User.prototype的实例对象。	
这种模式的缺点是有一次额外的函数调用，ES5有一种更奇异的调用方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function User(name, pass) {
	var self = this instanceof User
		? this
		: Obejct.create(User.prototype);

	self.name = name;
	self.pass = pass;
	return self;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式只有在ES5中才可以使用，对于不支持的环境，我们可以制造一个兼容性的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这里只实现了单参数版本的Object.create
if(typeof Object.creat === 'undefined') {
	Object.create = function(prototype) {
		function C() {}
		C.prototype = prototype;
		return new C();
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;在原型中存储方法&quot;&gt;在原型中存储方法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;将方法存储到实例对象中将创建该函数的多个副本，因为每个实例对象都有一份副本&lt;/li&gt;
  &lt;li&gt;将方法存储于原型中优于存储在实例对象中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用闭包存储私有变量&quot;&gt;使用闭包存储私有变量&lt;/h2&gt;
&lt;p&gt;闭包将数据存储到封闭的变量中而不提供对这些变量的直接访问，获取闭包内容结构的唯一方式是该函数显示的提供获取它的途径。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;对象和闭包剧哟相反的策略，对象的属性会被自动暴露出去，然而闭包中的变量会被自动隐藏起来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以利用这一特性在对象中存储真正的私有数据。不是将数据作为对象属性来存储而是在构造函数中以变量的方式来存储它，并将对象的方法转为引用这些变量的闭包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function User(name, passwordHash) {
	this.toString = function() {
		return &quot;[User &quot; + name +&quot;]&quot;;
	}
	this.checkPassword = function(password) {
		return hash(password) === passwordHash;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里name和passwordHash并不是以this的属性存储的，读取不到this.name 和this.passwordHash， User不包含任何实例属性。
该模式有一个缺点为了让构造函数的变量 在使用它们的方法的作用域中，这些方法必须置于实例对象中。 因此违背了上一条&lt;code&gt;在原型中存储方法&lt;/code&gt;
但是为了那些看中保障信息隐藏的情形来说，这点额外代价是值得的&lt;/p&gt;

&lt;h2 id=&quot;在子类的构造函数中调用父类的构造函数&quot;&gt;在子类的构造函数中调用父类的构造函数&lt;/h2&gt;
&lt;p&gt;如果正确构建父子级关系的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Actor(scene, x, y) {
	this.scene = scene;
	this.x = x;
	this.y = y;
	scene.register(this);
}

Actor.prototype.moveTo = function(x, y) {
	this.x = x;
	this.y = y;
	this.scene.draw();
}

Actor.prototype.exit = function() {
	this.scene.unregister(this);
	this.scene.draw();
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们要创建一个Actor的一个子类， 名字为SpaceShip怎么办&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function SpaceShip(scene, x, y) {
	Actor.call(this, scene, x, y);  
	// 这里SpaceShip的实例对象作为方法的接收者，会将Actor的实例属性加到SpaceShip的实例上，从而继承了Actor的实例属性

	this.points = {};
}

Actor.prototype.moveTo = function(x, y) {
	this.x = x;
	this.y = y;
	this.scene.draw();
}

Actor.prototype.exit = function() {
	this.scene.unregister(this);
	this.scene.draw();
}

如何继承Actor的prototype中的方法呢，我们可以使用之前提到过的ES5下的 
Object.create(非ES5需要自己实现Object.create)

SpaceShip.prototype = Object.create(Actor.prototype);

这样就很好的实现了继承


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;避免使用轻率的猴子补丁&quot;&gt;避免使用轻率的猴子补丁&lt;/h2&gt;

&lt;p&gt;由于对象共享原型，因此每一个对象都可以增加、删除、或修改原型的属性，这个有争议的实现通常被称为猴子补丁（monkey-patching）&lt;/p&gt;

&lt;p&gt;猴子补丁的吸引力在于它的强大。数组缺少一个有用的方法吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Array.prototype.split = function(i) {
	return [this.slice(0, i), this.slice(i)];
}

//Error Everry array instance has a split method
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当多个库以不兼容的方式给同一个原型打猴子补丁时，问题便出现了，另外的库可能使用同一个方法给Array.prototype打猴子补丁，这样会有冲突。
一种替代的方法是增加一个&lt;code&gt;addArrayMethods&lt;/code&gt;方法,用户可以选择调用或者忽略&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function addArrayMethods() {
	Array.prototype.split = function(i) {
		return [this.slice(0,i), this.slice(i)];
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尽管猴子补丁很危险但是有一种特别可靠而且有价值的使用场景 polyfill. ES5定义一些新的Array方法（forEach, map和filter）,如果一些浏览器版本可能不支持这些版本我们可以通过猴子补丁来实现。由于这些行为是标准化的，所以不会造成库与库之间的不兼容风险。&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">理解prototype,getPrototypeOf 和__proto__之间的不同</summary></entry><entry><title type="html">函数柯里化</title><link href="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2018/09/17/js-base-currying/" rel="alternate" type="text/html" title="函数柯里化" /><published>2018-09-17T00:00:00+08:00</published><updated>2018-09-17T00:00:00+08:00</updated><id>/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2018/09/17/js-base-currying</id><content type="html" xml:base="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2018/09/17/js-base-currying/">&lt;h2 id=&quot;js-函数柯里化&quot;&gt;JS 函数柯里化&lt;/h2&gt;
&lt;p&gt;什么是函数柯里化？ 柯里化通常也称部分求值，其含义是给函数分步传递参数。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个简单的函数柯里化例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var add = function(x, y) {
	return x + y;
}

add(1, 2);

var addCurry = function(x) {
	return function(y) {
		return x + y;
	}
}

addCurry(1)(2);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子是一个最简单的柯里化例子， 现在又有新的需要我需要能传多个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var add = function(items) {
	return items.reduce(function(a, b) {
		return a + b;
	});
}

add([1, 2, 3, 4]);

但如果要求把每个数乘以10之后再相加，那么：

var add = function(items, multi) {

	return items.map(function(item) {
		return item * multi
	}).reduce(function(a, b) {
		return a + b;
	})

}

console.log(add([1, 2, 3, 4], 10));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是柯里化实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var adder = function() {
	var _args = [];
	return function() {
		if(arguments.length === 0) {
			return _args.reduce(function(a, b) {
				return a + b;
			});
		}

		[].push.apply(args, [].slice.call(arguments))

		return arguments.callee;
	}
}


var sum = adder();

console.log(sum);

sum(100, 200)(300);   // 调用形式灵活， 一次调用可输入一个或多个参数， 并且支持链式调用

sum(400);

console.log(sum());  // 没有参数进行加总计算

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;adder是柯里化了的函数，它返回一个新的函数，新的函数接收可分批次接受新的参数，延迟到最后一次计算。&lt;/p&gt;

&lt;p&gt;通用的柯里化函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var currying = function(fn) {
	var _args = [];
	return function() {
		if(arguments.length === 0) {
			return fn.apply(this, _args);
		}

		Array.prototype.push.apply(_args, [].slice.call(arguments));
		return arguments.callee;
	}
}

var multi = function() {
	var total = 0;
	for(var i = 0, c = arguments.length; i &amp;lt; c; i++) {
		total += c;
	}

	// for一个特别骚的写法
	for(var i = 0, c; c = arguments[i++];) {
		total += c;
	}

	return total;
}

var sum = currying(multi);

sum(100, 200)(300);
sum(400);

console.log(sum());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码其实是一个高阶函数。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;高阶函数是指操作函数的函数，它接受一个或者多个函数作为参数，并返回一个新函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此外还依赖闭包的特性，来保存中间过程中输入的参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;函数可以作为参数传递&lt;/li&gt;
  &lt;li&gt;函数能够作为函数的返回值&lt;/li&gt;
  &lt;li&gt;闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;柯里化的作用&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;延迟计算&lt;/li&gt;
  &lt;li&gt;参数复用， 当在多次调用同一个函数，并且传递的参数绝大多数相同，那么该函数可能是一个很好的柯里化候选&lt;/li&gt;
  &lt;li&gt;动态创建函数， 这可以是在部分计算出结果后，在此基础上动态生成新的函数处理后面的业务，这样省略了计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如一个绑定事件的辅助方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var addEvent = function(el, type, fn, capture) {
	if(window.addEventListener) {
		el.addEventListener(type, function(e) {
			fn.call(el, e);
		}, capture);
	} else if(window.attachEvent) {
		el.attachEvent(&quot;on&quot;+type, function(e) {
			fn.call(el, e);
		})
	}
}

每次添加事件处理都要执行一遍 if...else...，其实在一个浏览器中只要一次判定就可以了，把根据一次判定之后的结果动态生成新的函数，以后就不必重新计算。

var addEvent = (function(){
    if (window.addEventListener) {
        return function(el, sType, fn, capture) {
            el.addEventListener(sType, function(e) {
                fn.call(el, e);
            }, (capture));
        };
    } else if (window.attachEvent) {
        return function(el, sType, fn, capture) {
            el.attachEvent(&quot;on&quot; + sType, function(e) {
                fn.call(el, e);
            });
        };
    }
})();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Function.prototype.bind 方法也是柯里化应用&lt;/p&gt;

&lt;p&gt;与 call/apply 方法直接执行不同，bind 方法 将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = {x: 888};
var bar = function () {
    console.log(this.x);
}.bind(foo);               // 绑定
bar();                     // 888

// 猜测bind的实现

Function.prototype.testBind = function (scope) {
    var fn = this;                    //// this 指向的是调用 testBind 方法的一个函数， 
    return function () {
        return fn.apply(scope);
    }
};
var testBindBar = bar.testBind(foo);  // 绑定 foo，延迟执行
console.log(testBindBar);             // Function (可见，bind之后返回的是一个延迟执行的新函数)
testBindBar();                        // 888

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来看这道面试题
编程题目的要求如下，完成plus函数，通过全部的测试用例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;'use strict';
function plus(n){
  
}
module.exports = plus



'use strict';
var assert = require('assert')

var plus = require('../lib/assign-4')

describe('闭包应用',function(){
  it('plus(0) === 0',function(){
    assert.equal(0,plus(0).toString())
  })
  it('plus(1)(1)(2)(3)(5) === 12',function(){
    assert.equal(12,plus(1)(1)(2)(3)(5).toString())
  })
  it('plus(1)(4)(2)(3) === 10',function(){
    assert.equal(10,plus(1)(4)(2)(3).toString())
  })
  it('方法引用',function(){
    var plus2 = plus(1)(1)
    assert.equal(12,plus2(1)(4)(2)(3).toString())
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
'use strict';
function plus(num){
	var adder = function() {
		var _args = [];

		var _adder = function () {
			[].push.apply(_args, [].slice.call(arguments));
			return _adder;
		}

		_adder.toString = function() {
			return _args.reduce(function(a, b) {
				return a + b;
			});
		}	

		return _adder;
	}

	
	return adder()(num);
  
}


module.exports = plus;

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zztt/p/4142891.html#3078374&quot;&gt;函数 currying 柯里化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="计算机基础" /><category term="javascript" /><summary type="html">JS 函数柯里化 什么是函数柯里化？ 柯里化通常也称部分求值，其含义是给函数分步传递参数。 curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</summary></entry><entry><title type="html">Effective JavaScript (六)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-six/" rel="alternate" type="text/html" title="Effective JavaScript (六)" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-six</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-six/">&lt;h2 id=&quot;函数调用&quot;&gt;函数调用&lt;/h2&gt;
&lt;p&gt;理解函数调用， 方法调用，构造函数调用之间的不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
最简单的函数调用
function hello(username) {
	return &quot;hello, &quot; + username;
}

hello(&quot;Keyser soze&quot;);

方法调用
var obj = {
	hello: function() {
		return &quot;hello, &quot; + this.username;
	},
	username: &quot;Hans, Gruber&quot;;
}

obj.hello(); // hello, Hans, Gruber


// 在函数调用过程中由调用表达式自身来确定this变量的绑定。 
  
构造函数调用

function User(name, pass) {
	this.name = name;
	this.pass = pass;
}  

var u = new User(&quot;sketcon&quot;, &quot;123456&quot;);

与函数调用和方法调用不同的是，构造函数调用将一个全新的对象作为this变量的值，并隐式的返回这个对象作为调用结果。
构造函数的主要职责是初始化这个新对象。


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;熟练掌握高阶函数&quot;&gt;熟练掌握高阶函数&lt;/h2&gt;
&lt;p&gt;高阶函数无非就是将函数作为参数或返回值的函数。将函数作为参数通常称为回调函数。&lt;/p&gt;

&lt;h2 id=&quot;使用call方法自定义接收者来调用方法&quot;&gt;使用call方法自定义接收者来调用方法&lt;/h2&gt;
&lt;p&gt;通常情况下，函数或方法的接接收者（即绑定到特殊关键字this的值）是由调用者的语法决定的。但是有时我需要自定义一个接收者，幸运的是函数有一个内置的方法call来自定义接收者。可以通过函数对象的call方法来调用自身。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f.call(obj, arg1, arg2, arg3);

f(arg1, arg2, arg3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同的是第一个参数提供了一个显示的接收者对象。&lt;/p&gt;

&lt;h2 id=&quot;使用apply方法通过不同数量的参数调用函数&quot;&gt;使用apply方法通过不同数量的参数调用函数&lt;/h2&gt;

&lt;p&gt;这里理解有误区，接受一个数组的参数，但是方法调用时将参数依次传入方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;average 函数是一个称为可变参数或可变元的函数（函数的元市值其期望的参数个数）

average(1, 2, 3);

average(1);

average(1, 2, 3, 7, 9);

可变参数的版本更加简洁，优雅。


averageOfArray([1, 2, 3]);

averageOfArray([1]);

averageOfArray([1, 2, 3, 7, 9]);


// 本来average 只接受可变参数，假设我有这样一个数字数组， average函数中没有this引用，所以简单的传null就可以。
var scores = getAllScores();
average.apply(null, scores)  
传入一个数组，调用时这样 average(scores[0], scores[1], scores[2])





使用apply方法指定一个可计算的参数数组来调用可变参数的函数。
使用apply方法的第一个参数给可变参数的方法提供一个接收者。

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用arguments创建可变参数的函数&quot;&gt;使用arguments创建可变参数的函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;参数可变函数的实现
function average() {
	for(var i = 0, sum = 0, n = argumants.length; i &amp;lt; n; i++) {
		sum += arguments[i];
	}

	return sum / n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变参数的函数提供了灵活的接口，不同的调用者可以使用不同数量的参数来调用它们，但是它们自身也失去了一点便利。如果使用者要使用数组的参数则只能使用 apply。 
apply方法会降低可读性而且经常导致性能损失&lt;/p&gt;

&lt;p&gt;好的经验是&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果提供了一个便利的可变参数的函数，最好也提供一个需要显示指定数组的固定元数的版本。这样可以编写一个轻量级的封装，并委托固定元数的版本来实现可变参数的函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比较拗口，代码比较直观如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
固定元数的版本实现 用来作为数组参数的调用
function averageOfArray(a) {
	for(var i = 0, sum = 0, n = a.length; i &amp;lt; n; i++) {
		sum += a[i];
	}

	return sum / n;
}

averageOfArray([1, 2, 3]);


参数可变函数的实现可以通过调用 固定元数版本来实现
function average() {
	// averageOfArray本来就支持数组 所以无论average传入数组还是啥
	return averageOfArray(arguments);
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;永远不要修改arguments对象&quot;&gt;永远不要修改arguments对象&lt;/h2&gt;
&lt;p&gt;不要修改arguments对象，并且将arguments对象复制到一个真正的数组中再进行调整。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
	add: function(x, y) { return x + y; }
}

function callMethod(obj, method) {
	var shift = [].shift;
	shift.call(arguments);
	shift.call(arguments);

	return obj[method].apply(obj, arguments);
}

callMethod(obj, &quot;add&quot;, 17, 25);  // cannot read property &quot;apply&quot; of undefined   17[25]

这里的arguments 对象并不是函数参数的副本，所有命名参数都是arguments对象中对应索引的别名。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;永远不要修改arguments对象是更为安全的，通过一开始复制参数中的元素到一个真正的数组的方式，很容易避免修改arguments对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var args = [].slice.call(argumants);

slice会复制整个数组，其结果是一个真正的标准Array类型实例。

function callMethod(obj, method) {
	var args = [].slice.call(arguments, 2);
	return obj[method].apply(obj, args);
}

callMethod(obj, &quot;add&quot;, 17, 25);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用变量保存arguments的引用&quot;&gt;使用变量保存arguments的引用&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// 实现一个迭代器


function values() {
	var i = 0, n = arguments.length;
	return {
		hasNext: function() {
			return i &amp;lt; n;
		},
		next: function() {
			if(i &amp;gt;= n) {
				throw new Error(&quot;end of iteration&quot;);
			}
			return arguments[i++]; // wrong arguments;
		}
	}
}

var it = values(1, 2, 3, 5, 78);

it.next(); //undefined

it.next(); //undefined

it.next(); //undefined

每次调用next的时候，next方法内部会存在一个arguments这里可能我们关心的只是values的arguments, 所以正确的方法是将values的arguments保存下来

function values() {
	var i = 0, n = arguments.length, arg = arguments;
	return {
		hasNext: function() {
			return i &amp;lt; n;
		},
		next: function() {
			if(i &amp;gt;= n) {
				throw new Error(&quot;end of iteration&quot;);
			}
			return arg[i++];
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用bind方法提取具有确定接收者的方法&quot;&gt;使用bind方法提取具有确定接收者的方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var buffer = {
	entries: [],
	add: function(s) {
		this.entries.push(s);
	},
	concat: function() {
		return this.entries.join(&quot;&quot;);
	}
}

var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];

source.forEach(buffer.add);  // error: entries is undefined


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;buffer.add 方法的接收者并不是buffer对象，函数的接收者取决于它是如何被调用，
不过我们并没有调用它，而是把它传给了forEach方法
而我们并不知道forEach在哪里调用了它，事实上forEach方法的实现使用全局对象作为默认的接收者。由于全局对象没有entries属性所以这段代码抛出了一个错误。
幸运的是forEach允许调用者提供一个可选的参数作为回调函数的接收者，所以我们可以很轻松的修复该例子。&lt;/p&gt;

&lt;p&gt;方法一&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];

source.forEach(buffer.add, buffer); 


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并非所有的高阶函数都会为使用者提供其毁掉函数的接收者。如果forEach不接受额外的接收者参数怎么办&lt;/p&gt;

&lt;p&gt;方法二&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source.forEach(function(s) {
	buffer.add(s);
});

bujjer.join();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个函数用来实现绑定其接收者到一个指定的对象是非常常见的，因此ES5标准库直接支持这种模式，函数对象的bind方法需要一个接收者对象，并产生一个以该接收者对象的方法调用的方式调用原来的函数的封装函数。&lt;/p&gt;

&lt;p&gt;方法三&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];

source.forEach(buffer.add.bind(buffer)); 


buffer.add.bind(buffer) 创建了一个新函数而不是修改了bufffer.add函数 该函数将接收者绑定到了buffer对象，而原有函数的接收者保持不变

buffer.add === buffer.add.bind(buffer);  // false;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用bind实现函数柯里化&quot;&gt;使用bind实现函数柯里化&lt;/h2&gt;
&lt;p&gt;函数对象的bind方法除了具有降方法绑定到接收者的用途外，它还有更多功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function simpleURL(protocol, domain, path) {
	return protocol + &quot;://&quot; + domain + &quot;/&quot; + path;
}

var urls = paths.map(function(path) {
	return simpleURL(&quot;http&quot;, siteDomain, path);
});


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传给simpleURL的前两个参数是固定的， 只有第三个参数在变化，我们可以通过调用simpleURL函数的bind方法来自动构造该匿名函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var urls = path.map(simpleURL.bind(null, &quot;http&quot;, siteDomain));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对simpleURL.bind的调用产生了一个委托到simpleURL的新函数，bind的第一个参数提供了接收者的值， 由于simpleURL.bind不需要引用this，所以可以使用任何值。使用null和undefined是习惯用法。 simpleURL.bind的其余参数和提供给你新函数的所有参数共同组成了传递给simpleURL的参数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将函数与其参数的一个子集绑定的技术称为函数柯里化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;不要信赖函数对象的tostring方法&quot;&gt;不要信赖函数对象的toString方法&lt;/h2&gt;

&lt;p&gt;JavaScript有一个非凡的特性， 即将其源代码重现为字符串的能力&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function(x) { 
	return x + 1 
}).toString();

// &quot;function (x) {\n return x + 1; \n}&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECMAScript标准对于函数对象的toString方法的返回结果并没有任何要求。这意味着不同的JavaScript引擎将产生不同的结果，甚至产生的字符串跟函数并不相关。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(x) { 
	return x + 1 
}).bind(16).toString();

// &quot;function (x) {\n [native code] \n}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于bind函数通常是由其他语言实现的通常c++，宿主提供一个编译后的函数，在此环境下通常没有源代码可展示。&lt;/p&gt;

&lt;p&gt;还有一点就是 toString方法生成的源代码并不展示闭包中保存的和内部变量引用相关的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function(x) {
	return function(y) {
		return x + y;
	}	
})(42).toString();

// &quot;function(y) {\n return x + y; \n }&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;总而言之，应该避免使用函数对象的toString方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;避免使用非标准的栈检查属性&quot;&gt;避免使用非标准的栈检查属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;arguments.callee 指向使用该arguments对象被调用的函数&lt;/li&gt;
  &lt;li&gt;arguments.caller 指向调用该arugments对象的函数（该arguments对象调用函数的函数）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;出于安全考虑大多环境移除了arguments.caller,因此它是不可靠的&lt;/p&gt;

&lt;p&gt;许多JavaScript环境提供了一个相似的函数对象属性—非标准但是普遍适用的caller属性。 它指向函数最近的调用者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function revealCaller() {
	return revealCaller.caller;
}

function start() {
	return revealCaller();
}

start() === start;  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;ES5的严格模式禁止使用arguments.caller 和arguments.callee ，因为它们不具备良好的可移植性， 非标准的函数对象caller属性应该避免使用，因为在包含全部栈信息方面，它是不可靠的。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">函数调用 理解函数调用， 方法调用，构造函数调用之间的不同。</summary></entry><entry><title type="html">Effective JavaScript (五)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five/" rel="alternate" type="text/html" title="Effective JavaScript (五)" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/09/11/read-book-effective-five/">&lt;h2 id=&quot;理解变量提升&quot;&gt;理解变量提升&lt;/h2&gt;

&lt;p&gt;try…catch 语句将补货的异常绑定到一个变量，该变量的作用域只是catch语句块。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
  function test() {
    var x = &quot;var&quot;, result = [];
    result.push(x);

    try {
      throw &quot;exception&quot;;
    } catch(x) {
      x = &quot;catch&quot;;
    }

    result.push(x);

    return result;
  }

  test(); // [&quot;var&quot;, &quot;var&quot;]
  

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用立即调用函数iife创建局部作用域&quot;&gt;使用立即调用函数IIFE创建局部作用域&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function wrapElements(a) {
  var result = [], i, n;
  for(i = 0, n = a.length; i &amp;lt; n; i++) {
    result[i] = function() { return a[i] }
  }

  return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];

f();  // ? 输出结果 undefined


// 更具有欺骗性的例子
function wrapElements(a) {
  var result = [];
  for(var i = 0, n = a.length; i &amp;lt; n; i++) {
    result[i] = function() { return a[i] }
  }

  return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];


f();  // ? 输出结果 undefined


// 为了避免这种问题需要用一个立即调用的函数创建一个局部作用域

(function() {
  var j = i;
  result[j] = function() { return a[j]; }
})();

// or

(function(j) {
  result[j] = function() { return a[j]; }
})(i);


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;当心命名函数表达式笨拙的作用域&quot;&gt;当心命名函数表达式笨拙的作用域&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function double(x) { return x * 2; }

这里既可以是一个函数声明，也可以是一个命名函数表达式

var f = function(x) { return x * 2; }

var f = function double(x) { return x * 2 }

根据ECMAScript规范， 此语句将该函数绑定到变量f，而不是变量double。

匿名和命名函数表但是的官方区别在于后者会绑定到其函数名相同的变量上，该变量将作为该函数内的一个局部变量。（只能在函数内部调用）可以用来写递归函数表达式

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;命名函数表达式是作用域和兼容性问题臭名昭著的来源，这归结于ECMAScript规范的历史中很不幸的错误以及流行的JavaScript引擎中的Bug. 规范的错误在ES3中就已经存在，JavaScript引擎被要求将命名函数表达式的作用域表示为一个对象，这有点像with，该作用域对象也继承了Object.prototype的属性，这意味着仅仅是给函数表达式命名也会将Object.prototype中的所有属性引入到作用域中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var constructor = function() { return null; }

var f = function f() {
  return constructor();
}

f();  // 结果 {} (in ES3 环境中)。这里错误的使用了Object.prototype.constructor (Object的构造函数)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;幸运的ES5修正了这个问题，但是有些JavaScript仍然使用过时的对象作用域，还有些更不符合标准的对于匿名函数的表达式也使用对象的作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var constructor = function() { return null; }

var f = function () {
  return constructor();
}

f();  // 结果 {} (在更不标准的环境中)。本来这里应该正确解析不使用对象的作用域但是不标准的环境导致匿名函数表达式仍然使用对象作用域

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;最好的做法就是避免任何时候在Object.prototype中添加属性，以及避免使用与标准Object.prototype属性同名的局部变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在流行的JavaScript的引擎中的另一个缺陷是函数命名表达式的声明进行提升。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = g() { returen 17; }
g(); // 17 (在非标准的环境中会返回17，标准环境会报错 g is not defined)

我们应该怎样做
var f = function g() { return 17; }
var g = null;

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于命名函数表达式会导致很多问题，所以不值得使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;当心局部块函数声明笨拙的作用域&quot;&gt;当心局部块函数声明笨拙的作用域&lt;/h2&gt;

&lt;p&gt;比较有迷惑性的一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function f() { return &quot;global&quot;; }

function test(x) {
  function f() { return &quot;local&quot;; }

  var result = [];
  if(x) {
    result.push(f());
  }

  result.push(f());
  return result;
}

// 返回结果
test(true); // [&quot;local&quot;, &quot;local&quot;]
test(false); // [&quot;local&quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当函数f放到局部块里将有什么不同呢，首先要记住一点
 &lt;code&gt;JavaScript没有块级作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function f() { return &quot;global&quot;; }

function test(x) {

  var result = [];
  if(x) {
    function f() { return &quot;local&quot;; }
    result.push(f());
  }
console.log(f);
  result.push(f());
  return result;
}

// 返回结果
test(true); // [&quot;local&quot;, &quot;local&quot;]
test(false); // 有些平台显示[&quot;local&quot;] 有些平台返回： f is not a function

你可能认为 第一个结果为[&quot;local&quot;, &quot;global&quot;], 第二个结果为 [&quot;global&quot;], 但是有一点需要记住 JavaScript没有块级作用域
这里根据平台的实现不同结果会不一样,代码很难理解，还会导致性能降低。 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; 对此官方指定函数声明只能出现在其他函数或者程序的最外层。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;编写可移植的函数最好方式是始终避免将函数声明置于局部块或者子语句中，如果想写嵌套函数声明应该将它置于父函数的最外层。如果要根据条件判断选择函数，最好的方法是使用var声明和函数表达式来实现。例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f() { return &quot;global&quot;; }

function test(x) {

  var g = f, result = [];
  if(x) {
    g = function() { return &quot;local&quot;; }
    result.push(g());
  }
  result.push(g());
  return result;
}

这样消除内部变量作用域的神秘性，结果很明确，函数可移植。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;避免使用eval创建局部变量&quot;&gt;避免使用eval创建局部变量&lt;/h2&gt;

&lt;p&gt;使用eval的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var y = &quot;global&quot;;
function test(x) {
  if(x) {
    eval(&quot;var y = 'local';&quot;);
  }
  return y;
}

test(true); // &quot;local&quot;;
test(false); // &quot;global&quot;

var y = &quot;global&quot;;
function test(src) {
  if(x) {
    eval(src);
  }
  return y;
}

test(&quot;var y = 'local';&quot;); // &quot;local&quot;;
test(&quot;var z = 'local';&quot;); // &quot;global&quot;
这段代码很脆弱，也很不安全，它赋予了外部调用者能改变test函数内部作用域的能力。ES5严格模式将eval函数运行在一个嵌套的作用域中防止这种污染

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;保证eval函数不影响外部作用域的一个简单的方法是一个明确的嵌套作用域中运行它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var y = &quot;global&quot;;
function test(src) {
  if(x) {
    (function() { eval(src); })();
  }
  return y;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;间接调用eval函数由于直接调用&quot;&gt;间接调用eval函数由于直接调用&lt;/h2&gt;
&lt;p&gt;大部分函数只能访问他们所在的作用域，而不能访问除此之外的作用域。然而 eval函数具有访问调用它那时的整个作用域的能力。这是很强大的能力，但是导致一个问题eval很难很高效的调用一个任何函数，因为一旦被调用的是eval函数，那么每个函数调用都需要确保在运行时整个作用域对eval函数是可访问的。&lt;/p&gt;

&lt;p&gt;总而言之我们使用过程中尽可能间接调用eval而不要直接调用。代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f = eval;
f(&quot;x&quot;);

编写间接调用的一种简洁方法是

(0, eval)(src);  // 逗号表达式求值返回eval函数，然后调用。  这种表达式被视为eval的一种间接调用。
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">理解变量提升</summary></entry><entry><title type="html">理解rem布局</title><link href="/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem/" rel="alternate" type="text/html" title="理解rem布局" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem</id><content type="html" xml:base="/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/2018/09/11/layout-study-rem/">&lt;h2 id=&quot;理解变量提升&quot;&gt;理解变量提升&lt;/h2&gt;

&lt;p&gt;JavaScript的一个便利是能够离开 语句结束分号 工作。 删除分号后，结果变得轻量而优雅，比如下面这个例子去掉所有分号，JavaScript会自动插入分号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  function Point(x, y) {
    this.x = x || 0
    this.y = y || 0
  }

  Point.prototype.isOrigin = function() {
    return this.x === 0 &amp;amp;&amp;amp; this.y === 0
  }

&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="页面布局" /><category term="css" /><summary type="html">理解变量提升</summary></entry><entry><title type="html">JAVASCRIPT面试题</title><link href="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js/" rel="alternate" type="text/html" title="JAVASCRIPT面试题" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-js/">&lt;h3 id=&quot;使用立即调用函数iife创建局部作用域&quot;&gt;使用立即调用函数IIFE创建局部作用域&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function wrapElements(a) {
	var result = [], i, n;
	for(i = 0, n = a.length; i &amp;lt; n; i++) {
		result[i] = function() { return a[i] }
	}

	return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];

f();  // ? 输出结果 undefined


// 更具有欺骗性的例子
function wrapElements(a) {
	var result = [];
	for(var i = 0, n = a.length; i &amp;lt; n; i++) {
		result[i] = function() { return a[i] }
	}

	return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);

var f = wrapped[0];


f();  // ? 输出结果 undefined


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在流行的JavaScript的引擎中的另一个缺陷是函数命名表达式的声明进行提升。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = g() { returen 17; }
g(); // 17 (在非标准的环境中，标准环境会报错 g is not defined)


我们应该怎样做
var f = function g() { return 17; }
var g = null;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var username=&quot;test&quot;;

function hello() {
	&quot;use strict&quot;;
	return &quot;hello, &quot; + this.username;
}

hello(); &quot;hello, undefined&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bind绑定方法接收者，下面例子返回什么结果， 用尽可能多的方法修复该例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var buffer = {
	entries: [],
	add: function(s) {
		this.entries.push(s);
	},
	concat: function() {
		return this.entries.join(&quot;&quot;);
	}
}

var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];

source.forEach(buffer.add);  // error: entries is undefined


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;什么是函数柯里化？柯里化的作用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;延迟计算&lt;/li&gt;
  &lt;li&gt;参数复用， 当在多次调用同一个函数，并且传递的参数绝大多数相同，那么该函数可能是一个很好的柯里化候选&lt;/li&gt;
  &lt;li&gt;动态创建函数， 这可以是在部分计算出结果后，在此基础上动态生成新的函数处理后面的业务，这样省略了计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数柯里化 一道有难度的面试题,完成plus函数 满足通过所有的测试条件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
'use strict';
function plus(n){
  
}
module.exports = plus


'use strict';
var assert = require('assert')

var plus = require('../lib/assign-4')

describe('闭包应用',function(){
  it('plus(0) === 0',function(){
    assert.equal(0,plus(0).toString())
  })
  it('plus(1)(1)(2)(3)(5) === 12',function(){
    assert.equal(12,plus(1)(1)(2)(3)(5).toString())
  })
  it('plus(1)(4)(2)(3) === 10',function(){
    assert.equal(10,plus(1)(4)(2)(3).toString())
  })
  it('方法引用',function(){
    var plus2 = plus(1)(1)
    assert.equal(12,plus2(1)(4)(2)(3).toString())
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;创建一个原型为null的对象用作字典&quot;&gt;创建一个原型为null的对象用作字典&lt;/h3&gt;

&lt;p&gt;防止原型污染的最简单的方式之一就是一开始就不使用原型。但是ES5发布之前并没有一个标准的方式创建一个空原型的新对象。你可能会这样做
该例子是否能创建一个原型为null的对象。不能的话要怎么做&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function C() { }

C.prototype = null;

var o = new C();

Object.getPrototypeOf(o) === null; // false
Object.getPrototypeOf(o) === Object.prototype // true

// ES5之后应该这样做
var x = Object.create(null);

Object.getPrototypeOf(o) === null; // true

在不支持Object.create的JavaScript环境中特殊对象__proto__提供了对对象内部原型链的读写访问

var x = { __proto__: null };

x instanceof Object;  // false;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种貌似更方便，但是有了Object.create函数后，Object.create是更值得推荐的方式。&lt;/p&gt;

&lt;h3 id=&quot;看下面代码mean的输出值时多少&quot;&gt;看下面代码mean的输出值时多少？&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var scores = [98, 74, 85, 77, 93, 100, 89];

var total = 0;

for(score in scores) {
	total += score;
}

var mean = total / socres.length;


mean; // ?   


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;javascript位操作符的诀窍&quot;&gt;JavaScript位操作符的诀窍&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;无符号右移自动转换成数字
&quot;&quot; &amp;gt;&amp;gt;&amp;gt; 0.  // 0
&quot;sdsd&quot; &amp;gt;&amp;gt;&amp;gt; 0   // 0

NaN &amp;gt;&amp;gt;&amp;gt; 0 // 0

undefined &amp;gt;&amp;gt;&amp;gt; 0  // 0
 
null &amp;gt;&amp;gt;&amp;gt; 0 // 0

[] &amp;gt;&amp;gt;&amp;gt; 0  // 0

&quot;70&quot; &amp;gt;&amp;gt;&amp;gt; 0 // 70

{} &amp;gt;&amp;gt;&amp;gt; 0. // Uncaught SyntaxError: Unexpected token &amp;gt;&amp;gt;&amp;gt;

～操作自动转换数字
负数转正数减一， 整数转负数减一， 其他-1

~&quot;sdsd&quot; // -1
~&quot;0&quot;    //-1
~0     //-1
~NaN    //-1
~null    //-1
~undefined    //-1
~[]    //-1
~{}    //-1
~&quot;sdsd&quot;    //-1
~&quot;45sdsd&quot;    //-1
~&quot;-1&quot; // 0
~&quot;1&quot; // -2


&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="JAVASCRIPT" /><summary type="html">使用立即调用函数IIFE创建局部作用域 ```javascript</summary></entry><entry><title type="html">HTML面试题</title><link href="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html/" rel="alternate" type="text/html" title="HTML面试题" /><published>2018-09-11T00:00:00+08:00</published><updated>2018-09-11T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2018/09/11/inverview-html/">&lt;h2 id=&quot;html&quot;&gt;HTML&lt;/h2&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="HTML" /><summary type="html">HTML</summary></entry></feed>