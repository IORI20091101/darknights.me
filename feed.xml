<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-11-06T09:54:44+00:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">git的使用教程(三)</title><link href="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/11/02/senior/" rel="alternate" type="text/html" title="git的使用教程(三)" /><published>2017-11-02T00:00:00+00:00</published><updated>2017-11-02T00:00:00+00:00</updated><id>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/11/02/senior</id><content type="html" xml:base="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/11/02/senior/">&lt;h2 id=&quot;git的高级使用教程&quot;&gt;git的高级使用教程&lt;/h2&gt;

&lt;p&gt;记录一些git的高级用法&lt;/p&gt;

&lt;h2 id=&quot;回滚错误的修改&quot;&gt;回滚错误的修改&lt;/h2&gt;

&lt;h3 id=&quot;git-checkout&quot;&gt;git checkout&lt;/h3&gt;
&lt;p&gt;参考上一篇 &lt;a href=&quot;https://darknights.me/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/11/02/git-medium/&quot;&gt;中级教程&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;git-revert&quot;&gt;git revert&lt;/h3&gt;
&lt;p&gt;建议仔细阅读&lt;a href=&quot;https://github.com/geeeeeeeeek/git-recipes/wiki/2.6-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9#git-revert&quot;&gt;git-revert&lt;/a&gt;
该命令只回滚了一个单独的提交，并没有移除后面的提交，并且保留了提交历史。 但是reset直接把状态回调bug之前之后所有的提交都会遗弃，这样并不安全。&lt;/p&gt;

&lt;p&gt;用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git revert &amp;lt;commit&amp;gt;


# 编辑一些跟踪的文件

# 提交一份快照
$ git commit -m &quot;Make some changes that will be undone&quot;

# 撤销刚刚的提交
$ git revert HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确保你只对本地的修改使用 git reset，而不是公共更改。如果你需要修复一个公共提交，git revert 命令正是被设计来做这个的&lt;/p&gt;

&lt;h2 id=&quot;重写项目历史&quot;&gt;重写项目历史&lt;/h2&gt;

&lt;h3 id=&quot;git-commit-amend&quot;&gt;git commit –amend&lt;/h3&gt;
&lt;p&gt;git commit –amend 命令是修复最新提交的便捷方式，如有需要请在本地使用不要修改公共历史。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log

commit eeeab2ca5f30d70667d6d12ab71f19dd7b958d1c (HEAD -&amp;gt; master)
Author: xxx &amp;lt;xxx@xxx.com&amp;gt;
Date:   Mon Nov 6 15:30:43 2017 +0800

    fix(测试): 测试提交

    测试提交

    Signed-off-by: xxx &amp;lt;xxx@xxx.com&amp;gt;


$ git commit --amend

# 该命令修改后再使用git log得到如下

commit eeeab2ca5f30d70667d6d12ab71f19dd7b958d1c (HEAD -&amp;gt; master)
Author: xxx &amp;lt;xxx@xxx.com&amp;gt;
Date:   Mon Nov 6 15:30:43 2017 +0800

    fix(测试): 测试提交sss

    测试提交sss

    Signed-off-by: xxx &amp;lt;xxx@xxx.com&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;git-rebase&quot;&gt;git rebase&lt;/h3&gt;
&lt;p&gt;变基（rebase, 事实上这个名字十分诡异, 所以在大多数时候直接用英文术语）是将分支移到一个新的基提交的过程。事实上重写了你的项目历史,过程一般如下所示
&lt;img src=&quot;https://darknights.b0.upaiyun.com/assets/images/in-post/git-senior/rebase.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase &amp;lt;base&amp;gt;

# 将当前分支 rebase 到 &amp;lt;base&amp;gt;，这里可以是任何类型的提交引用（ID、分支名、标签，或是 HEAD 的相对引用）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个🌰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 开始新的功能分支
$ git checkout -b feat master
# 编辑文件
$ git commit -a -m &quot;Start developing a feature&quot;

# 在 feature 分支开发了一半的时候，我们意识到项目中有一个安全漏洞:

# 基于master分支创建一个快速修复分支
$ git checkout -b bug master
# 编辑文件
$ git commit -a -m &quot;Fix security hole&quot;
# 合并回master
$ git checkout master
$ git merge bug
$ git branch -d bug

# 将 hotfix 分支并回之后 master，我们有了一个分叉的项目历史。
# 我们用 rebase 整合 feature 分支以获得线性的历史，而不是使用普通的 git merge。
$ git checkout feat
$ git rebase master

$ git checkout master
$ git merge feat

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个🌰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 开始新的功能分支
$ git checkout -b feat master
# 编辑文件
$ git commit -a -m &quot;Start developing a feature&quot;
# 编辑更多文件
$ git commit -a -m &quot;Fix something from the previous commit&quot;

# 直接在 master 上添加文件
$ git checkout master
# 编辑文件
$ git commit -a -m &quot;Fix security hole&quot;

# 开始交互式 rebase
$ git checkout feat
$ git rebase -i master

最后的那个命令会打开一个编辑器，包含 feat 的两个提交，和一些指示：

pick 32618c4 Start developing a feature
pick 62eed47 Fix something from the previous commit

# 你可以更改每个提交前的 pick 命令来决定在 rebase 时提交移动的方式。
# 在我们的例子中，我们只需要用 squash 命令把两个提交并在一起就可以了：

pick 32618c4 Start developing a feature
squash 62eed47 Fix something from the previous commit

# 保存并关闭编辑器以开始 rebase
# 最后，你可以执行一个快速向前的合并，来将完善的 feature 分支整合进主代码库：

git checkout master
git merge feat

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下建议使用rebase而非merge来拉取上游代码。这样所有的记录会被合并为一次commit,而且没有一些不重要的合并来污染提交的时间线&lt;/p&gt;

&lt;h3 id=&quot;git-pull&quot;&gt;git pull&lt;/h3&gt;

&lt;p&gt;在基于 Git 的协作工作流中，将上游更改合并到你的本地仓库是一个常见的工作。我们已经知道应该使用 git fetch，然后是 git merge，但是 git pull 将这两个命令合二为一。&lt;/p&gt;

&lt;p&gt;基于 Rebase 的 Pull&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git pull --rebase &amp;lt;remote&amp;gt;  //此命令会合并远程分支和本地分支而非使用git merge;

$ git checkout master
$ git pull --rebase origin  //简单地将你本地的更改放到其他人已经提交的更改之后。

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;git-cherry-pick&quot;&gt;git cherry-pick&lt;/h3&gt;
&lt;p&gt;只想将远程仓库的一个特定提交合并到自己的分支中该怎么做呢？可以使用git cherry-pick 来选择给定SHA值的提交，然后将其合并到当前分支中：&lt;/p&gt;

&lt;h2 id=&quot;修改tag&quot;&gt;修改tag&lt;/h2&gt;

&lt;h2 id=&quot;git-工作流&quot;&gt;git 工作流&lt;/h2&gt;

&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://github.com/geeeeeeeeek/git-recipes/wiki&quot;&gt;git-recipes&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/news/2016/01/12-git-advanced-commands&quot;&gt;你需要知道的12个Git高级命令&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot;&gt;git - 简明指南&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;git教程&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="工具" /><category term="git" /><summary type="html">git的高级使用教程</summary></entry><entry><title type="html">git的使用教程(二)</title><link href="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/11/02/git-medium/" rel="alternate" type="text/html" title="git的使用教程(二)" /><published>2017-11-02T00:00:00+00:00</published><updated>2017-11-02T00:00:00+00:00</updated><id>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/11/02/git-medium</id><content type="html" xml:base="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/11/02/git-medium/">&lt;h2 id=&quot;git的中级使用教程&quot;&gt;git的中级使用教程&lt;/h2&gt;

&lt;p&gt;记录一些使用率中等的git命令&lt;/p&gt;

&lt;h3 id=&quot;设置用户名和邮箱&quot;&gt;设置用户名和邮箱&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email &quot;email@example.com&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置别名&quot;&gt;配置别名&lt;/h3&gt;
&lt;p&gt;使用git status 太长了怎么破&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global alias.st status
$ git config --global alias.co checkout
$ git config --global alias.ci commit
$ git config --global alias.br branch
$ git config --global alias.unstage 'reset HEAD'
$ git config --global alias.last 'log -1'  //显示最后一次提交信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有这种操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset' --abbrev-commit&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下
&lt;img src=&quot;https://darknights.b0.upaiyun.com/assets/images/in-post/git-medium/0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;git-reset的后悔药&quot;&gt;git reset的后悔药&lt;/h3&gt;
&lt;p&gt;当使用  &lt;code&gt;git reset --hard xxx&lt;/code&gt; 回退到之前的版本,我又想回到最新的版本如何操作呢&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reflog

git reflog --relative-date  //用相对的日期显示引用日志。(如 2 周前）。



ea34578 HEAD@{0}: reset: moving to HEAD^
3628164 HEAD@{1}: commit: append GPL
ea34578 HEAD@{2}: commit: add distributed
cb926e7 HEAD@{3}: commit (initial): wrote a readme file

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样之后又可以使用 reset –hard xxx 乘坐时光机返回了。&lt;/p&gt;

&lt;h3 id=&quot;git-clean&quot;&gt;git clean&lt;/h3&gt;
&lt;p&gt;该命令将未跟踪的文件从工作目录中删除，同git status 然后手动删除一样。该命令无法撤销慎重使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clean -n  //进行预演告诉你哪些文件会被删除并不是真的删除

$ git clean -f  //删除所有未跟踪文件 &amp;lt;code&amp;gt;-f&amp;lt;/code&amp;gt;是必须的

$ git clean -f &amp;lt;path&amp;gt; //移除未跟踪的文件，但限制在某个路径下。

$ git clean -df //移除未跟踪的文件，以及目录。

$ git clean -xf //移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件。

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;resetclean&quot;&gt;reset+clean&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 编辑了一些文件
# 新增了一些文件
# 『糟糕』

# 将跟踪的文件回滚回去
git reset --hard

# 移除未跟踪的文件
git clean -df
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行了 reset/clean 的流程之后，工作目录和缓存区和最近一次提交看上去一模一样，而 git status会认为这是一个干净的工作目录。你可以重新来过了。&lt;/p&gt;

&lt;p&gt;注意，不像 git reset 的第二个栗子，新的文件没有被加入到仓库中。因此，它们不会受到 git reset –hard 的影响，需要 git clean 来删除它们。&lt;/p&gt;

&lt;h3 id=&quot;reset其他用法&quot;&gt;reset其他用法&lt;/h3&gt;
&lt;p&gt;git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
#
#       modified:   readme.txt
#

$ git reset HEAD readme.txt
Unstaged changes after reset:
M       readme.txt



# 另一个例子

# 编辑了hello.py和main.py

# 缓存了目录下所有文件
git add .

# 意识到hello.py和main.py中的修改
# 应该在不同的快照中提交

# 取消main.py缓存
git reset main.py

# 只提交hello.py
git commit -m &quot;Make some changes to hello.py&quot;

# 在另一份快照中提交main.py
git add main.py
git commit -m &quot;Edit main.py&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;git checkout – xxx 丢弃工作区间的修改 此时没有add&lt;/li&gt;
    &lt;li&gt;git reset HEAD xxx 将暂存区的文件撤销放回到工作区间 ，此时已经add&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;git-checkout&quot;&gt;git checkout&lt;/h3&gt;
&lt;p&gt;这里有个checkout的用法比较少用感觉用reset比较多，通常来说git checkout 会有三种用法： 检出文件，检出提交和检出分支，一般我们只关心前两种&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master //切换分支

$ git checkout &amp;lt;commit&amp;gt; &amp;lt;file&amp;gt;

$ git checkout a1e8fb5 hello.py //将某个文件切到某次提交的的样子


$ git checout &amp;lt;commit&amp;gt;  //将所有文件切换到某次提交的样子
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;生产ssh-key&quot;&gt;生产SSH Key&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;

//生产的公钥私钥 会放到服务器的 ~/.ssh/authorized_keys目录下

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;添加远程仓库&quot;&gt;添加远程仓库&lt;/h3&gt;
&lt;p&gt;本地文件夹添加远程仓库并且推送上去,基础文章已经写过这里再次复习一遍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git remote add origin git@github.com:michaelliao/learngit.git

$ git push -u origin master

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;分支管理策略--no-ff&quot;&gt;分支管理策略&lt;code&gt;--no-ff&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;通常，合并分支时，如果可能，Git会用&lt;code&gt;Fast forward模式&lt;/code&gt;，但这种模式下，删除分支后，会丢掉分支信息。&lt;/p&gt;

&lt;p&gt;如果要强制禁用&lt;code&gt;Fast forward&lt;/code&gt;模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
Merge made by the 'recursive' strategy.
 readme.txt |    1 +
 1 file changed, 1 insertion(+)

 //其他操作一样只是合并的时候可以带上 禁用ff模式并且加上注释。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;合并后的结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --graph --pretty=oneline --abbrev-commit
*   7825a50 merge with no-ff
|\
| * 6224937 add merge
|/
*   59bc1cb conflict fixed
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;保存工作现场&quot;&gt;保存工作现场&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git stash
Saved working directory and index state WIP on dev: 6224937 add merge
HEAD is now at 6224937 add merge

$ git stash list  //显示stash列表

$ git stash pop   //相当于 git stash apply + git stash drop   恢复最近的一条


$ git stash apply stash@{0} //指定要恢复的stash

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置文件&quot;&gt;配置文件&lt;/h3&gt;
&lt;p&gt;配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用
每个仓库的Git配置文件都放在.git/config文件中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat .git/config
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[remote &quot;origin&quot;]
    url = git@github.com:michaelliao/learngit.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch &quot;master&quot;]
    remote = origin
    merge = refs/heads/master
[alias]
    last = log -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~
$ cat .gitconfig
[alias]
    co = checkout
    ci = commit
    br = branch
    st = status
[user]
    name = Your Name
    email = your@email.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;使用gitignore&quot;&gt;使用.gitignore&lt;/h3&gt;
&lt;p&gt;有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：
如果你确实想添加该文件，可以用-f强制添加到Git：
或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add -f App.class

$ git check-ignore -v App.class
.gitignore:3:*.class    App.class
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;删除远程分支&quot;&gt;删除远程分支&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git push origin :master 等同于下面的命令推送一个空分支对应远程分支

$ git push origin --delete master

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;丢弃暂存区文件&quot;&gt;丢弃暂存区文件&lt;/h3&gt;

&lt;p&gt;如果一个文件已经add到暂存区，还没有commit，此时如果不想要这个文件了，有两种方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reset HEAD   用版本库内容清空暂存区

$ git rm --cache 删除缓存区内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;允许空提交&quot;&gt;允许空提交&lt;/h3&gt;
&lt;p&gt;即没有任何更改进行commit, 之所以需要这种是我们开发时制定分支推送会部署代码但是有时候没有代码提交只想单独部署这样可以进行推送从而触发部署&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git commit --allow-empty -m &quot;empty&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;文件夹大小写问题&quot;&gt;文件夹大小写问题&lt;/h3&gt;
&lt;p&gt;git 提交文件夹默认是不区分大小写的也就是说max/file 和Max/file 对于远端来说是一样的这样就会有本地和远端文件夹不一样的问题。带来的后果就是java起名字的时候如果文件夹有大小写有可能不识别会有找不到类的问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config core.ignorecase false  //默认是true

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;如何删除一些分支&quot;&gt;如何删除一些分支&lt;/h3&gt;
&lt;p&gt;远程已经删除但是本地还存在。
这种操作通常是我新建分支改完bug推送远程合并结束后,远程分支删掉了本地分支也删掉但是branch -a的时候还存在想删除本地远程分支数据库中的分支时使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ git fetch origin --prune  //update the local database of remote branches

$ git fetch -p origin      //这两条命令都在做一个事情,将本地分支库和远程分支库进行同步如果远程删掉了本地就删掉

$ git fetch origin -p --progress  //可以显示过程

$ git remote update --prune 也可以生效不过我没试过😓

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总有最笨的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -d -r origin/branch_name  //不嫌麻烦可以一条条删掉😂
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;本地分支与远程分支对应&quot;&gt;本地分支与远程分支对应&lt;/h2&gt;

&lt;h3 id=&quot;第一种情况&quot;&gt;第一种情况&lt;/h3&gt;

&lt;p&gt;新建分支直接创建新分支推送到远端即可&lt;/p&gt;

&lt;h3 id=&quot;第二种情况&quot;&gt;第二种情况&lt;/h3&gt;

&lt;p&gt;本地没有分支远端有分支dev&lt;/p&gt;

&lt;p&gt;可以git fetch ,然后直接新建分支&lt;b&gt;跟远端分支名字一样&lt;/b&gt; dev就可以建立链接。&lt;/p&gt;
&lt;h3 id=&quot;另一种解决方案&quot;&gt;另一种解决方案&lt;/h3&gt;
&lt;p&gt;情况二的领域中解决方案
要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是用这个命令创建本地dev分支&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b dev origin/dev


如果此时报错 no tracking information 需要将远程dev和本地dev分支建立链接

$ git branch --set-upstream dev origin/dev

$ git branch --track  dev origin/dev  //该方法同上

//也可以选择git fetch 将远程相关的内容全拉取下来然后直接切换分支

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot;&gt;git - 简明指南&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;git教程&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="工具" /><category term="git" /><summary type="html">git的中级使用教程</summary></entry><entry><title type="html">javascript的位操作</title><link href="/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/01/bin-operate/" rel="alternate" type="text/html" title="javascript的位操作" /><published>2017-11-01T00:00:00+00:00</published><updated>2017-11-01T00:00:00+00:00</updated><id>/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/01/bin-operate</id><content type="html" xml:base="/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/11/01/bin-operate/">&lt;h1 id=&quot;关于javascript中的操作&quot;&gt;关于javascript中的~操作&lt;/h1&gt;

&lt;p&gt;参考文章中有一道面试题,尽管文章已经有了一部分解释但是还有一些点不够明确在此在进行一次分析&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;!~location.href.search(‘abc’)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先再次回顾一下js中的位运算&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;amp; 与&lt;/li&gt;
  &lt;li&gt;| 或&lt;/li&gt;
  &lt;li&gt;~ 非&lt;/li&gt;
  &lt;li&gt;^ 异或&lt;/li&gt;
  &lt;li&gt;&amp;lt;&amp;lt; 左移&lt;/li&gt;
  &lt;li&gt;&amp;gt;&amp;gt; 算数右移(有符号右移)&lt;/li&gt;
  &lt;li&gt;&amp;gt;&amp;gt;&amp;gt; 逻辑右移(无符号右移)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Number.prototype.toString&lt;/p&gt;

&lt;p&gt;Number.prototype.toString方法可以讲数字转化为字符串，有一个可选的参数，用来决定将数字显示为指定的进制，下面可以查看3的二进制表示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-`&quot;&gt; 3..toString(2)

 (3).toString(2)

 Number(3).toString(2)   //这里如果直接 3.toString(2)是会报错的

  &amp;gt;&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-与&quot;&gt;&amp;amp; 与&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;amp;按位与会将操作数和被操作数的相同为进行与运算，如果都为1则为1，如果有一个为0则为0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;101
011
---
001
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-或&quot;&gt;| 或&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;按位或是相同的位置上只要有一个为1就是1，两个都为0则为0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;101
001
---
101
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-非&quot;&gt;~ 非&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;~操作符会将操作数的每一位取反，如果是1则变为0，如果是0则边为1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;101
---
010
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-异或&quot;&gt;^ 异或&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;再来说说异或，这个比较有意思，异或顾名思义看看两个位是否为异——不同，两个位不同则为1，两个位相同则为0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;101
001
---
100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次分析开头的问题&lt;/p&gt;

&lt;p&gt;首先关于indexOf获得的值可能有几种请求 -1,0,1 从这三种进行分析&lt;/p&gt;

&lt;h2 id=&quot;-1&quot;&gt;~-1&lt;/h2&gt;

&lt;p&gt;为了简便计算我这只取8位&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10000001  //这是-1的原码 (真值的绝对值加上符号位)
--------  //进行按位非操作后 这里会改变符号
01111110  //得到此值为正值要获得该值得真值需要然后取反再减一 注意取反的操作不会改变符号
--------
00000000  //最后得到的值是0

//浏览器控制台输出

~-1
0

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;0&quot;&gt;~0&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;00000000  //这是0的原码 (真值的绝对值加上符号位)
--------  //进行按位非操作后 这里会改变符号
11111111  //得到此值该值为负值的补码 要获得该值得真值需要对补码求补即取反+1 (注意取反的操作不会改变符号)
--------
10000001  //最后得到的值是1

//浏览器控制台输出

~0
-1

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;1&quot;&gt;~1&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;00000001  //这是1的原码 (真值的绝对值加上符号位)
--------  //进行按位非操作后 这里会改变符号
11111110  //得到此值该值为负值的补码 要获得该值得真值需要对补码求补即取反+1 (注意取反的操作不会改变符号)
--------
10000010  //最后得到的值是2

//浏览器控制台输出

~1
-2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此在上面问题出现的时候&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~location.href.search('abc')  //未匹配到返回 -1 这里为 ~-1  == 0 ==&amp;gt; !0 == true;
~location.href.search('abc')  //未匹配到返回 0 这里为 ~0  == -1 ==&amp;gt; !-1 == false;
~location.href.search('abc')  //未匹配到返回 1 这里为 ~1  == -2 ==&amp;gt; !-2== false;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此只有返回 -1时&lt;/p&gt;

&lt;p&gt;如果为 -1 说明未匹配到&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;!~location.href.search(‘abc’) ===&amp;gt; true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;得证。&lt;/p&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://yanhaijing.com/javascript/2016/07/20/binary-in-js/&quot;&gt;聊聊JavaScript中的二进制数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html&quot;&gt;原码, 反码, 补码 详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points/&quot;&gt;每一个JavaScript开发者应该了解的浮点知识&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jser.it/blog/2014/07/07/numbers-in-javascript/&quot;&gt;Numbers in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="计算机基础" /><category term="javascript" /><summary type="html">关于javascript中的~操作</summary></entry><entry><title type="html">常用快捷键整理总结</title><link href="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/10/31/quick-key/" rel="alternate" type="text/html" title="常用快捷键整理总结" /><published>2017-10-31T00:00:00+00:00</published><updated>2017-10-31T00:00:00+00:00</updated><id>/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/10/31/quick-key</id><content type="html" xml:base="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/10/31/quick-key/">&lt;h1 id=&quot;工欲善其事必先利其器快捷键总结&quot;&gt;工欲善其事必先利其器快捷键总结&lt;/h1&gt;</content><author><name>toshiba</name></author><category term="生产工具" /><category term="IDE" /><summary type="html">工欲善其事必先利其器快捷键总结</summary></entry><entry><title type="html">原码, 反码, 补码 详解</title><link href="/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/10/31/bin-calculate/" rel="alternate" type="text/html" title="原码, 反码, 补码 详解" /><published>2017-10-31T00:00:00+00:00</published><updated>2017-10-31T00:00:00+00:00</updated><id>/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/10/31/bin-calculate</id><content type="html" xml:base="/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2017/10/31/bin-calculate/">&lt;h1 id=&quot;机器数和真值&quot;&gt;机器数和真值&lt;/h1&gt;
&lt;p&gt;在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.&lt;/p&gt;

&lt;h2 id=&quot;机器数&quot;&gt;机器数&lt;/h2&gt;
&lt;p&gt;一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.&lt;/p&gt;

&lt;p&gt;比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。&lt;/p&gt;

&lt;p&gt;那么，这里的 00000011 和 10000011 就是机器数。&lt;/p&gt;

&lt;h2 id=&quot;真值&quot;&gt;真值&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131?&amp;gt;（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;原码-反码-补码的基础概念和计算方法&quot;&gt;原码, 反码, 补码的基础概念和计算方法&lt;/h1&gt;

&lt;p&gt;在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.&lt;/p&gt;

&lt;h2 id=&quot;原码&quot;&gt;原码&lt;/h2&gt;

&lt;p&gt;原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[+1]原 = 0000 0001&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;[-1]原 = 1000 0001&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1111 1111 , 0111 1111] 即 [-127 , 127]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原码是人脑最容易理解和计算的表示方式.&lt;/p&gt;

&lt;h2 id=&quot;反码&quot;&gt;反码&lt;/h2&gt;

&lt;p&gt;反码的表示方法是:&lt;/p&gt;

&lt;p&gt;正数的反码是其本身&lt;/p&gt;

&lt;p&gt;负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[+1] = [00000001]原 = [00000001]反&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;[-1] = [10000001]原 = [11111110]反&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.&lt;/p&gt;

&lt;h2 id=&quot;补码&quot;&gt;补码&lt;/h2&gt;

&lt;p&gt;补码的表示方法是:&lt;/p&gt;

&lt;p&gt;正数的补码就是其本身&lt;/p&gt;

&lt;p&gt;负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[+1] = [00000001]原 = [00000001]反 = [00000001]补&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;[-1] = [10000001]原 = [11111110]反 = [11111111]补&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.&lt;/p&gt;

&lt;h1 id=&quot;为何要使用原码-反码和补码&quot;&gt;为何要使用原码, 反码和补码&lt;/h1&gt;

&lt;p&gt;在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法.&lt;/p&gt;

&lt;p&gt;现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[+1] = [00000001]原 = [00000001]反 = [00000001]补&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以不需要过多解释. 但是对于负数:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[-1] = [10000001]原 = [11111110]反 = [11111111]补&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?&lt;/p&gt;

&lt;p&gt;首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.&lt;/p&gt;

&lt;p&gt;于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:&lt;/p&gt;

&lt;p&gt;计算十进制的表达式: 1-1=0&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.&lt;/p&gt;

&lt;p&gt;为了解决原码做减法的问题, 出现了反码:&lt;/p&gt;

&lt;p&gt;计算十进制的表达式: 1-1=0&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.&lt;/p&gt;

&lt;p&gt;于是补码的出现, 解决了0的符号以及两个编码的问题:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)&lt;/p&gt;

&lt;p&gt;使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].&lt;/p&gt;

&lt;p&gt;因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.&lt;/p&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://yanhaijing.com/javascript/2016/07/20/binary-in-js/&quot;&gt;聊聊JavaScript中的二进制数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html&quot;&gt;原码, 反码, 补码 详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points/&quot;&gt;每一个JavaScript开发者应该了解的浮点知识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="基础知识" /><summary type="html">机器数和真值 在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.</summary></entry><entry><title type="html">常用的后台管理主题模板</title><link href="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/10/31/admin-theme/" rel="alternate" type="text/html" title="常用的后台管理主题模板" /><published>2017-10-31T00:00:00+00:00</published><updated>2017-10-31T00:00:00+00:00</updated><id>/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/10/31/admin-theme</id><content type="html" xml:base="/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/2017/10/31/admin-theme/">&lt;h2 id=&quot;常用后台管理主题推荐&quot;&gt;常用后台管理主题推荐&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;jQuey: &lt;a href=&quot;http://www.bootcss.com/&quot;&gt;Bootstrap&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;React: &lt;a href=&quot;https://ant.design/index-cn&quot;&gt;ant.design&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Vue: &lt;a href=&quot;http://element.eleme.io/#/zh-CN/component/layout&quot;&gt;Element&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;个人感觉基于bootstrap的管理模板都大同小异参考文章中的内容基本可以满足需求推荐以下免费主题供大家参考&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://thetheme.io/theadmin/&quot;&gt;thetheme.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://flatfull.com/themes/flatkit/angular/#/app/dashboard&quot;&gt;flatfull.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wrappixel.com/demos/free-admin-templates/matrix-admin/index.html&quot;&gt;matrix-admin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://demo.thedevelovers.com/dashboard/klorofil-v2.0/icons.html&quot;&gt;KLOROFIL&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://adminlte.io/themes/AdminLTE/pages/UI/sliders.html&quot;&gt;adminlte.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wrappixel.com/demos/admin-templates/pixeladmin/inverse/index.html&quot;&gt;pixeladmin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://akveo.com/blur-admin-mint/#/tables/basic&quot;&gt;akveo 这个挺快&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://akveo.com/ngx-admin/#/pages/dashboard&quot;&gt;ngx-admin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考文章&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://colorlib.com/wp/free-bootstrap-admin-dashboard-templates/&quot;&gt;20 Free Bootstrap 3 Admin Dashboard Templates For Your Web App 2017&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://elements.envato.com/web-templates/admin-templates&quot;&gt;admin templates&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://athemes.com/collections/free-bootstrap-admin-templates/&quot;&gt;20 Best Free Bootstrap Admin Templates 2017&lt;/a&gt;
&lt;a href=&quot;https://cssauthor.com/bootstrap-admin-templates/&quot;&gt;100+ Best Free Bootstrap Admin Templates&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="html" /><category term="管理系统主题" /><summary type="html">常用后台管理主题推荐</summary></entry><entry><title type="html">娱乐</title><link href="/%E5%A8%B1%E4%B9%90/2017/10/29/entertainment/" rel="alternate" type="text/html" title="娱乐" /><published>2017-10-29T00:00:00+00:00</published><updated>2017-10-29T00:00:00+00:00</updated><id>/%E5%A8%B1%E4%B9%90/2017/10/29/entertainment</id><content type="html" xml:base="/%E5%A8%B1%E4%B9%90/2017/10/29/entertainment/">&lt;h2 id=&quot;justfun&quot;&gt;justfun&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wall.alphacoders.com/by_collection.php?id=39&amp;amp;lang=Chinese&amp;amp;page=1&quot;&gt;壁纸&lt;/a&gt;&lt;/p&gt;</content><author><name>toshiba</name></author><category term="娱乐" /><summary type="html">justfun</summary></entry><entry><title type="html">git的使用教程(一)</title><link href="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/10/12/git-base/" rel="alternate" type="text/html" title="git的使用教程(一)" /><published>2017-10-12T00:00:00+00:00</published><updated>2017-10-12T00:00:00+00:00</updated><id>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/10/12/git-base</id><content type="html" xml:base="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2017/10/12/git-base/">&lt;h2 id=&quot;git的初级使用教程&quot;&gt;git的初级使用教程&lt;/h2&gt;

&lt;p&gt;记录常用的git命令,方便自己查询&lt;/p&gt;

&lt;h2 id=&quot;创建新仓库&quot;&gt;创建新仓库&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$  git init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##检出新仓库&lt;/p&gt;
&lt;h3 id=&quot;clone本地仓库&quot;&gt;clone本地仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$  git clone /path/to/repository
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;从远程仓库clone&quot;&gt;从远程仓库clone&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$  git clone username@host:/path/to/repository
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;工作流&quot;&gt;工作流&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://darknights.b0.upaiyun.com/assets/images/in-post/git-base/trees.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;添加和提交&quot;&gt;添加和提交&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$  git add &amp;lt;filename&amp;gt;
$  git add *
$  git add .     //添加到缓存区

$  git commit -m &quot;代码提交信息&quot;   //提交到本地仓库

$ git commit -a  相当于 git add + git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;推送改动&quot;&gt;推送改动&lt;/h3&gt;
&lt;p&gt;你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以把 master 换成你想要推送的任何分支。&lt;/p&gt;

&lt;p&gt;如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  git remote add origin &amp;lt;server&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;远程仓库&quot;&gt;远程仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git remote -v //显示远程仓库信息

$ git remote rm origin  //删除远程链接

$ git remote set-url origin git@github.com:michaelliao/learngit.git  //更改远程仓库地址,通常用来切换ssh和https

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此你就能够将你的改动推送到所添加的服务器上去了。&lt;/p&gt;

&lt;h3 id=&quot;分支&quot;&gt;分支&lt;/h3&gt;
&lt;p&gt;分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。
&lt;img src=&quot;https://darknights.b0.upaiyun.com/assets/images/in-post/git-base/branches.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建一个叫做“feature_x”的分支，并切换过去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch 查看本地分支

$ git branch -a 查看本地和本地fetch到的远程分支都显示出来

$ git branch -r 查看本地fetch到的远程分支(只显示本地存储的远程分支)

$ git checkout -b feature_x


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换回主分支：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  git checkout master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再把新建的分支删掉：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  git branch -d feature_x //删除已经合并的分支
$  git branch -D feature_x  //强行删除未合并的分支
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重命名分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -m devel develop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  git push origin &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;更新与合并&quot;&gt;更新与合并&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$  git pull   //相当于 git fetch and git merge两个操作
$  git diff &amp;lt;source_branch&amp;gt; &amp;lt;target_branch&amp;gt;  //如果有冲突解决完冲突可以这样查看两个分支差别
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;标签&quot;&gt;标签&lt;/h3&gt;
&lt;p&gt;以执行如下命令创建一个叫做 1.0.0 的标签：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  git	 tag v1.0.0 1b2e1d63ff //b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符

$  git tag  //显示所有tag标签

$  git show v1.0 //查看标签信息

//打一个完整的标签 -a 制定标签的名字  -m 注释   最后的数字代表HEAD制定从哪次提交打标签
$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164


$ git tag -d v1.0 //删除本地标签

$ git push origin :refs/tags/v0.9   //删除远程标签 需要先将本地标签删除

$ git push origin v1.0   //将标签推送到远程仓库



$ git push origin --tags //一次性推送全部尚未推送到远程的本地标签：

//使用 gpg(GnuPG)签名来打标签但是不常用
$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;log&quot;&gt;log&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$  git log //查看所有日志

$  git log --author=toshiba  //查看某人的日志

$  git log --pretty=oneline  //压缩后的日志每个提交只占一行

$  git log --graph --oneline --decorate --all  //ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签

$  git log --graph --pretty=oneline --abbrev-commit

$  git log --name-status  //查看都有哪些文件修改过了

$  git log --help  //更多的帮助信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;git-fetch&quot;&gt;git fetch&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#拉取仓库中所有的分支。同时会从另一个仓库中下载所有需要的提交和文件。

$ git fetch &amp;lt;remote&amp;gt;


#和上一个命令相同，但只拉取指定的分支。

$git fetch &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;替换本地改动&quot;&gt;替换本地改动&lt;/h3&gt;
&lt;p&gt;假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  git checkout -- &amp;lt;filename&amp;gt; //此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。
    //已添加到暂存区的改动以及新文件都不会受到影响。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  git fetch origin
$  git reset --hard origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;实用小贴士&quot;&gt;实用小贴士&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$  gitk           					//内建的图形化 git

$  git config color.ui true          //彩色的 git 输出

$  git config --global color.ui true

$  git config format.pretty oneline  //显示历史记录时，每个提交的信息只显示一行

$  git add -i 							//交互式添加文件到暂存区：

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot;&gt;git - 简明指南&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="工具" /><category term="git" /><summary type="html">git的初级使用教程</summary></entry><entry><title type="html">LeetCode,LintCode,Hihocoder刷题指南</title><link href="/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/2017/10/12/interview/" rel="alternate" type="text/html" title="LeetCode,LintCode,Hihocoder刷题指南" /><published>2017-10-12T00:00:00+00:00</published><updated>2017-10-12T00:00:00+00:00</updated><id>/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/2017/10/12/interview</id><content type="html" xml:base="/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/2017/10/12/interview/">&lt;h1 id=&quot;通过题目训练来提升自己的编程能力&quot;&gt;通过题目训练来提升自己的编程能力&lt;/h1&gt;

&lt;h2 id=&quot;leetcode&quot;&gt;&lt;a href=&quot;https://leetcode.com/&quot;&gt;LeetCode&lt;/a&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;LeetCode 是一个非常棒的 OJ（Online Judge）平台，收集了许多公司的面试题目。相对其他 OJ 平台而言，有着下面的几个优点：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;题目全部来自业内大公司的真实面试&lt;/li&gt;
    &lt;li&gt;不用处理输入输出，精力全放在解决具体问题上&lt;/li&gt;
    &lt;li&gt;题目有丰富的讨论，可以参考别人的思路&lt;/li&gt;
    &lt;li&gt;精确了解自己代码在所有提交代码中运行效率的排名&lt;/li&gt;
    &lt;li&gt;支持多种主流语言：C/C++，Python, Java&lt;/li&gt;
    &lt;li&gt;可以在线进行测试，方便调试&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.lintcode.com/zh-cn/&quot;&gt;LintCode&lt;/a&gt;
&lt;a href=&quot;http://hihocoder.com/&quot;&gt;Hihocoder&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考文章&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://crispgm.com/page/48-tips-for-jekyll-you-should-know.html&quot;&gt;48 个你需要知道的 Jekyll 使用技巧
&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.zhanxin.info/journal/&quot;&gt;掌心&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://blog.ixxoo.me/&quot;&gt;likebeta’s Blog
&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/maoxunxing/article/details/40479753&quot;&gt;jekyll翻译文章&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://ibloodline.com/articles/2014/12/15/jekyll-syntax.html&quot;&gt;jekyll语法简单笔记&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://alfred-sun.github.io/blog/2014/12/05/github-pages/&quot;&gt;GitHub Pages 静态博客 - 个人建站实录
&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://harttle.com/2013/10/18/github-homepage-tutorial.html&quot;&gt;部署自己的博客&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://mritd.me/2017/02/25/jekyll-blog-+-travis-ci-auto-deploy/&quot;&gt;杨缘的博客参考&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://yerl.cn/blog/use-jekyll-build-your-blog&quot;&gt;poison&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://jekyllcn.com/docs/plugins/&quot;&gt;jekyll官网中文&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.thomaszhao.cn/2015/01/08/how-do-i-build-this-jekyll-blog/&quot;&gt;适合程序员的Blog – 基于github pages + jekyll + markdown打造自己的blog&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.w3cboy.com/post/2016/03/travisci-hexo-deploy/&quot;&gt;使用travis-ci自动部署hexo博客&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>toshiba</name></author><category term="interview" /><category term="JavaScript" /><summary type="html">通过题目训练来提升自己的编程能力</summary></entry><entry><title type="html">使用travis-ci集成项目,自动部署博客站点</title><link href="/2017/09/05/blog-static-nginx/" rel="alternate" type="text/html" title="使用travis-ci集成项目,自动部署博客站点" /><published>2017-09-05T00:00:00+00:00</published><updated>2017-09-05T00:00:00+00:00</updated><id>/2017/09/05/blog-static-nginx</id><content type="html" xml:base="/2017/09/05/blog-static-nginx/">&lt;p&gt;categories:
    - 技术文章&lt;/p&gt;

&lt;h1 id=&quot;第一次搭建博客&quot;&gt;第一次搭建博客&lt;/h1&gt;

&lt;h1 id=&quot;参考文章&quot;&gt;参考文章&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://crispgm.com/page/48-tips-for-jekyll-you-should-know.html&quot;&gt;48 个你需要知道的 Jekyll 使用技巧
&lt;/a&gt;
&lt;a href=&quot;http://www.zhanxin.info/journal/&quot;&gt;掌心&lt;/a&gt;
&lt;a href=&quot;https://blog.ixxoo.me/&quot;&gt;likebeta’s Blog
&lt;/a&gt;
&lt;a href=&quot;http://blog.csdn.net/maoxunxing/article/details/40479753&quot;&gt;jekyll翻译文章&lt;/a&gt;
&lt;a href=&quot;http://ibloodline.com/articles/2014/12/15/jekyll-syntax.html&quot;&gt;jekyll语法简单笔记&lt;/a&gt;
&lt;a href=&quot;http://alfred-sun.github.io/blog/2014/12/05/github-pages/&quot;&gt;GitHub Pages 静态博客 - 个人建站实录
&lt;/a&gt;
&lt;a href=&quot;http://harttle.com/2013/10/18/github-homepage-tutorial.html&quot;&gt;部署自己的博客&lt;/a&gt;
&lt;a href=&quot;https://mritd.me/2017/02/25/jekyll-blog-+-travis-ci-auto-deploy/&quot;&gt;杨缘的博客参考&lt;/a&gt;
&lt;a href=&quot;http://yerl.cn/blog/use-jekyll-build-your-blog&quot;&gt;poison&lt;/a&gt;
&lt;a href=&quot;http://jekyllcn.com/docs/plugins/&quot;&gt;jekyll官网中文&lt;/a&gt;
&lt;a href=&quot;http://www.w3cboy.com/post/2016/03/travisci-hexo-deploy/&quot;&gt;使用travis-ci自动部署hexo博客&lt;/a&gt;&lt;/p&gt;</content><author><name>toshiba</name></author><category term="博客搭建" /><category term="jekyll" /><summary type="html">categories: - 技术文章</summary></entry></feed>